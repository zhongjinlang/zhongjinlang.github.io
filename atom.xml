<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T05:58:49.409Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis复制原理</title>
    <link href="http://yoursite.com/2019/04/07/redis%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/07/redis复制原理/</id>
    <published>2019-04-07T01:45:28.000Z</published>
    <updated>2019-04-08T05:58:49.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-master-slave.jpg" alt></p><p>单机部署redis所存在的问题：机器故障数据转移、容量瓶颈、QPS瓶颈</p><p>主节点master负责<strong>写数据</strong>，从节点slave负责<strong>读数据</strong>，主节点定期把数据同步到从节点保证数据的一致性</p><blockquote><p>主从复制的作用：数据副本（高可用分布式基础）、读写分离提高性能</p></blockquote><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><p><strong>命令slaveof</strong>和配置文件的方式</p><h3 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a>slaveof</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6380节点（从）复制6379节点（主）</span></span><br><span class="line">redis-6380 &gt; slaveof 192.168.211.134:6379 OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消复制（不希望成为从），此时会断开连接（从数据并不会丢失，而是主的数据不会同步给从）</span></span><br><span class="line">redis-6380 &gt; slaveof no one OK</span><br></pre></td></tr></table></figure><h2 id="主从复制实验"><a href="#主从复制实验" class="headerlink" title="主从复制实验"></a>主从复制实验</h2><ul><li><p>我们通过配置文件的方式实现 6379作为主节点、6380为从节点</p></li><li><p>其中有两个中要的配置slaveof ip port、slave-read-only yes（期望从节点只作读操作）目的是达到主从复制数据的一致性效果。保证主节写操作，而从节点只作为读操作</p></li><li><p>cp redis.conf两份分别命名为 redis-6379.conf、redis-6380.conf</p></li></ul><h3 id="redis-6379-conf"><a href="#redis-6379-conf" class="headerlink" title="redis-6379.conf"></a>redis-6379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启守护者进程</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta">#</span><span class="bash">进程id</span></span><br><span class="line">pidfile /var/run/redis-6379.pid </span><br><span class="line"><span class="meta">#</span><span class="bash"> 主节点密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile "6379.log"</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb文件</span></span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置主从关系</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只读，主节点不关心</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分片信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication </span><br><span class="line">role:master # 主节点</span><br><span class="line">connected_slaves:0 # 所连接的从节点个数</span><br></pre></td></tr></table></figure></li></ul><h3 id="redis-6380-conf"><a href="#redis-6380-conf" class="headerlink" title="redis-6380.conf"></a>redis-6380.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 开启守护者进程</span><br><span class="line">pidfile /var/run/redis-6380.pid #进程id</span><br><span class="line">port 6380</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dbfilename dump-6380.rdb # rdb文件</span><br><span class="line">slaveof 192.168.211.134 6379 # 成为6379的从节点</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从节点只作为读操作</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">127.0.0.1:6379&gt; info replication # 查看分片信息</span><br><span class="line">role:slave # 已成为从节点</span><br><span class="line">master_host:192.169.211.134 # 主节点地址</span><br><span class="line">master_port:6379 # 主节点端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>从主节点6379端口中set值，从节点会复制主节点的数据<br><img src="http://poporz7f8.bkt.clouddn.com/redis-test.jpg" alt></p><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><p>主从复制的读写分离实际上内部使用命令的方式进行数据的同步，我们可以分析两个日志文件</p><h2 id="6379-log"><a href="#6379-log" class="headerlink" title="6379.log"></a>6379.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6379log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示6380需要进行复制操作</span></span><br><span class="line">Slave 192.168.211.134:6380 asks for synchronization</span><br><span class="line"><span class="meta">#</span><span class="bash"> resync 全量复制操作</span></span><br><span class="line">Full resync requested by slave 192.168.211.134:6380</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现复制操作是使用RDB进行实现的，实际就是将快照进行同步</span></span><br><span class="line">Starting BGSAVE for SYNC with target: disk</span><br></pre></td></tr></table></figure><h2 id="6380-log"><a href="#6380-log" class="headerlink" title="6380.log"></a>6380.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6380log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接主节点</span></span><br><span class="line">Connecting to MASTER 192.168.211.134:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主从复制</span></span><br><span class="line">MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master的runid（每一个redis启动时的随机ID）</span></span><br><span class="line">Full resync from master: f45a09af5ab5fe887ad7a33b451e4955b1dafebd:1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master节点数据(rbd)</span></span><br><span class="line">receiving 31 bytes from master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空之前的数据(全量复制的情况下)</span></span><br><span class="line">Flushing old data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载rdb</span></span><br><span class="line">Loading DB in memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载成功</span></span><br><span class="line">Finished with success</span><br></pre></td></tr></table></figure><h2 id="验证Flushing-old-data"><a href="#验证Flushing-old-data" class="headerlink" title="验证Flushing old data"></a>验证Flushing old data</h2><p>我们可以看到上述6380日志，当拿到master节点之后做的事情，清空旧的数据、加载RDB，如下实验验证是否安装该流程进行的</p><ul><li><p>先将6380成为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> slaveof no one</span></span><br></pre></td></tr></table></figure></li><li><p>切换到6379添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">mset a b c d</span><br></pre></td></tr></table></figure></li><li><p>再切换到6380执行如下操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时成为master当然不能同步数据</span></span><br><span class="line">keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一些数据</span></span><br><span class="line">127.0.0.1:6380&gt; set abc6380 hello</span><br><span class="line">127.0.0.1:6380&gt; slaveof 192.168.211.134 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) "c"</span><br><span class="line">2) "a"</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们可以看到当slaveof继续成为从节点时候，再获取数据时之前的abc6379已被删除</p></blockquote><h1 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h1><p>我们在分析日志的时候发现，master有resync(全量复制)、slave有获取masterRUNID的一些操作，引入我们引入两个概念 <strong>runid</strong> 以及 <strong>偏移量</strong></p><h2 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h2><p>每一个redis服务启动时，都会随机一个字符串id，作为一个标识。如果重启之后，runid会消失</p><ul><li>查看runid<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 6379 info server | grep run</span><br><span class="line">run_id:f45a09af5ab5fe887ad7a33b451e4955b1dafebd</span><br><span class="line">[root@localhost config]# redis-cli -p 6380 info server | grep run</span><br><span class="line">run_id:e93481fdcc9e791516c77f8a61a3e7e5e2db4f9e</span><br></pre></td></tr></table></figure></li></ul><p>当复制时发现和之前的 run_id不同时（重启），将会对数据全量同步，一般用于初次复制场景</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>一个数据写入量的字节(如 set a b)，此时从节点会同步记录偏移量，当主从偏移量达到一至时，那么就完成了数据同步的过程。简言之：通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致 </p><blockquote><p>如果主、从偏移量不一至。master &gt; slave可能会出现主从不一致</p></blockquote><ul><li>查看偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:48425</span><br></pre></td></tr></table></figure></li></ul><p>当我们添加值时，偏移量也会随着增加</p><ul><li>查看主、从偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:49146</span><br><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6380 info replication</span><br><span class="line">slave_repl_offset:49170</span><br></pre></td></tr></table></figure></li></ul><p>为什么主从偏移量不一致呢？实际上主从的偏移量是一个同步更新的状态，从节点会将一些状态向主节点上报。我们也可查看主从的同步状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">slave0:ip=192.168.211.134,port=6380,state=online,offset=49482,lag=2</span><br><span class="line">master_repl_offset:49482</span><br></pre></td></tr></table></figure></p><blockquote><p>通常offset差距不会太大，否则可能有其他问题如网络、阻塞</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-slavecopy.jpg" alt></p><p>如果对于一个存了很多数据的master，slave期望复制master中的数据，并且这些数据是时刻同步的、完整的。这样就可达到完整的数据同步效果。</p><ul><li>首先将本身的RDB文件同步给slave，为了达到时刻同步，在此期间，master写入的命令也会记录下来。当slave将RDB加载完后，会通过偏移量的对比将这期间master写入的值同步给slave</li></ul><ol><li><p>首先slave发送命令psync ? -1，参数1:runid，参数2：偏移量（报告主节点偏移量）。由于第一次复制不知道runid和偏移量，所以参数为?和-1</p></li><li><p>master接收到此命令，将runid和偏移量发送给slave</p></li><li><p>slave保存master的基本信息</p></li><li><p>master会执行bgsave（rdb生成）</p></li></ol><blockquote><p>此时怎么将RDB发送给salve呢？master内部有复制缓冲区reple_back_buffer，它可记录最新的数据</p></blockquote><ol start="5"><li><p>经过了缓冲区的过滤，将RDB和缓存的一些信息发送给slave(5-6步骤)</p></li><li><p>slave先清空自己old数据</p></li><li><p>加载RDB以及缓存数据完成同步</p></li></ol><h1 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h1><p>经过上述分析，我们可以明显感受到，全量复制的开销是巨大的。有如下几个问题</p><ul><li>bgsave时间，需要生成RDB</li><li>RDB文件网络传输时间</li><li>slave清空old的时间</li><li>slave加载RDB的时间</li><li>可能的AOF重写时间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://poporz7f8.bkt.clouddn.com/redis-master-slave.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>elasticsearch+filebeat+kibana日志收集</title>
    <link href="http://yoursite.com/2019/04/06/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/04/06/ELK日志收集/</id>
    <published>2019-04-06T13:18:14.000Z</published>
    <updated>2019-04-07T01:08:19.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>对大规模日志数据进行采集、追踪、分析及处理</p><p>目前主流的分布式日志框架有：</p><ul><li><p>Logstash ELK(ElasticsSearch, Logstash, Kibana) – 一套强大的日志收集系统，由于Logstash消耗资源过大，官方推荐使用filebeat取代</p></li><li><p>Flume – 由Apache基金会提供的一个分布式、高可靠、高可用的服务</p></li><li><p>filebeat用于日志的收集、elasticsearch用于存储日志、kibana实现数据的展示</p></li><li><p>download: <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases</a></p></li></ul><h1 id="elasticsearch-install"><a href="#elasticsearch-install" class="headerlink" title="elasticsearch install"></a>elasticsearch install</h1><ul><li><p>es启动不能使用root，因此需要创建一个用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd es</span><br><span class="line">useradd es -g es</span><br><span class="line">passwd es</span><br></pre></td></tr></table></figure></li><li><p>切换root进入es目录为es文件给予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es es es-5.6.16</span><br></pre></td></tr></table></figure></li><li><p>修改/conf/elasticsearch.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Network </span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">network.host: ip  </span><br><span class="line"><span class="meta">#</span> 默认http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta">#</span> 默认tcp端口</span><br><span class="line">transport.tcp.port: 9300</span><br></pre></td></tr></table></figure></li><li><p>修改jvm内存大小 /conf/jvm.options</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xms1g</span><br></pre></td></tr></table></figure></li><li><p>由于es启动需要开启大量线程，需要修改系统文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vi /etc/security/limits.conf</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> cd /etc/security/limits.d</span><br><span class="line">vi 20-nproc.conf</span><br><span class="line">root       soft    nproc     2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> vi /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>su es &gt; ./elasticsearch 如果启动不了设置防火墙</p></blockquote><h1 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h1><p>Filebeat是一个轻量型日志采集器，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放</p><ul><li>安装完之后编辑核心配置文件filebeat.yml</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 指定被探测的日志文件, 可添加多个该配置</span><br><span class="line">paths:</span><br><span class="line">    - /install/logs/*.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置多行合并</span><br><span class="line">multiline.pattern: ^\[</span><br><span class="line">multiline.negate: true</span><br><span class="line">multiline.match: after    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定es的位置，将日志收集到es存储</span><br><span class="line">output.elasticsearch:</span><br><span class="line"><span class="meta">  #</span> Array of hosts to connect to.</span><br><span class="line">  hosts: ["192.168.211.134:9200"]</span><br></pre></td></tr></table></figure><blockquote><p>./filebeat 启动</p></blockquote><blockquote><p>日志收集测试 : 当配置的探测日志文件发生变化时，filebeat会将数据发送给ES进行存储</p></blockquote><h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p>kibana可取代elastic-head，提供了更为专业的可视化界面、日志分析系统，它是ES的成员之一</p><ul><li>安装完之后配置kibana.yml核心配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认端口</span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">server.host: "192.168.211.134"</span><br><span class="line"><span class="meta">#</span> 指定es的地址</span><br><span class="line">elasticsearch.url: "http://192.168.211.134:9200"</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">cd bin &gt; ./kibana</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;p&gt;对大规模日志数据进行采集、追踪、分析及处理&lt;/p&gt;
&lt;p&gt;目前主流的分布式日志框架有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Logstash E
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis的持久化</title>
    <link href="http://yoursite.com/2019/04/06/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/06/redis的持久化/</id>
    <published>2019-04-05T16:55:05.000Z</published>
    <updated>2019-04-05T17:57:02.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h1><p>redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 <strong>Redis</strong> 提供了两种<strong>持久化</strong>的方案，将内存中的数据保存到磁盘中，避免数据的丢失</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><blockquote><p>该机制使用快照方式，在指定的时间内将内存中的数据写入到硬盘（rdb文件），也可手动执行命令</p></blockquote><ul><li>文件策略：如果存在老的RDB文件，会进行替换</li><li>优点：RBD作为一个备份文件容易恢复，性能好，通过子进程fork生成rdb，用于备份</li><li>缺点：容易造成数据丢失，如果fork花费时间大，那么将会阻塞redis服务、耗时耗性能</li></ul><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><ul><li>save命令（同步 ） — 可能会产生阻塞</li><li>bgsave命令（异步）— <strong>创建一个子进程fork() </strong>生成rdb文件（阻塞发生在<br>fork），创建完毕返回给主进程bgsave successfully</li><li>自动 — 根据save配置自动生成，例如如果在60秒内改变了1w条数据则生成rdb、300-10、900-1满足任一个条件（底层使用fork）</li></ul><p>在redis.conf中节点为SNAPSHOTTING中有如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta">#</span><span class="bash"> bgsave发生错误是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb是否采用压缩格式</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd校验</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认rbd文件名，在/bin目录</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志等文件存储位置</span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p>推荐配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不采用自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd文件名称采用+端口形式区分</span></span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议指定容量较大硬盘位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他默认</span></span><br></pre></td></tr></table></figure><blockquote><p>不容忽略的方式：主从复制、debug reload、shutdown可能会触发</p></blockquote><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB快照方式并不是很可靠，如果服务器宕机，那么最新的数据就会丢失。而AOF文件提供一种更为可靠的的持久化方式。当进行set操作时，会追加到AOF文件中。当redis重启之后，AOF中的命令会被重新执行一次，重建数据</p><h2 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-aof.jpg" alt></p><ul><li>always：每条命令都会持久化一次（执行写操作时，先进入缓冲区后写入到硬盘）</li><li>everysec：每秒持久化一次</li><li>no：缓冲区的刷新策略根据OS决定</li></ul><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>由于每条命令都会追加到AOF文件中，随着时间的推移，AOF文件必然逐渐变大。AOF重写解决了这一问题</p><ul><li>例 ：命令优化、过期数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hello one</span><br><span class="line">set hello two</span><br><span class="line">set hello three</span><br></pre></td></tr></table></figure><p>当连续执行上诉命令最终的结果为three，而AOF并不会写入三次命令，而只会追加有效的命令set hello three</p><ul><li><p>AOF重写实现的两种方式</p><blockquote><p>bgrewriteaof命令：（类似RDB的bgsave）开启子线程完成AOF重写</p></blockquote><blockquote><p>AOF重写配置</p></blockquote></li></ul><p>在/redis.conf配置文件有APPEND ONLY MODE节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要完成aof功能开启为yes</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 三种同步策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always</span></span><br><span class="line">appendfsync everysec -- 每秒写入（默认）</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入aof文件，不等待磁盘同步（安全，但可能阻塞）</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><h1 id="RDB和AOF的抉择"><a href="#RDB和AOF的抉择" class="headerlink" title="RDB和AOF的抉择"></a>RDB和AOF的抉择</h1><blockquote><p>比较 </p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-rdb-aof.jpg" alt></p><blockquote><p>RDB最佳策略</p></blockquote><ul><li>“关闭”rdb</li><li>集中管理，指定时间内进行大量的数据备份</li><li>从节点开启</li><li>分片</li></ul><blockquote><p>AOF最佳策略</p></blockquote><ul><li>“开启” ： 缓存和存储</li><li>AOF重写集中管理</li><li>everysec策略</li><li>分片</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>当进行 RDB的<strong>bgsave</strong>操作和AOF的<strong>bgrewriteaof</strong>会产生子线程进行持久化的相关操作，如果fork操作执行慢，此时会将redis主线程阻塞。 </p><ul><li>查看fork持久化的时间</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latest_fork_usec</span><br></pre></td></tr></table></figure><ul><li><p>改善</p><blockquote><p>物理机或支持fork操作的虚拟化技术</p></blockquote><blockquote><p>控制redis实例最大可用内存：maxmemory</p></blockquote><blockquote><p>合理配置Linux内存分配策略：vm.overcommit_memory=1（默认0）</p></blockquote><blockquote><p>放宽AOF重写自动触发机制，不必全量复制</p></blockquote></li></ul><h2 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h2><blockquote><p>bgsave和bgrewriteaof是将内存中的数据写入到硬盘，此时会集中消耗CPU、rork内存开销、硬盘</p></blockquote><ul><li><p>优化</p><blockquote><p>不做CPU绑定，不和CPU密集部署，单机部署不要大量的AOF和RDB持久化的过程</p></blockquote><blockquote><p>echo never &gt; 追加配置文件</p></blockquote><blockquote><p>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</p></blockquote><blockquote><p>配置no-appendfsync-on-rewrite yes </p></blockquote><blockquote><p>ssd介质</p></blockquote></li></ul><h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><p>如果我们使用了AOF的每秒刷盘策略，如果fork执行大于2秒，那么主线程阻塞</p><ul><li><p>阻塞定位</p><blockquote><p>redis日志</p></blockquote><blockquote><p>info persistence收集记录</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持久化的作用&quot;&gt;&lt;a href=&quot;#持久化的作用&quot; class=&quot;headerlink&quot; title=&quot;持久化的作用&quot;&gt;&lt;/a&gt;持久化的作用&lt;/h1&gt;&lt;p&gt;redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>瑞士军刀redis</title>
    <link href="http://yoursite.com/2019/04/05/%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80redis/"/>
    <id>http://yoursite.com/2019/04/05/瑞士军刀redis/</id>
    <published>2019-04-05T14:51:03.000Z</published>
    <updated>2019-04-05T17:36:07.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><p>许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息（例如：发生时间、耗时、命令的详细信息）记录下来，Redis也提供了类似的功能。</p><ul><li>首先我们需要先了解client和serve的生命周期</li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-server.jpg" alt></p><hr><blockquote><p>慢查询发生在第三阶段</p></blockquote><blockquote><p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p></blockquote><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><p>多数情况下，我们会通过请求-响应的机制来操作redis。当要执行多个命令时，由于redis是单线程的，那么下一次请求必须等待上一次请求完成之后才可继续执行。而pipeline模式，客户端可一次性将命令打包发送，</p><blockquote><p>无需等待服务端返回。这样就减少了网络往返时间。</p></blockquote><ul><li>使用传统方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashKey:"</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">//2983</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用pipeline</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        pipeline.hset(<span class="string">"hashKey: "</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">// 38</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>位图：基于最小的单位bit进行存储，非常省空间、二进制数据存储，计算快</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 取出位图指定索引的值</span><br><span class="line">getbit element 0</span><br></pre></td></tr></table></figure><ul><li>使用场景：独立用户统计（一亿用户，五千万独立）</li></ul><blockquote><p>set存储: 内存量200mb</p></blockquote><blockquote><p>bitmap存储：内存量12.5mb</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;慢查询&quot;&gt;&lt;a href=&quot;#慢查询&quot; class=&quot;headerlink&quot; title=&quot;慢查询&quot;&gt;&lt;/a&gt;慢查询&lt;/h1&gt;&lt;p&gt;许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redisAPI</title>
    <link href="http://yoursite.com/2019/04/05/redisAPI/"/>
    <id>http://yoursite.com/2019/04/05/redisAPI/</id>
    <published>2019-04-05T14:50:50.000Z</published>
    <updated>2019-04-05T17:33:24.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><ul><li>keys[patten]（查看所有的key）</li><li>dbsiz（查看所有key的大小）</li><li>exists key（判断一个key是否存在）</li><li>del key [key ..] （删除key）</li><li>expice key seconds（为key设置过期时间）</li><li>type key（查看key类型）</li></ul><h1 id="内部编码架构"><a href="#内部编码架构" class="headerlink" title="内部编码架构"></a>内部编码架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-code.jpg" alt></p><hr><h1 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sing.jpg" alt></p><hr><blockquote><p><strong>当我们在操作redis时，时刻要明白redis在一个瞬间只会执行一条命令，不会执行两条命令</strong></p></blockquote><ul><li><p>单线程为何快？</p><blockquote><p>纯内存</p></blockquote><blockquote><p>非阻塞IO</p></blockquote><blockquote><p>避免线程之间的切换和竞态消耗</p></blockquote></li></ul><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string的value可存储普通字符串、数值、二进制、JSON。使用场景：缓存、计数器、分布式锁</p><ul><li>基本命令  get、set、del（O1）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取key对应的value</span><br><span class="line">get key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置key-value</span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除key-value</span><br><span class="line">del key</span><br></pre></td></tr></table></figure><ul><li>计数命令 incr 、decr、incrby、decrby（O1）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> key自增1，0开始</span><br><span class="line">incr key</span><br><span class="line"><span class="meta">#</span> 相反</span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 期望自增指定值，key自增k</span><br><span class="line">incrby key k</span><br><span class="line"><span class="meta">#</span> 相反</span><br><span class="line">decrby key k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 浮点数的自增3.5</span><br><span class="line">incrbyfloat key 3.5</span><br></pre></td></tr></table></figure><ul><li>其他set命令 set、setnx、setxx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 不管key是否存在，都设置</span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> key不存在才进行设置（add操作）</span><br><span class="line">setnx key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> key存在才设置（update操作）</span><br><span class="line">set key value xx</span><br></pre></td></tr></table></figure><ul><li>批量处理命令：mget  mset</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 批量获取key</span><br><span class="line">mget key1 key2 ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量设置key-value</span><br><span class="line">mset key1 value1 key2 value2 ...</span><br></pre></td></tr></table></figure><blockquote><p>如果传输n次get命令，那么 <strong>n次get = n次网络时间 + n次命令时间</strong></p></blockquote><blockquote><p>如果1次将命令批量传输给服务端，那么 <strong>1次mget = 1次网络时间 + n次命令时间</strong></p></blockquote><ul><li>其他命令 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 为key设置新的值，并返回之前的值</span><br><span class="line">getset key newvalue</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 为key追加值</span><br><span class="line">append key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 返回字符串长度</span><br><span class="line">strlen key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：</p></blockquote><ul><li>记录网站每个用户个人主页的访问量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr userid:pageview</span><br></pre></td></tr></table></figure><ul><li>缓存视频的基本信息（数据源在mysql）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 从redis中取数据，存在数据直接返回，则不需要访问mysql</span><br><span class="line"><span class="number">2</span>. 若不存在，访问mysql，获取到数据，加入到redis缓存</span><br><span class="line"><span class="number">3</span>. 当下此访问此接口时，会从redis中访问</span><br></pre></td></tr></table></figure><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>hash键值结构：</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-hash.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取hash key对应的field的value</span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置hash key对应file的value</span><br><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除hash key对应file的value</span><br><span class="line">hdel key field value</span><br></pre></td></tr></table></figure><ul><li>hexists、hlen </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 判断hash key是否有filed</span><br><span class="line">hexists key filed</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 获取hash key fiedl的数量</span><br><span class="line">hlen key</span><br></pre></td></tr></table></figure><ul><li>批量操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 批量获取hash key的一批field对应的值</span><br><span class="line">hmget key field1 field2...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 批量设置hash key的一批field value</span><br><span class="line">hmset key field1 value2 ...</span><br></pre></td></tr></table></figure><ul><li>其他命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 返回hash key对应的所有field和value</span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 返回所有的值</span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 返回所有的field</span><br><span class="line">hkeys key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>和string 的使用场景类似、数据缓存等</li></ul><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list 队列结构：有序、可重复、左右两边插入弹出</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-list.jpg" alt></p><hr><ul><li>增加操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 从列表左边插入值</span><br><span class="line">lpush key val1 val2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从列表右边插入值</span><br><span class="line">rpush key val1 val2 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在列表指定值的前|后插入新的值</span><br><span class="line">linsert key before|after value newvalue</span><br></pre></td></tr></table></figure><ul><li>删除操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 从列表左边弹出一个元素</span><br><span class="line">lpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从列表右边弹出一个元素</span><br><span class="line">rpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从列表删除所有value相等的值</span><br><span class="line"><span class="meta">#</span> count=0删除所有、count&gt;0左边开始删除、count&lt;0右边开始删除</span><br><span class="line">lrem key count value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 保留指定索引内的列表元素</span><br><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure><ul><li>查询操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 获取索引内范围的元素</span><br><span class="line">lrange key start end(包含)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 根据指定索引获取元素</span><br><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 列表长度</span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><ul><li>修改操作 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 设置指定索引的值</span><br><span class="line">lset key index newvalue</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>用户抢购进入排队状态（加入队列）</li><li>你关注的人更新文博（LPUSH可看到最新状态、lrange范围查询）</li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>集合特点：无序、无重复、可进行集合间操作（交集、并集）</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-set.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 向集合key添加元素（如果元素存在添加失败）</span><br><span class="line">sadd key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除集合中某个元素</span><br><span class="line">srem key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 计算集合size</span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 判断元素是否在在集合中存在</span><br><span class="line">sismember key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从集合中挑选一个元素（不删除）</span><br><span class="line">srandmember key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 从集合中弹出一个元素(删除)</span><br><span class="line">spop key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 取出集合中所有元素</span><br><span class="line">smembers key</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用命令&quot;&gt;&lt;a href=&quot;#通用命令&quot; class=&quot;headerlink&quot; title=&quot;通用命令&quot;&gt;&lt;/a&gt;通用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;keys[patten]（查看所有的key）&lt;/li&gt;
&lt;li&gt;dbsiz（查看所有key的大小）&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis初识</title>
    <link href="http://yoursite.com/2019/04/05/redis%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2019/04/05/redis初识/</id>
    <published>2019-04-05T14:50:33.000Z</published>
    <updated>2019-04-05T17:34:26.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。</p><h1 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h1><ul><li>多种数据结构<br><img src="http://poporz7f8.bkt.clouddn.com/redis-datastructure.jpg" alt></li></ul><hr><blockquote><p>其中还扩展数据结构有</p></blockquote><blockquote><p>bitmaps：位图 ，（布隆过滤器可使用位图来实现）</p></blockquote><blockquote><p>hyperloglog：超小内存唯一值计数（12k</p></blockquote><blockquote><p>geo：地理信息位置</p></blockquote><ul><li>速度快</li></ul><blockquote><p>redis可达到10w读写速度，将数据存储到内存中，使用C语言编写（50000 line），单线程</p></blockquote><ul><li>持久化</li><li>功能丰富</li><li>主从复制</li><li>高可用、分布式</li></ul><h1 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h1><ul><li><p>缓存系统</p><blockquote><p>先从cache中获取数据，如果有返回数据，没有则从数据库中取数据并加入到缓存中</p></blockquote></li><li><p>计数器</p></li><li><p>消息队列系统</p></li><li><p>排行榜</p></li><li><p>社交网络</p></li><li><p>实时系统</p></li></ul><h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><blockquote><p><a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 下载</span><br><span class="line">wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br><span class="line"><span class="meta">#</span> cd到redis目录编译，会产生redis.conf、src等文件</span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span> 安装到指定目录产生bin文件</span><br><span class="line">make install PREFIX=/install/redis</span><br></pre></td></tr></table></figure><ul><li><p>bin目录下6个可执行文件</p><blockquote><p>redis-server：redis服务器 </p></blockquote><blockquote><p>redis-cli：redis命令行客户端</p></blockquote><blockquote><p>redis-benchmark：基准测试</p></blockquote><blockquote><p>redis-check-aof：持久化aof文件修复工具</p></blockquote><blockquote><p>redis-check-dump：持久化rdb文件修复工具</p></blockquote><blockquote><p>redis-sentinel：sentinel服务器（2.8version）</p></blockquote></li></ul><ul><li><p>三种启动redis方式</p><blockquote><p>redis-serve（默认配置） </p></blockquote><blockquote><p>redis-serve – port 6380（动态参数启动，默认端口是6379）</p></blockquote><blockquote><p>redis-serve &amp;confipath（参与配置文件启动）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。&lt;/p&gt;
&lt;h1 id=&quot;redis的特性&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/04/hello-world/"/>
    <id>http://yoursite.com/2019/04/04/hello-world/</id>
    <published>2019-04-04T07:41:28.062Z</published>
    <updated>2019-04-04T07:41:28.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
