<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T06:00:29.037Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发基础（一）</title>
    <link href="http://yoursite.com/2019/04/21/concurrence/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/04/21/concurrence/并发基础(一)/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-21T06:00:29.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><em>并发</em>：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可同时运行<br></p><p><em>高并发(high concurrent)</em>：是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够<em>同时并行处理</em>很多请求</p><ul><li>并发：多个线程操作相同的资源，保证线程安全，合理使用资源</li><li>高并发：服务能同时处理很多请求，提高程序性能</li></ul><h1 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h1><p>随着现代半导体工艺的发展，CPU的频率越来远快，相对内存快了一个数量级，对于访存的操作CPU就需要等待主存，这样会导致资源的白白浪费。所以cache的出现是为了解决CPU与内存速度不匹配的问题<br></p><p>cache 的工作原理是基于“局部性”原理，它包含以下两个方面：</p><ul><li>时间局部性：如果某个数据被访问，那么不久将来它很可能再次被访问</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据也可能被访问</li></ul><p>cache中保存着cpu刚用过的数据或者是循环使用的数据，这时，从cache中读取数据就会很快，减少了cpu等待的时间，提高了系统的性能</p><h2 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h2><p>cache 给系统带来性能上飞跃的同时，也引入了新的问题“缓存一致性问题”。设想如下场景（cpu一共有两个核，core1和core2）：<br>以i++为例，i的初始值是0.那么在开始每个核都存储了i的值0，当第core1块做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后core2缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2</p><h1 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h1><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。我们介绍其中最经典的MESI协议</p><p>在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：</p><ul><li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</li><li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中</li><li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中</li><li>I(Invalid): 这行数据无效</li></ul><p><strong>CPU多级缓存-乱序执行优化</strong><br>处理器为提高运算速度而做出违背代码原有顺序的优化</p><p><strong>乱序执行优化出现问题的原因</strong><br>在单核时代处理器做出的优化可以保证执行结果不会远离预期目标，但是，在多核时代却并非如此。在多核时代，同时会有多个核同时执行指令，每一个核的指令都可能被乱序。另外,处理器还引入了L1，L2,…,Ln等多级缓存机制，每个核心都有自己的缓存机制，这样就导致了逻辑次序上后写入内存的数据未必真的最后写入。最后就带来一个问题，如果不做任何防护措施，处理器最终得出的结果和逻辑得出结果会大不相同。比如，在一个核上执行写入操作，并在最后写一个标记用来表示操作完毕，之后从另外一个核上通过判断这个标记来判定所需要的数据是否已经就绪，这种做法就存在一定风险：标记位先被写入但之前的操作却并未完成(可能是未计算完成，也可能是数据没有从处理器缓存刷新到主存中，最终导致另外的核使用了错误的数据)</p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/01.jpg" alt></p><p>JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。</p><p>Java采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序</p><h2 id="Java内存模型—同步八种操作"><a href="#Java内存模型—同步八种操作" class="headerlink" title="Java内存模型—同步八种操作"></a>Java内存模型—同步八种操作</h2><p><img src="https://img-blog.csdn.net/20180522220730109" alt></p><ul><li><p>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</p></li><li><p>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p></li><li><p>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p></li><li><p>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</p></li><li><p>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</p></li><li><p>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</p></li><li><p>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</p></li><li><p>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p></li></ul><h2 id="同步规则分析"><a href="#同步规则分析" class="headerlink" title="同步规则分析"></a>同步规则分析</h2><ul><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</p></li><li><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p></li></ul><p>-对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p><h1 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h1><p><em>优势</em>:</p><ul><li>速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程（或线程）同时进行</li><li>设计：程序设计在某些情况下更简单，也可以有更多的选择</li><li>资源利用：CPU能够等待IO的时候能够做一些其他的事情</li></ul><p><em>风险</em>:</p><ul><li>安全性：多个线程共享数据时可能会产生于期望不相符的结果</li><li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如：死锁、饥饿等问题。</li><li>性能：线程过多时会使得：CPU频繁切换，调度时间增多；同步机制；消耗过多内存</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CPU多级缓存：缓存一致性、乱序执行优化</li><li>Java内存模型： JMM规定、抽象结构、同步八种操作以及规则</li><li>Java并发的优势与风险</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;em&gt;并发&lt;/em&gt;：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能的索引</title>
    <link href="http://yoursite.com/2019/04/20/mysql/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/04/20/mysql/创建高性能的索引/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-21T05:57:36.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第五章 创建高性能的索引</em><br>索引在MySQL中也称为key，它是存储引擎用于快速找到记录的一种数据结构。索引能够轻易将查询性能提高几个数量级</p><h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>存储引擎是如何使用索引的？ 首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。也就是说，如果某个列建立了索引，那么会先在索引中查找。</p><ul><li>可创建多个索引，如果多个列，那么顺序非常重要</li></ul><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><p>索引在存储引擎层，因此不同的存储引擎对索引的工作方式也不一样，并不是所有的存储引擎都支持所有类型的索引</p><p><strong>B-Tree索引</strong></p><blockquote><p>术语B-Tree是因为MySQL在create table和其他语句中也使用该关键字<br></p></blockquote><p>内部算法实际使用B+Tree实现，InnoDB使用B+Tree，NDB集群使用T-Tree来存储索引</p><ul><li>B-Tree与二叉树的形式存储索引，意味着所有的值都是顺序的，能够快速访问数据不需要进行全表扫描</li><li>B-Tree对索引是顺序组织存储，所以适合查找范围数据</li></ul><p><strong>哈希索引</strong><br>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效, 哈希索引会将所有的哈希码存储在索引中，同时在哈希表中存储每个数据行的指针</p><ul><li>在MySQL中，只有memory引擎支持哈希索引</li><li>如果要查询很多关联的表，哈希索引非常使用用于查询</li><li>InnoDB有一种特殊的功能 <em>自适应哈希索引</em> 如果它注意到某些索引使用频繁，内部会基于B-Tree之上创建哈希索引</li></ul><p><strong>创建自定义索引</strong><br>我们可模拟InnoDB一样创建函数, 虽然还是使用B-Tree进行查找，但是使用哈希值来查询<br><br><em>我们有如下表</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hash_test(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">url</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  url_crc <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>例如url存储”<a href="http://www.mysql.com&quot;" target="_blank" rel="noopener">http://www.mysql.com&quot;</a>, 我们进行如下查询效率是非常低的，使用的是全表扫描<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span>;</span><br></pre></td></tr></table></figure></p><p>因此我们在上述表中添加了url_crc它用于存储URL的哈希值，通过哈希值来进行查询，效率是极高的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将值存储到url_crr列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">crc32</span>(<span class="string">'http://www.mysql.com'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span> <span class="keyword">AND</span> url_crc = <span class="keyword">crc32</span>(<span class="string">"http://www.mysql.com"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>上述过程的缺陷是需要手动设置哈希值，当然可使用触发器来完成。注意：哈希冲突问题，或可使用FNV64()哈希函数，冲突比CRC32()少</p></blockquote><p><strong>全文索引</strong><br>它查找的是文本中的关键词，而不是直接比较索引中的值。类似于搜索引擎做的事情</p><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><ul><li>大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序和临时表</li><li>可将随机I/O变为顺序IO</li></ul><p><em>索引是最好的解决方案吗?</em><br>只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是最有效的</p><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><p>正确的创建和使用索引是实现高性能查询的基础</p><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p><em>不当的使用索引</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>如果查询总的列不是独立的，则MySQL不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>如果需要索引很长的字符串，这会导致索引变的大且慢。我们可采用<em>索引开始部分的字符</em>来提高索引效率。但是也会降低索引的选择性。指定是如果你使用部分字符，那么出现重复的值越高</p><ul><li>对于blob、text或很长的varcher类型的列必须采用前缀索引</li></ul><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>在多个列上建立独立的单列索引大部分情况下并不能提高性能，在MySQL5.0版本引入了”索引合并”的策略，一定程度上表上的多个单列索引来定位指定的行</p><ul><li>OR、AND、UNION以集合的方式会根据索引查询并不会进行全表扫描</li></ul><h2 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h2><p>在B-Tree索引中，意味着安装最左列进行排序，其次第二列</p><ul><li>将选择性最高的列放到索引最前列</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行，它的优点有</p><ul><li>把相关数据保存在一起，例如实现电子邮箱时，可根据用户ID聚集数据获取全部邮件</li><li>数据访问更快，聚簇索引将索引和数据存储在一个B-Tree中</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>MySQL可直接获取列的数据，这样就不再需要读取数据行, 如果一个索引包含所有需要查询的字段的值，称为覆盖索引</p><ul><li>覆盖索引必须要存储索引的值，并不是所有的存储引擎都支持覆盖索引</li></ul><h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><ul><li>MySQL有两种方式生成有序的结果，排序、按索引顺序扫描 <em>可使用explain select table 查看tyep值 如果为index则使用了索引扫描来做排序</em></li></ul><h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中</p><ul><li>可以在create table语句中指定pack_keys参数来控制压缩索引的方式</li></ul><h2 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h2><p>如果在相同列上创建多个索引, 那么MySQL需要单独维护重复的索引，这会影响性能</p><ul><li>未使用的索引考虑删除</li></ul><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行</p><ul><li>InnoDB行锁效率高，只有在访问行的时候才会对其加锁</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>如果列中建立了索引，存储引擎会根据索引快速查询到记录。</li><li>InnoDB使用B-Tree索引，所有中都是顺序的，避免了全表扫描。哈希索引只有memory</li><li>可以使用CRC32(‘url’)获取哈希值，可通过哈希值来查询较长的字符串如URL地址，不要使用SHA1()和MD5()作为哈希函数</li><li>编写查询语句时尽可能选择合适的索引以避免单行查找，尽可能使用数据原生顺序从而避免而外的排序操作，尽可能使用索引覆盖查询</li><li>不要因”应该为where子句中出现的所有列创建索引”所谓的经验法来创建索引，而是要应该根找出消耗最长时间的查询来创建合适的索引</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第五章 创建高性能的索引&lt;/em&gt;&lt;br&gt;索引在MySQL中也称为k
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>查询性能优化</title>
    <link href="http://yoursite.com/2019/04/20/mysql/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/20/mysql/查询性能优化/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-21T06:01:14.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第六章 查询性能优化</em><br>查询优化、索引优化、库表结构优化需要齐头并进，一个不落，本章节理解MySQL如何真正的指向查询，并明白高效的低效的原因何在</p><h1 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h1><p>如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。因此我们要优化查询实际上就是优化子任务。</p><ul><li>查询生命周期：从客户，到服务器，然后再服务器上进行解析，生成指向计划，执行，后返回结果给客户端</li><li>在每一个消耗大量实际的查询案例中，都可能看到一些不必要的额外操作、重复、某些操作执行太慢等</li></ul><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>查询性能低下最基本的原因是访问数据太多</p><ul><li>确认程序是否在检索大量不需要的数据</li><li>确认MySQL服务器层是否存在分析大量不需要的数据</li></ul><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销等</p><p><strong>查询不需要的记录</strong><br>我们通常会认为MySQL只会返回需要的数据，实际MySQL是先返回全部结果集后进行计算</p><p><strong>多表关联时返回全部列</strong><br>千万不要写select * 这样会导致查询所有关联表的字段数据。应该只取需要的列</p><p><strong>总是取出所有列</strong><br>当编写select *时，会让优化器无法完成索引覆盖扫描这类优化。但也并不是坏事，如果你的程序中使用了缓存机制，可能有其好处</p><p><strong>重复查询相同的数据</strong><br>如果不断的重复执行相同的查询，每次返回完全相同的数据。比较好的解决方案是，当初次查询的时候将这个数据缓存起来。例如用户每次评论都需要查询用户头像的URL</p><h2 id="MySQL是否存在扫描额外的记录"><a href="#MySQL是否存在扫描额外的记录" class="headerlink" title="MySQL是否存在扫描额外的记录"></a>MySQL是否存在扫描额外的记录</h2><p>衡量查询开销的三个指标</p><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul><p>它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中</p><p><strong>响应时间</strong></p><ul><li>响应时间 = 服务时间 + 排队时间<br><em>服务时间</em>：数据库处理查询真正花了多少时间，<em>排队时间</em>是指服务器因为等待某些资源而没有真正执行查询的时间——可能是I/O、锁等待…</li></ul><p><strong>扫描的行数和返回的行数</strong><br>理想情况下扫描的行数和返回的行数应该是相同的。实际情况下这种完美的事并不多</p><p><strong>扫描的行数和访问类型</strong><br>在explain语句中的type列反应了访问类型，访问类型有多种，如全表扫描(ALL)、索引扫描、范围扫描等等。这些类型速度慢到快，扫描行数多到少</p><ul><li>索引让MySQL以最高效、扫描行数最少的方式找到需要的记录</li></ul><h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>设计查询时需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在以前总是认为网络通信，查询解析是一件代价很高的事情</p><ul><li>第一种情况不必考虑，现代网络比以前快很多</li><li>第二种情况其实在MySQL设计中连接和断开连接的处理非常高效，每秒内部能扫描百万行数据</li></ul><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对一个大的查询我们可将切分小查询，例如删除旧的数据，将一个大的delete语句切分成多个较小的查询</p><ul><li>每次删除数据后，都暂停一会再做下一次删除，这样可以将服务器上原本一次性的压力分散到一个时间很长的时间段中</li></ul><h2 id="分散关联查询"><a href="#分散关联查询" class="headerlink" title="分散关联查询"></a>分散关联查询</h2><p>例如做多表关联查询，有如下语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag</span><br><span class="line"><span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag.id=tag.id</span><br><span class="line"><span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">where</span> tag.tag=<span class="string">'mysql'</span></span><br></pre></td></tr></table></figure></p><p>可以分解为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag=<span class="string">'mysql'</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span>(?)</span><br></pre></td></tr></table></figure></p><p><em>分解关联查询有如下优势：</em></p><ul><li>让缓存效率更高，方便其他程序从缓存中查询单表对象</li><li>执行单个查询减少锁的竞争</li><li>对数据拆分，做到高性能和可扩展等</li></ul><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>MySQL执行一个查询的流程：<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/mysql-phone/mysql-001.jpg" alt></p><ul><li>客户端发送一条查询语句给服务器</li><li>服务器检查查询缓存，如果缓存中有数据，直接返回。否则进入下一个阶段</li><li>服务器进行SQL解析，预处理再由优化器生成对应的执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>最后将结果返回客户端</li></ul><p>我们对其上述的流程进一步的解析</p><h2 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>在任何一个时刻，要么由服务器向客户端发送数据，要么客户端向服务器发送数据，这两个动作不能同时发生。</p><ul><li>客户端用一个单独的数据包将查询传给服务器，一旦客户端发送了请求，它能做的事就只能等待</li><li>相反，服务器响应给客户端的数据通常很多，由多个数据包组成。当开始响应时，客户端必须完整接收整个返回结果，并不能简单的取出前面几条结果（<em>类似拉取数据的过程</em>）</li><li>获取结果集看上去是从MySQL服务器获取，实际从函数库(<em>连接MySQL的库函数</em>)的缓存中获取数据</li></ul><p><strong>查询状态</strong><br>对于一个MySQL连接，或者说一个线程，任何时刻都由一个连接状态，该状态表示了MySQL当前在做什么。使用<em>SHOW FULL PROCESSLIST</em>命令查询，command列表示当前的状态。有如下状态：</p><ul><li>sleep：线程正在等待客户端发送新的请求</li><li>query：线程正在执行查询或正在将结果发送给客户端</li><li>locked：在MySQL服务层，该线程等待表锁</li><li>analyzeing and statisticas：线程正在收集存储引擎的统计信息，并生成查询的执行计划</li><li>copying to table [on disk]：线程正在执行查询，并将结果集复制到一个临时表中，这种状态通常在做group by union等 </li><li>sorting result：线程正在对结果集进行排序</li><li>sending data：多种情况，线程可能在多个状态之间传送数据，或者在生成结果集等</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>这里指的是query cache</p></blockquote><p>在解析一个查询语句之前，如果缓存开启，MySQL会优先检查这个查询是否在缓存，是直接返回，否则下一个阶段</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>此阶段进入查询优化，目标是将一个SQL转换成一个执行计划。MySQL会根据执行计划和存储引擎机械进行交互。这包含了多个子阶段：解析SQL、预处理、优化SQL执行计划，如果该过程有任何错误都可能和终止查询</p><p><strong>语法解析器和预处理</strong><br>MySQL会将SQL语句解析为对应的<em>解析树</em>，检查数据表和数据列是否存在、正确等</p><p><strong>查询优化器</strong><br>优化器是将SQL转换成执行计划，一条查询可以有多种执行方式，最后都返回相同的值。查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>MySQL根据执行计划给出的指令逐步执行，在该过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口称为’handler  API’</p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>最后一个阶段是将结果返回客户端，如果查询可以被缓存，那么MySQL在这个阶段会将结果存放到查询缓存中</p><h1 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h1><p>如果对优化器选择的执行计划不满意，可使用优化器提供的几个提示(hint)来控制最终的执行计划</p><p><em>sql_small_result和sql_big_result</em><br>sql_smqll_result告诉优化器结果集很少，可以将结果集放在内存中的索引临时表，以避免排序操作。sql_big_result则告诉优化器结果集可能非常大，建议使用磁盘临时表做排序操作</p><blockquote><p>p233介绍了更多了的hint</p></blockquote><h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><blockquote><p>本节介绍的多数优化技巧都是和特定的版本有关的，对于其他版本未必适用</p></blockquote><h2 id="优化count"><a href="#优化count" class="headerlink" title="优化count()"></a>优化count()</h2><p>count聚合函数：可统计某个列值的数量，也可统计行数</p><ul><li>使用count(*)时，并不会像我们猜想的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数</li><li>如果希望知道的是结果集的行数，最好使用count(*)，这样写意义清晰，性能也会更好</li></ul><h2 id="优化group-by和distinct"><a href="#优化group-by和distinct" class="headerlink" title="优化group by和distinct"></a>优化group by和distinct</h2><p>使用sql_big_result和sql_small_result来让优化器按照你希望的方式运行</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优化数据访问：访问的数据量过大，是否查询了不必要的数据</li><li>重构查询方式：将大的查询切分成小的查询，例如将多表查询分成单表查询</li><li>理解查询是如何被执行的，以及时间都消耗在那些地方</li><li>优化通常需要三管齐下，不做(查询缓存)，少做，快速的做</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第六章 查询性能优化&lt;/em&gt;&lt;br&gt;查询优化、索引优化、库表结构优
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Schema与数据类型优化</title>
    <link href="http://yoursite.com/2019/04/19/mysql/Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/19/mysql/Schema与数据类型优化/</id>
    <published>2019-04-19T08:39:23.000Z</published>
    <updated>2019-04-19T10:29:36.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第四章 Schema与数据类型优化</em> <br></p><blockquote><p>选择正确的数据类型对于获得高性能至关重要</p></blockquote><ul><li>更小的通常更好，尽量使用存储数据的最小数据类型</li><li>简单就好，例如整形比字符操作更快，而不是使用字符存储时间</li><li>尽量避免NULL，通常情况下最好将列指定为NOT NULL</li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>存储整数可使用：tinyint、smallint、mediumint、int、bigint<br>。分别使用8、16、24、32、64位存储空间</p><ul><li>整数类型有可选的unsigend属性，表示不允许负值</li><li>整数计算通常使用bigint</li></ul><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数是带有小数部分的数字</p><ul><li>float（4字节）和double（8字节）支持浮点运算</li><li>decimal用于存储精确的小数, 因为decimal只是一种存储格式，在计算中会转换为double</li><li>只在对小数进行精确计算时才使用decimal，例如财务数据</li></ul><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>不同的存储引擎存储字符的方式可能不同</p><ul><li>varchar存储可边长字符串，仅使用必要的空间</li><li>char类型是定长的，适合存储更短的字符串。当存储char值时，MySQL会删除所有的末尾空格</li><li>binary和varbinary用于存储二进制字符串，存储的是字节码而不是字符</li><li>blob和text：存储大数据而设计的字符串类型。前者为二进制，后者为字符串。它们与其他类型不同，存储引擎会做特殊处理，如果值太大，InnoDB会使用专门的”外部”存储区域进行存储</li><li>使用枚举类型存储字符串，与数字-字符串映射关系查找表</li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL能存储的最小时间颗粒度为秒，MariaDB支持微妙级别的时间类型，<em>可使用bigint存储微秒级别的时间戳</em></p><ul><li>datetime: 可保存大范围的值，1001年-9999年，精度为秒。8字节存储</li><li>timestamp: 保存了从1970-1-1午夜（格林尼治标准时间）以来的秒数, 使用4字节存储。</li></ul><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型</p><ul><li>bit：bit(1)定义一个包含单个位的字段, 存储一个或多个true/false</li><li>set: 存储很多个true/false，以集合的形式来表示</li></ul><h2 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h2><p>整数通常是标识列最好的选择，enum和set只适合标记固定的值，如人的性别、产品类型等，尽量避免字符串类型作为标识列，因为消耗空间<br><br>随机字符如UUID存储会导致insert、select语句变慢。插入会随机写到索引不同位置，查询逻辑上相邻的行为分布在磁盘和内存分布在不同的位置。</p><ul><li>如果存储UUID，移出’-‘，使用unhex()函数转换位16字节数字，存储在binary(16)。检索使用hex()函数格式化位十六进制的格式</li></ul><h1 id="schema设计中的陷阱"><a href="#schema设计中的陷阱" class="headerlink" title="schema设计中的陷阱"></a>schema设计中的陷阱</h1><ul><li>太多的列</li><li>太多的表关联，MySQL限制每个关联操作最多61张表。如果希望查询效率更高，单个查询最好在12个表以内做关联</li><li>防止过度的使用enum</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择优化的数据类型&quot;&gt;&lt;a href=&quot;#选择优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择优化的数据类型&quot;&gt;&lt;/a&gt;选择优化的数据类型&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第四章 Sc
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper分布式锁原理</title>
    <link href="http://yoursite.com/2019/04/19/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/19/zookeeper/zookeeper分布式锁原理/</id>
    <published>2019-04-18T16:06:16.000Z</published>
    <updated>2019-04-19T08:27:18.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁-活锁概念"><a href="#死锁-活锁概念" class="headerlink" title="死锁 | 活锁概念"></a>死锁 | 活锁概念</h1><p><strong>死锁</strong></p><ul><li>如果有两个服务订单服务和商品服务，订单服务需要读取库存操作, 商品服务也需要读取库存操作(图1)</li><li>此时订单服务读取完库存之后并没有释放(没有提交)。当商品服务再次读取时，库存数据可能会不一致（脏读）。通常这种情况采用<em>死锁</em></li><li>解决：在订单服务访问库存的时候，无论crud操作都加一把锁(未释放)。那么商品服务就不能访问库存了(图2)</li></ul><p><em>图1</em></p><p><img src="http://poporz7f8.bkt.clouddn.com/05.jpg" alt></p><p><em>图2</em></p><p><img src="http://poporz7f8.bkt.clouddn.com/06.jpg" alt></p><p><em>活锁</em><br>无论多少个服务，只对库存进行<strong>读取的操作</strong> 那么其他服务都可以去读取，否则都要进行加锁。这种情况成为<em>活锁</em></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在分布式环境下，当不同的服务访问某一个共享资源数据(数据库)的时候，可能会发生数据不一致的情况</p><p><em>下订单流程</em><br><img src="http://poporz7f8.bkt.clouddn.com/07.jpg" alt><br>如果在创建订单和扣除库存的操作没有完成（sleep），此时有其他请求进入时，那么库存的数量就可能会造成不一致(之前的值，因为sleep了)</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p><img src="http://poporz7f8.bkt.clouddn.com/09.jpg" alt></p><ul><li>在获取锁的时候，要根据锁是否被占用才可获取。如果没有占用创建锁 <em>zk临时节点</em>。临时节点会根据客户端会话的断开而断开（释放锁）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>什么是死锁：当A服务进行CRUD库存的时候，其他服务不可访问库存</li><li>什么是活锁：如果A服务只是进行读库存的操作，那么其他服务可访问库存</li><li>利用Zookeeper不能重复创建一个节点的特性来实现一个分布式锁，与redis很类似</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;死锁-活锁概念&quot;&gt;&lt;a href=&quot;#死锁-活锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁 | 活锁概念&quot;&gt;&lt;/a&gt;死锁 | 活锁概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有两个服务订单服务和商
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="活锁" scheme="http://yoursite.com/tags/%E6%B4%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper集群</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper集群/</id>
    <published>2019-04-18T06:08:54.000Z</published>
    <updated>2019-04-18T17:12:32.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper集群概述"><a href="#zookeeper集群概述" class="headerlink" title="zookeeper集群概述"></a>zookeeper集群概述</h1><p>zookeeper集群包含主从节点，心跳机制（选举模式），架构如下<br><img src="http://poporz7f8.bkt.clouddn.com/04.jpg" alt></p><p><em>选举模式</em>: 如果上述图中的master宕机了, slave1和slave进行选举，只有其中一个为master。如果原来的master恢复了，那么会加入到集群中成为slave。集群个数建议为奇数因为需要选举的过程</p><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><ul><li>配置数据文件 myid 1/2/3 对应 server.1/2/3</li><li>通过 ./zkCli.sh -server [ip]:[port] 检测集群是否配置成功</li></ul><p><em>拷贝3份zookeeper文件, 在第一份文件中的zoo.cfg配置如下信息</em><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个文件都需要加入该配置</span></span><br><span class="line"><span class="comment"># master节点ip | 数据同步的端口 | 选举端口</span></span><br><span class="line"><span class="string">server.1=192.168.211.136:2888:3888</span></span><br><span class="line"><span class="string">server.2=192.168.211.136:2889:3889</span></span><br><span class="line"><span class="string">server.3=192.168.211.136:2890:3890</span></span><br></pre></td></tr></table></figure></p><p><em>在dataDir数据源目录创建 myid 添加数字 1</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang dataDir]# vim myid</span><br><span class="line">[root@zhongjinlang dataDir]# ll</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 2 4月  18 00:42 myid</span><br><span class="line">drwxr-xr-x. 2 root root 6 4月  18 00:32 version-2</span><br><span class="line">-rw-r--r--. 1 root root 4 4月  18 00:32 zookeeper_server.pid</span><br></pre></td></tr></table></figure></p><blockquote><p>其他文件修改端口 2182、2183和创建myid即可</p></blockquote><p><em>分别启动 ./zkServer.sh start 并在2181中set一个节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /data 123 </span><br><span class="line">Created /data</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper, data]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出当前连接，连接2182</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] [root@zhongjinlang bin]# ./zkCli.sh -server </span><br><span class="line">localhost:2182</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时发现从节点2182有了master的数据（2183也有）</span></span><br><span class="line">[zk: localhost:2182(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper, data]</span><br></pre></td></tr></table></figure></p><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower # 从节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Mode: leader # 主节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: follower # 从节点</span><br></pre></td></tr></table></figure><h2 id="选举模式实验"><a href="#选举模式实验" class="headerlink" title="选举模式实验"></a>选举模式实验</h2><p>上述可看出2182为主节点，我们将2182进程kill，观察谁会成为主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时已经连接不了2182</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Ncat: Connection refused.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别连接其他节点</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower</span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: leader # 2183成为了主节点</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper集群包含主从节点、心跳机制。当主节点挂了，经过选举会将某一个从节点成为主节点，来保证整体服务的高可用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper集群概述&quot;&gt;&lt;a href=&quot;#zookeeper集群概述&quot; class=&quot;headerlink&quot; title=&quot;zookeeper集群概述&quot;&gt;&lt;/a&gt;zookeeper集群概述&lt;/h1&gt;&lt;p&gt;zookeeper集群包含主从节点，心跳机制（选举模
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeperACL权限控制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeperACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeperACL权限控制/</id>
    <published>2019-04-17T17:12:12.000Z</published>
    <updated>2019-04-18T17:12:54.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为ACL-access-control-lists"><a href="#何为ACL-access-control-lists" class="headerlink" title="何为ACL(access control lists)?"></a>何为ACL(access control lists)?</h1><p>可以对节点设置读写等权限，来保障数据的安全性，权限permission可以指定不同的范围以及角色<br></p><h1 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h1><ul><li>getAcl：获取某个节点的权限信息</li><li>setAcl：设置某个节点的权限</li><li>addauth： 输入认证授权信息，注册用户将用户根据指定的权限才可登入</li></ul><h2 id="ACL的构成一"><a href="#ACL的构成一" class="headerlink" title="ACL的构成一"></a>ACL的构成一</h2><ul><li><p>zookeeper的ACL通过[scheme:id:permission]来构成权限列表</p><blockquote><p>scheme: 代表采用的某种全新机制</p></blockquote><blockquote><p>id: 代表允许访问的用户</p></blockquote><blockquote><p>permission: 权限组合字符串</p></blockquote></li></ul><h2 id="ACL的构成二-scheme"><a href="#ACL的构成二-scheme" class="headerlink" title="ACL的构成二 - scheme"></a>ACL的构成二 - scheme</h2><ul><li><p>world：只有一个用户, 语法: world:anyone:[permission] 默认情况下它表示任何人都可访问这一节点</p></li><li><p>auth：认证登入，需要注册用户且有权限。语法：auth:user:password:[permission]</p></li><li><p>digest：需要对密码进行加密才可访问，语法：digest：username:BASE64(SHA1(password)):[permission]</p></li><li><p>ip: 可限制某个ip的访问，语法：ip:192.168.1.1:[permission]</p></li><li><p>super: 代表超级管理员，拥有所有权限</p></li></ul><h2 id="ACL的构成三-permission"><a href="#ACL的构成三-permission" class="headerlink" title="ACL的构成三 - permission"></a>ACL的构成三 - permission</h2><p>权限字符串使用缩写 crdwa，分别表示：</p><ul><li>c: create创建子节点。表示设置了改权限才可进行创建子节点</li><li>r: read获取节点/子节点列表的权限 </li><li>d: delete删除子节点权限</li><li>w: write写节点数据权限</li><li>a: admin权限才可分配permission</li></ul><h1 id="ACL实战"><a href="#ACL实战" class="headerlink" title="ACL实战"></a>ACL实战</h1><h2 id="world"><a href="#world" class="headerlink" title="world"></a>world</h2><p><em>创建一个节点并查看默认的权限</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /imooc/abc data </span><br><span class="line">Created /imooc/abc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] getAcl /imooc/abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拥有所有权限</span></span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure></p><p><em>设置权限：禁止删除</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] setAcl /imooc/abc world:anyone:crwa</span><br></pre></td></tr></table></figure></p><p><em>此时节点的权限、后新创建一个节点再进行删除测试（因为当前节点拥有之前的权限）</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /imooc/abc</span><br><span class="line">'world,'anyone</span><br><span class="line">: crwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] create /imooc/abc/xyz new-data-isnotdelete </span><br><span class="line">Created /imooc/abc/xyz</span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] delete /imooc/abc/xyz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示权限不足</span></span><br><span class="line">Authentication is not valid : /imooc/abc/xyz</span><br></pre></td></tr></table></figure></p><h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>明文登入<br><em>注册账号并登入</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 39] create /name/zhangsan zs </span><br><span class="line">Created /name/zhangsan</span><br><span class="line">[zk: localhost:2181(CONNECTED) 40] getAcl /name/zhangsan</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登入提示没有这个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] setAcl /name/zhangsan auth:zhangsan:123:cdrwa     </span><br><span class="line">Acl is not valid : /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注册一个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 42] addauth digest zhangsan:zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次登入</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] setAcl /name/zhangsan auth:zhangsan:123:cdrwa</span><br></pre></td></tr></table></figure></p><p><em>此时权限信息</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 44] getAcl /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码存在数据库中是一个密文</span></span><br><span class="line">'digest,'zhangsan:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdrwa</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># digest</span></span></span><br><span class="line">使用密文方式登入</span><br><span class="line"></span><br><span class="line">*创建新的节点 并设置登入账号以及密码*</span><br><span class="line">```shell</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /name/lisi</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码（密文）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] setAcl /name/lisi digest:lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=:cdra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /name/lisi</span><br><span class="line">'digest,'lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdra</span><br></pre></td></tr></table></figure></p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>控制某个网段是否有权限来访问目录节点，通常用于控制客户端</p><p><em>创建一个新的节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] create /name/ip ip</span><br><span class="line">Created /name/ip</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /name/ip</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] setAcl /name/ip ip:192.168.117.1:cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] getAcl /name/ip</span><br><span class="line">'ip,'192.168.117.1</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时虚拟机不可访问</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] get /name/ip</span><br><span class="line">Authentication is not valid : /name/ip</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper的ACL可对节点进行权限控制来保障数据安全性</li><li>world：默认所有用户登入</li><li>auth：注册用户登入，注册密码时为明文</li><li>digest：注册用户登入，注册密码时为密文</li><li>ip: 可限制网段访问</li><li>super: 可访问所有权限</li><li>ACL使用场景一：开发/测试环境分离，开发者无权操作测试库的节点，只能看</li><li>ACL使用场景二：生产环境上控制指定IP的服务可以访问相关节点，防止混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为ACL-access-control-lists&quot;&gt;&lt;a href=&quot;#何为ACL-access-control-lists&quot; class=&quot;headerlink&quot; title=&quot;何为ACL(access control lists)?&quot;&gt;&lt;/a&gt;何为ACL(
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper的watch机制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E7%9A%84watch%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper的watch机制/</id>
    <published>2019-04-17T16:11:33.000Z</published>
    <updated>2019-04-18T17:12:36.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为watch"><a href="#何为watch" class="headerlink" title="何为watch?"></a>何为watch?</h1><p>针对每个节点的操作，都会有一个监督者<strong>watch</strong>。当节点发现变化时，如create、set、delete都会触发一个watch事件。<br><br>zookeeper中的watch是一次性的，<em>触发后立即销毁</em>。注意是在zookeeper中</p><ul><li><p>父节点，子节点增删改都会触发watch</p></li><li><p>针对不同类型的操作，触发的watch事件不同：如节点创建事件、节点删除事件、节点数据变化事件</p></li></ul><h1 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h1><h2 id="父节点watch事件"><a href="#父节点watch事件" class="headerlink" title="父节点watch事件"></a>父节点watch事件</h2><ul><li>创建父节点触发: NodeCreated</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先设置一个事件（<span class="built_in">set</span> get都可以 使用<span class="built_in">help</span>查看）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] stat /imooc watch  </span><br><span class="line">Node does not exist: /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发了事件</span></span><br><span class="line">watch::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/imooc</span><br><span class="line">Created /imooc</span><br></pre></td></tr></table></figure><ul><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li></ul><h2 id="子节点watch事件"><a href="#子节点watch事件" class="headerlink" title="子节点watch事件"></a>子节点watch事件</h2><p>ls为父节点设置watch</p><ul><li>创建子节点触发：NodeChildrenChanged<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /imooc</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /imooc watch </span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /imooc/abc 88 </span><br><span class="line">Created /imooc/abc</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/imooc</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>触发了NodeChildrenChanged</p></blockquote><ul><li>删除子节点也是触发：NodeChildrenChanged</li><li><p>修改子节点不会触发事件</p></li><li><p>TODO：增加和删除触发的事件为什么一样：因为它们为子节点，子节点和父节点需要进行区分，父节点有不同的事件，对于父节点来说不需要关注子节点的事件。因为父节点只需要告诉客户端 哦我的子节点改变了NodeChildrenChanged事件</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>watcher使用场景：在集群环境下，如果某个节点发生了变化，例如配置文件的变化，我们可通过watcher监听获取到数据，并将其同步到其他分布式的节点中，达到数据的一致性</li><li>zookeeper节点（子父）发生变化时，会触发watch事件，并且出发后立即销毁（在zookeeper中)不同的类型操作watch事件也不同（增、删、改）</li><li>在修改节点数据之前可设置watch，如果下次获取该节点时会触发不同的watch类似</li><li>父节点触发watch事件有： NodeCreated（增）、NodeDeleted（删）、NodeDataChanged（改）</li><li>子节点触发watch事件有:  NodeChildrenChanged（增删）、修改不会触发事件因为对于父节点来说并不关心</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为watch&quot;&gt;&lt;a href=&quot;#何为watch&quot; class=&quot;headerlink&quot; title=&quot;何为watch?&quot;&gt;&lt;/a&gt;何为watch?&lt;/h1&gt;&lt;p&gt;针对每个节点的操作，都会有一个监督者&lt;strong&gt;watch&lt;/strong&gt;。当节点发现变化
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper命令使用</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper命令使用/</id>
    <published>2019-04-17T16:10:33.000Z</published>
    <updated>2019-04-18T17:12:48.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>通过 ./zkCli.sh打开客户端进行命令行后台操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# zkCli.sh</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="ls-ls2"><a href="#ls-ls2" class="headerlink" title="ls | ls2"></a>ls | ls2</h2><p><strong>查看zookeeper路径</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p><strong>查看状态信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建了之后，zk为这个节点所分配的ID</span></span><br><span class="line">cZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> create-time</span></span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后zk的ID</span></span><br><span class="line">mZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后节点的时间</span></span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点ID</span></span><br><span class="line">pZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点发生变化后的version值</span></span><br><span class="line">cversion = -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点数据的version，修改后累加1</span></span><br><span class="line">dataVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 权限</span></span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点个数（ls /）</span></span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p><h2 id="get-stat"><a href="#get-stat" class="headerlink" title="get | stat"></a>get | stat</h2><ul><li><p>stat命令：ls2 = ls + stat</p></li><li><p>get：取出当前节点数据，如果没有数据，与上述内容一至</p></li></ul><h1 id="节点操作命令"><a href="#节点操作命令" class="headerlink" title="节点操作命令"></a>节点操作命令</h1><p>讲述该节内容前，我们先阐述session的基本原理：</p><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都可设置一个超时时间（30分钟不操作session失效）：心跳结束，则session过期</li><li>session过期，临时节点znode会被抛弃</li><li>心跳机制： 客户端向服务端的ping包请求</li></ul><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><ul><li><p>创建默认节点节点（持久化节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc immoc-data </span><br><span class="line">Created /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] get /immoc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点的持久化数据</span></span><br><span class="line">immoc-data</span><br><span class="line">..</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 10</span><br></pre></td></tr></table></figure></li><li><p>创建节点后目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /     </span><br><span class="line">[zookeeper, imooc]</span><br></pre></td></tr></table></figure></li><li><p>创建临时节点: create -e /imooc/tmp immoc-data</p></li><li><p>创建顺序节点: 每个节点后缀都会增加数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s /imooc/sec seq </span><br><span class="line">Created /imooc/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s /imooc/sec seq</span><br><span class="line">Created /imooc/sec0000000002</span><br></pre></td></tr></table></figure></li></ul><h2 id="set-delete"><a href="#set-delete" class="headerlink" title="set | delete"></a>set | delete</h2><ul><li><p>set path data [version]：修改节点如果默认不设置版本号，直接删除。加上版本号可实现乐观锁(只能修改最新的数据)</p></li><li><p>delete path [version]: 直接删除节点, 加上版本号只能删除最新数据</p></li></ul><h1 id="四字命令-four-letter-words"><a href="#四字命令-four-letter-words" class="headerlink" title="四字命令 four letter words"></a>四字命令 four letter words</h1><p>zookeeper可通过它自身提供的简写命令来和服务器进行交互, 可查看服务器的一些状态信息。使用运维来进行监控</p><ul><li>需要使用nc命令，安装yum install nc</li><li>语法： echo [commod] | nc [ip] [port]</li></ul><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>它可查看zookeeper的状态信息，以及是否mode（集群还是单机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo stat | nc 192.168.211.136 2181</span><br><span class="line">Zookeeper version: 3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /192.168.211.136:34346[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/27</span><br><span class="line">Received: 2696</span><br><span class="line">Sent: 2701</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x45</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 8</span><br></pre></td></tr></table></figure><h2 id="ruok"><a href="#ruok" class="headerlink" title="ruok"></a>ruok</h2><p>查看当前zk服务是否启动，启动返回imok</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo ruok | nc localhost 2181</span><br><span class="line">imok[root@zhongjinlang /]#</span><br></pre></td></tr></table></figure><h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><p>列出未经处理的会话和临时节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo dump | nc localhost 2181</span><br><span class="line">SessionTracker dump:</span><br><span class="line">Session Sets (0):</span><br><span class="line">ephemeral nodes dump:</span><br><span class="line">Sessions with Ephemerals (0):</span><br></pre></td></tr></table></figure><h2 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h2><p>查看服务器配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo conf | nc localhost 2181</span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataDir/version-2</span><br><span class="line">dataLogDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataLogDir/version-2</span><br><span class="line">tickTime=2000</span><br><span class="line">maxClientCnxns=60</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=40000</span><br><span class="line">serverId=0</span><br></pre></td></tr></table></figure><h2 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h2><p>展示连接到服务器的客户端信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo cons | nc localhost 2181</span><br><span class="line"> /0:0:0:0:0:0:0:1:47224[0](queued=0,recved=1,sent=0)</span><br></pre></td></tr></table></figure><h2 id="mntr"><a href="#mntr" class="headerlink" title="mntr"></a>mntr</h2><p>监控zookeeper的健康信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo mntr | nc localhost 2181</span><br><span class="line">zk_version3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">zk_avg_latency0</span><br><span class="line">zk_max_latency27</span><br><span class="line">zk_min_latency0</span><br><span class="line">zk_packets_received2703</span><br><span class="line">zk_packets_sent2708</span><br><span class="line">zk_num_alive_connections1</span><br><span class="line">zk_outstanding_requests0</span><br><span class="line">zk_server_statestandalone</span><br><span class="line">zk_znode_count8</span><br><span class="line">zk_watch_count0</span><br><span class="line">zk_ephemerals_count0</span><br><span class="line">zk_approximate_data_size85</span><br><span class="line">zk_open_file_descriptor_count30</span><br><span class="line">zk_max_file_descriptor_count4096</span><br></pre></td></tr></table></figure><h2 id="wchs"><a href="#wchs" class="headerlink" title="wchs"></a>wchs</h2><p>展示watch信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo wchs | nc localhost 2181</span><br><span class="line">0 connections watching 0 paths</span><br><span class="line">Total watches:0</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ls / 查看zk目录</li><li>ls2 / 查看节点信息</li><li>get / 取出当前节点信息</li><li>zookeeper存储了节点的各种状态，如数据的大小、修改时间等</li><li>ephemeralOwner = 0x0属性如果为0x0那么为临时节点，否则为持久节点（后面是一串数据）。临时节点在断开连接后消失（10秒左右延迟 - 心跳机制）</li><li>create path data创建持久化节点</li><li>set path data [version]修改节点</li><li>delete path data [version]删除节点</li><li>使用set和delete时候，建议根据version删除，可达到<em>乐观锁的</em>效果，不会删除到之前旧的数据</li><li>zookeeper提供四字命令可查看服务器的一些状态信息，语法：echo [命令] | nc [ip] [port]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;通过 ./zkCli.sh打开客户端进行命令行后台操作&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="乐观锁" scheme="http://yoursite.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper基本数据模型</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper/zookeeper%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper/zookeeper基本数据模型/</id>
    <published>2019-04-17T01:29:33.000Z</published>
    <updated>2019-04-18T17:12:44.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper模型介绍"><a href="#zookeeper模型介绍" class="headerlink" title="zookeeper模型介绍"></a>zookeeper模型介绍</h1><ul><li><p>数据为树形结构，可理解为Linux的目录结构 /usr/local/..</p></li><li><p>每一个节点成为znode，它可有子节点，也可以有数据</p></li><li><p>每个节点分为临时节点和永久节点，临时节点在客户端断开连接后消失。永久节点是一个持久化的节点</p></li><li><p>每个zk节点都有各自的版本号，可通过命令显示节点信息</p></li><li><p>每当节点数据发生变化时，那么该节点的版本号就会累加（乐观锁）</p></li><li><p>删除/修改过时的节点，版本号不匹配则会报错</p></li><li><p>每一个zk节点存储的数据不易过大，几k即可</p></li><li><p>节点可设置权限ACL，可通过权限来限制用户访问</p></li></ul><h1 id="数据模型基本操作"><a href="#数据模型基本操作" class="headerlink" title="数据模型基本操作"></a>数据模型基本操作</h1><ul><li>客户端连接 - 查看znode结构 - 关闭客户端连接</li></ul><p><strong>连接客户端</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkCli.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示一推信息...</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里需要回车</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></p><p><strong>zookeeper命令</strong></p><p><img src="http://poporz7f8.bkt.clouddn.com/02.jpg" alt></p><p><strong>查看znode</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zookeeper/quota</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p><h1 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h1><ul><li><p>master节点选举，当主节点挂了，从节点就会接手工作，从而保证集群是高可用的</p></li><li><p>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，例如在一个集群的生产环境下，修改了一个redis的配置那么其他服务都需要进行修改，这样就很麻烦</p></li><li><p>发布订阅模式，类似消息队列MQ, dubbo发布者把数据数据存储到znode节点上，订阅者会读取这个数据</p></li><li><p>提供<em>分布式锁</em>，分布式环境中不同<strong>进程</strong>之间争夺资源，类似于多线程中的锁<br><img src="http://poporz7f8.bkt.clouddn.com/003.jpg" alt></p><blockquote><p>当A处理完B、C、D</p></blockquote></li><li><p>集群管理，集群中保证数据的强一致性</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>zookeeper的结构为树形结构，节点分为临时节点和永久节点。前者会在客户端断开后消失，后者是一个持久化的节点</p></li><li><p>zookeeper可保证集群高可用、提供了分布式锁保证数据一致性、可以统一管理集群中的配置文件进行同步</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper模型介绍&quot;&gt;&lt;a href=&quot;#zookeeper模型介绍&quot; class=&quot;headerlink&quot; title=&quot;zookeeper模型介绍&quot;&gt;&lt;/a&gt;zookeeper模型介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据为树形结构，可理解为Linux
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper概述</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper/zookeeper%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper/zookeeper概述/</id>
    <published>2019-04-17T00:29:33.000Z</published>
    <updated>2019-04-19T10:45:35.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户</p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p><img src="http://poporz7f8.bkt.clouddn.com/01.jpg" alt></p><ul><li>很多台计算机组成一个整体，一个整体一致对外并处理同一个请求</li><li>内部的每台计算机都可相互通信（rest/rpc）</li><li>客户端到服务端的一次请求到响应结束会历经多台计算机</li></ul><h1 id="zookeeper特性"><a href="#zookeeper特性" class="headerlink" title="zookeeper特性"></a>zookeeper特性</h1><ul><li>一致性：数据一致性，将数据按照顺序分批入库</li><li>原子性： 事务要么成功要么失败，不会局部化</li><li>单一视图： 客户端连接集群中的任一zookeeper节点，数据都是一致的</li><li>可靠性： 每次对zookeeper的操作状态都会保存在服务端</li><li>实时性: 客户端可以读取到zookeeper服务端的最新数据</li></ul><h1 id="zookeeper的安装"><a href="#zookeeper的安装" class="headerlink" title="zookeeper的安装"></a>zookeeper的安装</h1><h2 id="JDK依赖"><a href="#JDK依赖" class="headerlink" title="JDK依赖"></a>JDK依赖</h2><ul><li>安装解压好后配置环境变量，java-version查看是否安装成功</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set java</span></span><br><span class="line"><span class="comment"># java安装路径</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure><h2 id="zookeeper配置"><a href="#zookeeper配置" class="headerlink" title="zookeeper配置"></a>zookeeper配置</h2><ul><li><p>下载地址：<a href="https://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/</a></p></li><li><p>安装解压后配置环境变量</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">ZOOKEEPER_HOME=/usr/local/server/zookeeper/zookeeper-3.4.11</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span>    </span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$ZOOKEEPER_HOME/bin:JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心配置文件</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于计算时间的单元, 比如session超时（N * tickTime）</span></span><br><span class="line"><span class="attr">tickTime:</span> </span><br><span class="line"><span class="comment">#用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime的倍数来表示</span></span><br><span class="line"><span class="attr">initLimit:</span> </span><br><span class="line"><span class="comment">#用于集群，master主节点与从节点之间的消息通信，请求和答应的时间（心跳机制）</span></span><br><span class="line"><span class="attr">syncLimit:</span></span><br><span class="line"><span class="comment">#必须要配置的。用来zookeeper存储的数据(手动创建) </span></span><br><span class="line"><span class="attr">dataDir:</span> </span><br><span class="line"><span class="comment">#日志目录，如果不配置会和data目录公用（手动创建）</span></span><br><span class="line"><span class="attr">dataLogDir:</span> </span><br><span class="line"><span class="comment">#连接服务器的端口，默认2181</span></span><br><span class="line"><span class="attr">clientPort:</span></span><br></pre></td></tr></table></figure></p><p><strong>启动</strong></p><ul><li>./zkServer.sh 命令帮助</li><li>./zkServer.sh start 启动<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li></ul><p><strong>查看启动状态</strong></p><ul><li>./zkServer.sh status<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示单机状态</span></span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper用于提供协调服务，作用与分布式，发挥其优势，可为大数据服务</li><li>一次请求历经了多台服务器，这是分布式系统的最简单</li><li>zookeeper协调服务可理解为交通堵塞时交警的作用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存使用与优化</title>
    <link href="http://yoursite.com/2019/04/16/redis/redis%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/16/redis/redis缓存使用与优化/</id>
    <published>2019-04-15T17:21:17.000Z</published>
    <updated>2019-04-17T18:19:44.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h1><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><p>加速读写：CPU L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器读写、Ehcache缓存数据库结果</p></li><li><p>降低后端负载：降低MySQL的负载等</p></li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><p>数据不一致：缓存层和数据层有时间窗口不一致，和<em>更新策略</em>有关。也就是说，需要将数据库中的数据存入redis进行缓存，如果数据库更新了，那么缓存如何更新呢? </p></li><li><p>代码维护成本高： 多了一层缓存逻辑</p></li><li><p>运维成本：例如redis-cluster，或者使用云服务</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>降低后端负载：对高消耗的SQL, 如join结果集 / 分组结果集</p></li><li><p>加速请求响应：优化IO响应时间</p></li><li><p>大量写合并为批量写： 计数器先在redis累加，再批量写入DB</p></li></ul><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><p>当数据库数据更新时，那么缓存将如何进行更新维护呢？<br></p><ol><li><p>先进先出算法剔除：例如<em>maxmemory-policy</em>(最大内存限制)，当超过指定值之后，删除过期的key。不需担心每一个key是如何删除的。适用场景：控制内存</p></li><li><p>超时剔除：设置过期时间<em>expire</em>。适用场景：存储不是很重要的数据</p></li><li><p>主动更新：开发控制生命周期，由自己来控制每一个key的更新周期</p></li></ol><blockquote><p>开发建议： 超时剔除 + 主动更新</p></blockquote><h1 id="缓存颗粒控制"><a href="#缓存颗粒控制" class="headerlink" title="缓存颗粒控制"></a>缓存颗粒控制</h1><p>通常我们都是这样设计一个缓存系统的：先从redis查询数据，如果有直接返回。如果没有则从数据库中查询然后再加入缓存中。<br><br><em>伪代码如下</em>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set userid <span class="string">'select * from user where id=1'</span></span><br><span class="line"></span><br><span class="line">set userid <span class="string">'select column.. from user where id=1'</span></span><br></pre></td></tr></table></figure></p><ul><li>那么到底要缓存select * 还是部分字段的数据？该问题为缓存粒度问题</li></ul><h2 id="缓存粒度控制-三个角度"><a href="#缓存粒度控制-三个角度" class="headerlink" title="缓存粒度控制 - 三个角度"></a>缓存粒度控制 - 三个角度</h2><ul><li>通用性：全部属性更好</li><li>占用空间：部分数据更好</li><li>代码维护：表面上全部属性更好</li></ul><blockquote><p>生产环境通常采用部分属性，缓存需要考虑到性能问题、序列化问题</p></blockquote><h1 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h1><p>通常情况下缓存设计是这样的：第一次访问redis没有数据就去从数据库中查询，然后将数据加入缓存中，当下此访问redis时就直接从缓存中获取了。这是通常的情况下，如果第二个步骤访问数据库没有数据会怎样？如下如图结构：<br><img src="http://poporz7f8.bkt.clouddn.com/redis-chuantou.jpg" alt></p><p>此时就失去了缓存的意义，因为缓存就是用来保存持久层。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li><p>业务代码问题： 本身你编写的接口就拿不到持久层数据或是调用别的接口拿不到持久层数据</p></li><li><p>恶意攻击、爬虫等等: 根据URI一定的规则访问到接口</p></li></ul><h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><ul><li>业务的相应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>缓存空对象</strong><br><br>如果从数据库中查询的值不存在，进行一个判断直接将null就作为’数据’存入缓存中</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-chuantou2.jpg" alt></p><p>但是这种解决方案还是有问题，<em>持久层和缓存层数据”短期”不一致</em>。比如业务上的接口问题调用时可能出现网络原因拿不到结果，此时你将它作为null缓存了。如果恢复了，此时缓存是一个null的状态</p><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(cacheValue) )&#123;</span><br><span class="line">        <span class="comment">// 为空从持久层获取数据</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 加入缓存</span></span><br><span class="line">        jedis.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 防止缓存穿透, 如果数据库值真为空，设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(storageValue) )&#123;</span><br><span class="line">            jedis.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>布隆过滤器拦截</strong><br><br>通过很少的内存对数据的过滤, 例如在一个电话本中判断一个电话是否在电话本中，通常不会将电话本存储到内存中，占用内存可能会很大。布隆过滤器就是解决这种类似的问题，它通过一些算法，将电话本存入过滤器，当要判断电话是否在电话本中时，通过很少的算法来进行解决</p><blockquote><p>布隆过滤器用于检索一个元素是否在一个集合中</p></blockquote><h1 id="缓存无底洞问题"><a href="#缓存无底洞问题" class="headerlink" title="缓存无底洞问题"></a>缓存无底洞问题</h1><ul><li>2010年，Facebook有3000个memcache节点</li><li>发现问题： 加机器性能没有提升反而下降</li></ul><p><strong>问题关键点</strong></p><ul><li>更多的j机器 != 更高的性能</li><li>批量接口需求（mget、mset等）</li><li>数据增长与水平扩展需求</li></ul><h1 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h1><p>当缓存服务承载大量请求，如果缓存服务异常/宕机，流量直接压向后端DB，造成级联故障</p><p><strong>优化方案</strong><br></p><ul><li>保证缓存高可用：个别节点、个别机器、甚至是机房</li><li>依赖隔离组件为后端限流</li><li>提前演练：压力测试</li><li>cache服务高可用：redis-sentinel、redis-cluster、redis-VIP</li></ul><h1 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h1><p>缓存重建过程：我们知道使用缓存首先从缓存中获取,如果获取不到从数据库中获取，如果获取到了将数据写入缓存，该过程为缓存的重建的过程。该过程可能会出现的问题<br><br><img src="http://poporz7f8.bkt.clouddn.com/redis-redian01.jpg" alt></p><p>热点key（访问量大） + 较长的重建时间： 大量的线程作查询数据源和缓存重建的工作。解决方案：</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>第一个获取缓存的线程需要做重建的时候，将重建过程加锁。完成了重建工作再将锁解开。在这期间其他线程的发现重建过程处于等待状态，直到最后一个发现锁解开就可直接获取缓存进行输出<br><img src="http://poporz7f8.bkt.clouddn.com/redis-unlock.jpg" alt></p><blockquote><p>该解决方案没有大量的重建过程，但有等待的问题</p></blockquote><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key;</span><br><span class="line">    <span class="keyword">if</span>(cacheValue == <span class="keyword">null</span>)&#123; <span class="comment">// 重建工作</span></span><br><span class="line">        <span class="comment">// 设置互斥锁key</span></span><br><span class="line">        String mutexKey = <span class="string">"mutexKey:"</span> + key;</span><br><span class="line">        <span class="comment">//setnx命令：key不存在才进行设置</span></span><br><span class="line">        <span class="keyword">if</span>(redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>) )&#123; </span><br><span class="line">            <span class="comment">// 开始重建</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value);</span><br><span class="line">            <span class="comment">// 删除锁        </span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 存在该key，让其他线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 再次尝试获取key</span></span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h2><ul><li>缓存层面： 没有设置过期时间</li><li>功能层面： 为每一个value添加<em>逻辑过期时间</em>，发现过期了，使用单独线程去完成缓存的重建工作</li><li>该方案相比互斥锁没有等待的过程</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>缓存的收益: 加速读写、降低后端存储负载</li><li>缓存成本: 缓存和存储数据不一致性、代码维护成本、运维成本</li><li>缓存更新策略：超时删除 + 主动更新</li><li>缓存穿透问题：使用缓存空对象和布隆过滤器解决，注意他们各自使用场景</li><li>缓存雪崩问题： 缓存层的高可用、客户端降级、提前压力测试</li><li>热点key重建问题： 互斥锁、”永不过期” 来解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存的收益与成本&quot;&gt;&lt;a href=&quot;#缓存的收益与成本&quot; class=&quot;headerlink&quot; title=&quot;缓存的收益与成本&quot;&gt;&lt;/a&gt;缓存的收益与成本&lt;/h1&gt;&lt;h2 id=&quot;收益&quot;&gt;&lt;a href=&quot;#收益&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构与存储引擎</title>
    <link href="http://yoursite.com/2019/04/15/mysql/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/15/mysql/MySQL存储引擎概述/</id>
    <published>2019-04-15T12:48:06.000Z</published>
    <updated>2019-04-19T08:37:42.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第一章 MySQL架构与历史</em></p><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><ul><li><p>最上层服务是多数基于网络的客户端/服务器都有类似的架构</p></li><li><p>第二层是MySQL核心服务功能，查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等</p></li><li><p>第三层包含存储存储引擎，它负责MySQL中数据的存储和提取，存储引擎API包含几十个底层函数，例如执行<em>开始一个事务</em>等操作。注意：存储引擎并不会提取SQL</p></li></ul><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是mysql的默认<em>事务型引擎</em>, 使用最为广泛的的存储引擎。它的作用是处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>在MySQL5.1及之前的版本，默认使用MyISAM存储引擎。它提供了全文索引、压缩、空间函数等特性，它不支持事务和行级锁。不要默认开启此引擎，应当使用InnoDB。</p><p><br></p><h1 id="MySQL内建的其他存储引擎"><a href="#MySQL内建的其他存储引擎" class="headerlink" title="MySQL内建的其他存储引擎"></a>MySQL内建的其他存储引擎</h1><h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>它只支持insert、select操作，archive引擎会缓存所有的写并利用zlib对插入的行进行压缩，比MyISAM更少的IO</p><h2 id="Blackhole"><a href="#Blackhole" class="headerlink" title="Blackhole"></a>Blackhole</h2><p>它没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。可用于复制数据库进行备份，可在复制架构和日志审核时发挥作用。但是并不推荐</p><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>它可将普通的CSV文件（逗号分隔的文件）作为MySQL的表来处理，但这种表不支持索引。可将excel中的数据存储为CSV文件然后复制到MySQL数据目录。它可作为一种数据交换的机制</p><h2 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h2><p>该引擎是访问其他MySQL服务器的一个代理，默认是禁用的，它有一个后续的版本为FederatedX</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>如果需要快速访问数据，且这些数据不会被修改，它把数据保存在内存, 重启之后表结构还存在但是数据会丢失。使用场景：</p><ul><li>查询或映射表</li><li>缓存周期性聚合数据的结果</li><li>保存数据分析中产生的中间数据</li></ul><blockquote><p>memory支持hash索引，因此查询很快</p></blockquote><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>MyISAM的变种引擎，由多个表合并出来的虚拟表，该引擎已被放弃</p><h2 id="NDB"><a href="#NDB" class="headerlink" title="NDB"></a>NDB</h2><p>当时的MySQL AB公司从索尼爱立信公司收购了NDB数据库，开发了自己的NDB集群存储引擎</p><h1 id="第三方引擎"><a href="#第三方引擎" class="headerlink" title="第三方引擎"></a>第三方引擎</h1><p>MySQL从2007年提供了插件式的存储引擎API，因此由大多数的第三方产品或开源项目</p><h2 id="OLTP类引擎"><a href="#OLTP类引擎" class="headerlink" title="OLTP类引擎"></a>OLTP类引擎</h2><p>InnoDB是该类型的引擎，还有其他比如支持事务和MVCC的其中一个由PBXT</p><h2 id="面向列的存储引擎"><a href="#面向列的存储引擎" class="headerlink" title="面向列的存储引擎"></a>面向列的存储引擎</h2><p>MySQL默认是面向行的，没一行的数据是一起存储的，查询也是以行为单位处理。而在大数据量处理时，面向队列方式可能效率更高<br><br><strong>infobright</strong> 是一种面向列的存储引擎，在非常大的数据量（数十TB）时，该引擎工作良好。<br>它为数据分析和数据仓库而设计。该引擎不支持索引，不过在这么大的数据量，索引也很难发挥作用</p><h2 id="社区存储引擎"><a href="#社区存储引擎" class="headerlink" title="社区存储引擎"></a>社区存储引擎</h2><p>社区所提供的存储引擎很多，这里只介绍常见的</p><ul><li>Groonga： 全文索引引擎，号称可以提供准确高效的全文索引</li><li>OQGraph: 支持图操作，比如最短路径问题，用SQL很难实现该问题</li><li>Q4M：该引擎在MySQL内部实现了队列操作，用SQL很难实现该问题</li><li>SphinxSE: 该引擎为Sphinx全文索引搜索服务器提供了SQL接口</li><li>Spider: 该引擎可将数据切分为不同的分区，高效透明的实现了分片，并可分片执行并行查询</li><li>VPForMySQL: 该引擎支持垂直分区，指的是将表分成不同列的组合，进行单独存储。但是对于查询来说，看到的还是一张表</li></ul><h1 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h1><p>多数情况下，innoDB都是正确的选择, Oracle在MySQL5.5将innoDB作为默认引擎。如何选择归纳一句话 <strong>除非要用到innoDB不具备的特性，并且没有其他办法可替代</strong> ,</p><ul><li>如果需要事务，InnoDB是目前最稳定的选择</li><li>如果不需要要事务，并主要是SELECT和INSERT那么使用MyISAM</li></ul><h1 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h1><p>每种方法都有优缺点，以下只讲述三种方法：</p><ul><li>alter table<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure></li></ul><p>上诉语法可适用任何存储引擎，但有一个问题：需要执行很长时间，MySQL会按行将数据从原表复制一张新的表中，在复制期间可能会消耗系统所有的IO资源，同时原来的表会加上读锁</p><ul><li><p>导出于导入</p></li><li><p>创建于查询（create、select）</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>MySQL拥有分层架构，上层是服务器层的服务、和查询执行引擎。下层存储引擎</p></li><li><p>mysql的引擎和区别：InnoDB、MyISAM, 5.1之前的版本采用MyIsAM。InnoDB支持事务而MyISAM不支持事务，如果需要大量的插入数据操作使用MyISAM，其他情况优先使用InnoDB</p></li><li><p>如果要处理大数据量使用第三方引擎 infobright</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第一章 My
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis集群总结</title>
    <link href="http://yoursite.com/2019/04/15/redis/redis%E9%9B%86%E7%BE%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/redis/redis集群总结/</id>
    <published>2019-04-15T08:47:57.000Z</published>
    <updated>2019-04-19T08:22:07.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群总结"><a href="#集群总结" class="headerlink" title="集群总结"></a>集群总结</h1><p>redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写服务<br></p><ul><li><p>那么从节点的数据怎么和主节点的数据达到一致性呢？首先从节点拿到数据的原理是通过<em>RDB传输(主从复制原理)</em> 的方式来获取数据，而主从数据的一致性通过<em>偏移量</em>来判断数据的一致性。</p></li><li><p>数据一致性问题解决了，而故障转移redis是如何做到的？ 官方的两种方案： <strong>redis-sentinel</strong> 和 <strong>redis-cluster</strong>，redis-sentinel（哨兵）是一个独立的程序，它的作用是监控多个主从节点，如果发现主节点挂了会进行内部选举的模式让一个从节点成为主节点。而redis-cluster专门用于搭建集群模式的情况下使用，因此它本身就具备了高可用的特性。</p></li></ul><h1 id="rediscluster总结"><a href="#rediscluster总结" class="headerlink" title="rediscluster总结"></a>rediscluster总结</h1><ol><li><p>rediscluster数据分区规则使用虚拟槽（16384），每个节点负责一部分槽和相关数据，实现数据的和请求的均衡负载</p></li><li><p>搭建集群步骤：准备节点、节点握手、分配槽、复制。redis.trib.rb工具用于快速搭建集群</p></li><li><p>集群伸缩实现是通过节点之间移动槽和相关数据的实现</p></li></ol><ul><li>加入：把槽从原来的节点迁移到新节点</li><li>退出：如果要退出集群的节点中槽有数据，那么将它迁移到其他节点，在通过cluster forget命令广播集群让所有节点忘记</li></ul><ol start="4"><li>集群故障转移过程为故障发现和节点恢复。节点的下线分为主观下线和客观下线，当半数主节点认为你是故障了标记为客观下线。从节点负责故障恢复的过程，保证集群可用性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集群总结&quot;&gt;&lt;a href=&quot;#集群总结&quot; class=&quot;headerlink&quot; title=&quot;集群总结&quot;&gt;&lt;/a&gt;集群总结&lt;/h1&gt;&lt;p&gt;redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>rediscluster常见运维问题</title>
    <link href="http://yoursite.com/2019/04/15/redis/rediscluster%E5%B8%B8%E8%A7%81%E8%BF%90%E7%BB%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/15/redis/rediscluster常见运维问题/</id>
    <published>2019-04-15T07:54:03.000Z</published>
    <updated>2019-04-17T18:19:24.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助</p><h1 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h1><p>也就是我们在rediscluster篇章中配置的 <em>cluster-require-full-coverage </em> 默认true<br><br>它表示是否需要集群中的所有节点都是一个在线的状态，所有的0-16384槽都在一个服务的状态，才认为整个集群是完整的，才会对外提供服务<br></p><ul><li><p>但是对于大多数的业务都无法容忍，如果我们有1000主从节点，当其中一节点进行故障转移的期间（clusterdown the cluster is down）那么此时整个集群就不可用了</p></li><li><p>在实际生产过程中设置为 <em>no</em></p></li><li><p>为何默认为yes？ 集群中16384个槽全部不可用，这也设计就是为了保证集群完整性</p></li></ul><h1 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h1><p>我们知道集群节点之间使用信息的交换(gossip)，所以一定有带宽的开销。官方建议：最多1000个节点当节点规模较大时候，会有不容忽视的带宽消耗</p><ul><li><p>消息发送的频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</p></li><li><p>消息数据量：消息会槽信息，槽数组(2kb)，集群的1/10状态数据(10个节点1kb)</p></li><li><p>集群规模越高带宽越高</p></li><li><p>优化： cluster-node-timeout带宽和故障转移的速度的均衡</p></li></ul><h1 id="发布-订阅广播"><a href="#发布-订阅广播" class="headerlink" title="发布/订阅广播"></a>发布/订阅广播</h1><p>类似于mq的生产消息于订阅消息。当某个节点要通知集群中其他节点的时候，例如故障恢复。其他节点就会收到该消息，这样会产生一个问题，节点的带宽开销会很大。</p><ul><li><p>publish在集群每个节点广播，会加重带宽</p></li><li><p>解决: 如果只需要做到高可用，单独使用redissentinel</p></li></ul><h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><p>如果将原来节点的数据分布到多个节点上，可能会产生数据的倾斜，有如下原因</p><ul><li><p>节点和槽分配不均匀</p></li><li><p>不同槽对应键值数量差距大</p></li><li><p>包含bigkey</p></li><li><p>内存相关配置不一致</p></li></ul><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><ul><li><p>只读连接：集群模式的从节点不接受任何读写请求，会跳转到数据对应槽的主节点上，如果需要读（每次客户端执行readonly）</p></li><li><p>读写分离跟为复杂不建议在集群模式下实现，需要考虑复制延迟、读取过期数据、从节点故障。如果真要实现需要维护slave（思路类似redis-sentinel）</p></li></ul><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><p>如果我们需要将原来的单机节点迁移到rediscluster，这种模式如何实现？</p><ul><li><p>redis-trib.rb import可将单节点数据迁移到集群。不支持在线迁移，b不支持断点续传，单线程迁移</p></li><li><p>在线迁移：唯品会&gt;redis-migrate-tool、豌豆荚&gt;redis-port</p></li></ul><h1 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h1><ul><li><p>集群批量操作有限：如mget、mset必须在一个槽</p></li><li><p>集群事务和lua无法跨节点使用</p></li><li><p>集群模式只有一个db0，没有16个数据库</p></li><li><p>集群模式复制只支持一层，不支持树形复制结构</p></li></ul><p>rediscluster满足容量和新能的扩展性，但很多业务达不到一定的QPS，很多场景下redis-sentinel已经足够好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助&lt;/p&gt;
&lt;h1 id=&quot;集群
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>rediscluster高可用</title>
    <link href="http://yoursite.com/2019/04/15/redis/rediscluster%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/15/redis/rediscluster高可用/</id>
    <published>2019-04-15T07:49:51.000Z</published>
    <updated>2019-04-17T18:19:28.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><p>rediscluster不需要到sentinel即可完成故障转移，实现高可用的集群特性。它与sentinel很相似，分为故障发现和故障恢复的过程</p><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>依赖节点之间的通信使用ping/pong消息实现故障的发现，不需要sentinel</p><h2 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h2><p>定义：某个节点认为另一个节点不可用，”偏见”，代表一个节点对另一个节点的认知<br><br>流程：<br><img src="http://poporz7f8.bkt.clouddn.com/zhuguanxiaxian.jpg" alt></p><blockquote><p>当某个节点断开连接之后，超过node-timeout超时时间，那么标记为pfaill</p></blockquote><h2 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h2><p>定义： 持有半数以上的槽的节点都标记某个节点时，就认为那个节点不可用<br><br>流程：<br><img src="http://poporz7f8.bkt.clouddn.com/keguanxiaxianmoshi.jpg" alt></p><blockquote><p>记录每个节点的状态，如果状态不可用，会将信息添加到故障列表中，列表用于维护故障列表，后再尝试客观下线。之后通知集群内所有节点标记故障节点为客观下线，通知故障节点的从节点准备执行转移</p></blockquote><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>客观下线通知从节点，从节点接收到消息开始准备进行故障的恢复，从而保证集群的高可用，实现流程有：</p><ul><li>资格检查<br>检查哪些从节点可能成为主节点的资格条件：</li></ul><ol><li>每个从节点检查与故障主节点的断线时间</li><li>超过cluster-node-timeout(15) * cluster-slave-validity-factory(10)取消资格</li></ol><ul><li><p>选举<br>具备更大的偏移量（更接近主节点）成为主节点的可能性更大，选举的时间更小且投票个数更高，收集3张选票大于N/2+1，那么执行替换主节点工作</p></li><li><p>替换主节点</p></li></ul><ol><li>当前节点取消从节点复制，变为主节点（slaveof one one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己</li><li>集群广播消息，表明已经替换了故障从节点</li></ol><h1 id="故障转移实验"><a href="#故障转移实验" class="headerlink" title="故障转移实验"></a>故障转移实验</h1><p><strong>环境</strong>: springboot + 3主3从节点<br><br><strong>目的</strong>: 不断的从节点中set值, 中途将其中一个master kill观察情况</p><h2 id="maven依赖和配置"><a href="#maven依赖和配置" class="headerlink" title="maven依赖和配置"></a>maven依赖和配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TODO: spring-boot-starter-data-redis内部使用的不是jedis实现的连接池，经过之前的测试，如果使用lettuce-core这个连接池没有达到故障转移的效果, 所以这次实验使用jedis内部的连接池完成</p><p><strong>application.yml</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    cluster:</span></span><br><span class="line"><span class="attr">      nodes:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7001</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7002</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7003</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7004</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7005</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7006</span></span><br></pre></td></tr></table></figure></p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SpringbootRedisApplicationTests.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 不断的set值</span></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</span><br><span class="line">                String key = <span class="string">"k-"</span> + index;</span><br><span class="line">                String value = <span class="string">"v-"</span> + index;</span><br><span class="line">                redisTemplate.boundValueOps(key).set(value);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出日志</span></span><br><span class="line">                logger.info(<span class="string">"&#123;&#125; value is &#123;&#125;"</span>, key, redisTemplate.boundValueOps(key).get());              </span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>此时节点状态：<br><img src="http://poporz7f8.bkt.clouddn.com/clustertest01.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/clustertest02.jpg" alt></p></li><li><p>开始不断的set值，在进行kill主节点，观察日志输出：<br><img src="http://poporz7f8.bkt.clouddn.com/clustertest03.jpg" alt></p></li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/clustertest04.jpg" alt></p><p><img src="http://poporz7f8.bkt.clouddn.com/clustertest05.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;故障转移&quot;&gt;&lt;a href=&quot;#故障转移&quot; class=&quot;headerlink&quot; title=&quot;故障转移&quot;&gt;&lt;/a&gt;故障转移&lt;/h1&gt;&lt;p&gt;rediscluster不需要到sentinel即可完成故障转移，实现高可用的集群特性。它与sentinel很相似，分为故障
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot原理</title>
    <link href="http://yoursite.com/2019/04/14/springboot/springboot%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/14/springboot/springboot原理/</id>
    <published>2019-04-13T17:43:31.000Z</published>
    <updated>2019-04-19T08:22:05.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Boot是Spring旗下众多的子项目之一。其理念是约定优于配置，它通过实现了自动配置（大多数用户平时习惯设置的配置作为默认配置）的功能来为用户快速构建出标准化的应用。内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行</p><blockquote><p>特点：spring boot不是对spring的增强，而是提供了一种<strong>快速</strong>使用spring的方式</p></blockquote><blockquote><p>核心：起步依赖、自动配置</p></blockquote><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>使用idea快速搭建一个springboot项目：<br></p><ul><li><p>创建springboot项目<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-01.jpg" alt></p></li><li><p>指定包名和项目名<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-02.jpg" alt></p></li><li><p>选择需要的依赖文件<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-03.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-04.jpg" alt></p></li><li><p>项目结构如下<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-05.jpg" alt></p></li><li><p>pom依赖文件如下<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-06.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-07.jpg" alt></p></li><li><p>编写一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/info.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是我的第一个spring boot程序"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动spring boot引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问8080<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-08.jpg" alt><br><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-09.jpg" alt></p></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>起步依赖是spring boot的核心功能之一，起步依赖本质是maven定义了对其他库的传递依赖，简单的说，起步依赖就是将具备某种功能的坐标打包在一起，并提供一些默认的功能<br></p><ul><li>springboot的起步依赖核心坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>它提供了大量的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签</p><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>spring boot默认配置了一些用户常用的配置，因此不需要我们先编写xml（如web.xml）在编写代码进行开发，那么它是如何做到的呢?</p><p>我们开发一个spring boot都会有如下启动类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SpringBootApplication注解结构"><a href="#SpringBootApplication注解结构" class="headerlink" title="SpringBootApplication注解结构"></a>SpringBootApplication注解结构</h3><p><img src="http://poporz7f8.bkt.clouddn.com/springboot-10.jpg" alt></p><ul><li><p>@SpringBootConfiguration: 继承了Configuration（可进入查看），作用是取代xml的方式(spring的纯注解开发)</p></li><li><p>@ComponentScan：组件扫描，表示其他包可使用spring组件</p></li></ul><h3 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="EnableAutoConfiguration注解:"></a>EnableAutoConfiguration注解:</h3><p>开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助，将所有符合自动配置条件的bean定义加载到IOC容器中。<br>EnableAutoConfiguration有如下信息<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-11.jpg" alt></p><h3 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector类</h3><p>该类用于管理加载默认的配置信息，例如我们使用springmvc必须会经过<br>dispatchservlet，那么spring boot会将这些配置存储到如下文件中：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-12.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-13.jpg" alt><br>可发现这些类都AutoConfiguraion作为结尾, spring boot会将这些存有自动配置的类获取并加载, 我们分析其源代码：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-14.jpg" alt><br>可发现@bean，作用是取代xml的bean标签(spring的纯注解开发)</p><h3 id="EnableConfigurationProperties注解"><a href="#EnableConfigurationProperties注解" class="headerlink" title="EnableConfigurationProperties注解"></a>EnableConfigurationProperties注解</h3><p>该注解的作用是加载ServerProperties服务器相关配置属性类，例如上述搭建的程序，访问tomcat默认端口为8080，这些默认配置存储在如下文件中：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-15.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-16.jpg" alt></p><blockquote><p>当需要覆盖默认配置，在application.xml中指定即可</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>springboot的启动类会加载SpringBootApplication注解，该注解包含了@configuration（该类为配置类，取代xml）、@import（加入其他配置类）、自动装配的核心注解EnableAutoConfiguration，它用于完成记录默认的配置信息（web.xml）、服务器的配置信息(tomcat)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spring Boot是Spring旗下众多的子项目之一。其理念是约定优于配置，它通过实现了自动配置（大多数用户平时习惯设置的配置作为默认配
      
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>redis集群伸缩</title>
    <link href="http://yoursite.com/2019/04/12/redis/redis%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9/"/>
    <id>http://yoursite.com/2019/04/12/redis/redis集群伸缩/</id>
    <published>2019-04-12T07:53:48.000Z</published>
    <updated>2019-04-17T18:19:58.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>上一篇章中，我们分析了节点取余和一致性哈希产生数据迁移的问题，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的，每个节点与槽的分配都具备权力</p><h1 id="集群伸缩原理"><a href="#集群伸缩原理" class="headerlink" title="集群伸缩原理"></a>集群伸缩原理</h1><p>它的原理其实就是rediscluster的基本架构（在rediscluster文章所讲述）：</p><ul><li>节点: 每个节点负责读写</li><li>meet: 完成节点之间通信工作 A meet C; A meet B; B &gt; C</li><li>指派槽: 只有给节点指派了槽才可以进行读写</li><li>复制: 为了达到高可用，有主从复制概念</li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-shensuo.jpg" alt></p><blockquote><p>集群伸缩 = 槽和数据在节点之间的移动</p></blockquote><h1 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h1><p>首先加入集群的作用有：实现扩容、作为从节点负责故障转移，实现扩容的步骤：</p><h2 id="准备新的节点"><a href="#准备新的节点" class="headerlink" title="准备新的节点"></a>准备新的节点</h2><ul><li>集群模式</li><li>配置和其他节点统一</li><li>启动后是孤儿节点</li></ul><h2 id="加入集群（meet）"><a href="#加入集群（meet）" class="headerlink" title="加入集群（meet）"></a>加入集群（meet）</h2><p>将两个孤儿节点加入到集群中，(可通过cluster-meet完成，不推荐)，推荐使用redis-trib.rb加入集群，它会检测你加入的节点是否为孤儿节点，是才可进行加入</p><h2 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h2><blockquote><p>把其他节点负责的槽均匀的迁移到新节点，让它工作起来</p></blockquote><ul><li>槽迁移规划<br><br>  我们需要将槽进行均衡的分配<br><img src="http://poporz7f8.bkt.clouddn.com/redis-qianyicaojihua.jpg" alt></li></ul><ul><li>迁移数据<br><br><img src="http://poporz7f8.bkt.clouddn.com/redis-caoqianyiliuche.jpg" alt></li></ul><ol><li>让目标节点准备导入槽的数据: cluster setslot {slot} importing {sourceNodeId}</li><li>对源节迁移出槽数据：cluster setslot {slot} migrating {targetNodeId}</li><li>对源节点循环遍历槽，获取count个槽的key：cluster getkeysinslot {slot} {count}</li><li>在源节点执行：migrate {targetIp} {targetPort} key 0 {timeout}</li><li>重复执行步骤3-4直到槽下所有的键数据迁移到目标节点</li><li>通知槽分配个目标节点：cluster setslot {slot} node {targetNodeId}</li></ol><h1 id="加入集群实战"><a href="#加入集群实战" class="headerlink" title="加入集群实战"></a>加入集群实战</h1><blockquote><p>此时的集群状态<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiedianxinxi.jpg" alt></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动7006和7007(拷贝文件和修改配置文件不在阐述)</span></span><br><span class="line">root      52263      1  0 05:10 ?        00:00:00 redis-server *:7006 [cluster]</span><br><span class="line">root      52272      1  1 05:10 ?        00:00:00 redis-server *:7007 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时为孤立状态</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7006</span><br><span class="line">127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 :7006 myself,master - 0 0 0 connected</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入集群</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 192.168.211.136 7006</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 192.168.211.136 7007</span><br><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经加入了集群</span></span><br><span class="line">0936d215f3adc8aad93f935ba5ea72c7d6cc7bd0 192.168.211.136:7007 master - 0 1555017424796 7 connected</span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 192.168.211.136:7006 master - 0 1555017423368 0 connected</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7007（从）复制 7006（主）配置</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7007 cluster replicate d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为7006主节点分配槽，在/usr/<span class="built_in">local</span>/bin</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard 192.168.211.136:7000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示输入</span></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096</span><br><span class="line">What is the receiving node ID? d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type 'all' to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type 'done' once you entered all the source nodes IDs.</span><br><span class="line">Source node #1:all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看槽信息</span></span><br><span class="line">[root@zhongjinlang bin]# redis-cli -p 7006 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可发现槽有三份数据</span></span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 192.168.211.136:7006 myself,master - 0 0 8 connected 0-1364 5461-6826 10923-12287</span><br></pre></td></tr></table></figure><h1 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-shousuojiqun.jpg" alt><br>收缩集群就是对一个节点进行下线，实现步骤如下：</p><h2 id="下线迁移槽"><a href="#下线迁移槽" class="headerlink" title="下线迁移槽"></a>下线迁移槽</h2><p>我们将下线7006和7007，并将他们的槽均匀的给其他节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看集群</span></span><br><span class="line">redis-cli -p 7000 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将7006节点的槽（有三段）迁移给主节点7000</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to 5fe9ca13ded00d87f3271380f9e0c7278ec8c483 --slots 1366 192.168.211.136:7006</span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移给7001</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to d0941ed132c5a495545e1e30808cefd243942309 --slots 1365 192.168.211.136:7006</span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移给7002</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to 3f3b1a02189aa7b27d5ebc2038a07441933b7327 --slots 1365 192.168.211.136:7006</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先下线7006的从节点7000</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib del-node 192.168.211.136:7000 0936d215f3adc8aad93f935ba5ea72c7d6cc7bd0</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; SHUTDOWN the node.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下线7006</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib del-node 192.168.211.136:7000 d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时集群状态</span></span><br><span class="line">[root@zhongjinlang bin]# redis-cli -p 7000 cluster nodes</span><br><span class="line">bf5e78c9bc9728a2af1ac4077a539207146963a9 192.168.211.136:7004 slave d0941ed132c5a495545e1e30808cefd243942309 0 1555021435868 10 connected</span><br><span class="line">3a959f75d04e953b71c80f74f4d5c63b9fd319fd 192.168.211.136:7003 slave 5fe9ca13ded00d87f3271380f9e0c7278ec8c483 0 1555021438977 9 connected</span><br><span class="line">3f3b1a02189aa7b27d5ebc2038a07441933b7327 192.168.211.136:7002 master - 0 1555021437945 11 connected 10924-16383</span><br><span class="line">5fe9ca13ded00d87f3271380f9e0c7278ec8c483 192.168.211.136:7000 myself,master - 0 0 9 connected 0-5461</span><br><span class="line">d0941ed132c5a495545e1e30808cefd243942309 192.168.211.136:7001 master - 0 1555021440005 10 connected 5462-10923</span><br><span class="line">a9b8f471b99a598cf295f3c15dcb12325302d1bd 192.168.211.136:7005 slave 3f3b1a02189aa7b27d5ebc2038a07441933b7327 0 1555021434839 11 connected</span><br></pre></td></tr></table></figure><h1 id="rediscluster客户端"><a href="#rediscluster客户端" class="headerlink" title="rediscluster客户端"></a>rediscluster客户端</h1><p>当我们对一个rediscluster执行set或get时，rediscluster的计算规则是怎样的?</p><h2 id="move重定向"><a href="#move重定向" class="headerlink" title="move重定向"></a>move重定向</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-move-send.jpg" alt></p><p>当客户端拿到moved异常后，需要对目标执行命令，注意此时客户端并不会自动找到目标节点进行重定向发送(如果使用redis-cli)。而redis-cli-c内部完成了重定向</p><ul><li>槽命中和不命中情况<br><br>计算某个key所对应的槽位置的命令: cluster keyslot key<blockquote><p>如果set值，并在槽的范围内，返回OK</p></blockquote></li></ul><blockquote><p>如果不在槽返回为返回moved异常 + 槽位置 + 节点位置。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用redis-cli设置值</span></span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为php不在7000负责的槽范围内</span></span><br><span class="line">127.0.0.1:7000&gt; set php one</span><br><span class="line">(error) MOVED 9244 192.168.211.136:7001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用redis-cli-c集群模式连接</span></span><br><span class="line">127.0.0.1:7000&gt; set php best</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [9244] located at 192.168.211.136:7001</span></span><br><span class="line">OK</span><br><span class="line">192.168.211.136:7001&gt; get php</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure><h2 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h2><p>当进行集群缩容和扩容时，由于槽处于迁移的过程。例如：一个slot存在三个key，分别为hello1、hello2、hello3，假设此时槽正在处于迁移状态，hello1已经迁移到了目标节点，此时如果在源节点获取hello1，则会报出ask重定向错误</p><h2 id="move异常和ask异常"><a href="#move异常和ask异常" class="headerlink" title="move异常和ask异常"></a>move异常和ask异常</h2><ul><li>两者都是客户端重定向</li><li>moved: 槽已经确定迁移</li><li>ask： 槽还在迁移的过程中</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;上一篇章中，我们分析了节点取余和一致性哈希产生数据迁移的问题，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redisCluster</title>
    <link href="http://yoursite.com/2019/04/11/redis/redisCluster/"/>
    <id>http://yoursite.com/2019/04/11/redis/redisCluster/</id>
    <published>2019-04-11T13:37:51.000Z</published>
    <updated>2019-04-17T18:19:20.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sentinel问题引入"><a href="#sentinel问题引入" class="headerlink" title="sentinel问题引入"></a>sentinel问题引入</h1><p>上一篇章中，我们讲述了redis sentinel实现高可用。我们发现使用哨兵，每个slave都是全量存储数据，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。我们希望最大化的利用内存，采用集群，分布式存储。即每台redis都存储不同的内容。redisCluster是redis3.0推出的功能，有效的解决了redis分布式方面的需求，当遇到单机内存、并发、流量等瓶颈时，可采用cluster架构达到均衡负载的目的。</p><h2 id="sentinel和cluster"><a href="#sentinel和cluster" class="headerlink" title="sentinel和cluster"></a>sentinel和cluster</h2><p>sentinel与cluster是两个独立的功能，从特性来看sentinel可视为集群的子集，当不需要数据分片或已在客户端分片的场景下，sentinel足够使用了。如果需要进行水平扩容，那么cluster是一个很好的选择</p><h1 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h1><p>集群首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集<br><img src="http://poporz7f8.bkt.clouddn.com/redis-partition.jpg" alt></p><h2 id="顺序分区-哈希分区"><a href="#顺序分区-哈希分区" class="headerlink" title="顺序分区 | 哈希分区"></a>顺序分区 | 哈希分区</h2><ul><li><p>顺序分区保证每个节点的数据均衡<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sxufenbu.jpg" alt></p></li><li><p>哈希分区 对每一个数字进行哈希函数，按照节点取余(实现之一)<br><img src="http://poporz7f8.bkt.clouddn.com/redis-hashfenbu.jpg" alt></p></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-fenquduibi.jpg" alt></p><h1 id="哈希分区探究"><a href="#哈希分区探究" class="headerlink" title="哈希分区探究"></a>哈希分区探究</h1><p>redis-cluster采用哈希分区的方式进行数据分布，为此我们将进一步分析</p><h2 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h2><p>对每一个key对3（节点个数）取余，如果余数为0则分布到第一个节点，余数为2则分布到第二个节点，余数为3则分布到第三个节点<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiedianquyu.jpg" alt></p><ul><li>客户端分片: 哈希 + 取余</li><li>节点伸缩： 节点变化，数据迁移量巨大</li></ul><h2 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h2><p>解决了节点取余的缺点<br>token表示一个数据范围，为每一个节点分配一个token，每一个节点负责一部分token数据。当对key进行hash计算后按照顺时针的规则寻找离它最近的节点</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-yizhixhash.jpg" alt></p><ul><li>客户端分片: 哈希 + 取余(优化取余)</li><li>节点伸缩： 只影响临近节点，但还是有数据迁移</li></ul><h2 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h2><p>Redis Cluster中有一个16384长度的槽的概念, 每个槽映射一个数据子集, 按照一定的hash计算对16383取余, 如果它落在某个槽的范围内，那么就证明这个槽必须所管理的数据，它是由服务端管理接节点槽之间的关系<br><img src="http://poporz7f8.bkt.clouddn.com/redis-xunicao.jpg" alt></p><p>节点取余分区和一致性哈希分区当节点伸缩时，都会进行数据的迁移，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的，每个节点与槽的分配都具备权力</p><h1 id="redisCluster架构"><a href="#redisCluster架构" class="headerlink" title="redisCluster架构"></a>redisCluster架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-jiagou.jpg" alt></p><p>服务端有多个节点，<strong>每个节点都负责读写，节点之间是彼此通信的</strong>。如果节点A覆盖0－5460、节点B覆盖5461－10922、节点C覆盖10923－16383。 如果存入一个值，按照redis cluster哈希槽的算法： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><ul><li><p>节点: 每个节点负责读写</p></li><li><p>meet: 完成节点之间通信工作 A meet C; A meet B; B &gt; C</p></li><li><p>指派槽: 只有给节点指派了槽才可以进行读写</p></li><li><p>复制: 为了达到高可用，有主从复制概念</p></li></ul><blockquote><p>rediscluster特性：复制、高可用、分片</p></blockquote><h1 id="原生命令安装"><a href="#原生命令安装" class="headerlink" title="原生命令安装"></a>原生命令安装</h1><blockquote><p><strong>环境</strong></p><ul><li>3主3从</li></ul></blockquote><pre><code>&gt; 192.168.211.134:7000(主)&gt; 192.168.211.134:7001(主)&gt; 192.168.211.134:7002(主)&gt; 192.168.211.134:7003(从)&gt; 192.168.211.134:7004(从)&gt; 192.168.211.134:7005(从)</code></pre><h2 id="redis-7000-70005-conf"><a href="#redis-7000-70005-conf" class="headerlink" title="redis-[7000-70005].conf"></a>redis-[7000-70005].conf</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir ./</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dbfilename "dump-7000.rdb"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启cluster</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster配置文件</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有一个master宕机，没有故障恢复，整个集群不可用（默认<span class="literal">true</span>）</span></span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><blockquote><p>其他配置文件只需修改端口即可</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-server redis-7000.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7001.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7002.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7003.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7004.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7005.conf</span><br><span class="line">[root@localhost cluster]# ps -ef | grep redis</span><br><span class="line">root      57254      1  0 01:44 ?        00:00:00 redis-server *:7000 [cluster]</span><br><span class="line">root      57258      1  0 01:44 ?        00:00:00 redis-server *:7001 [cluster]</span><br><span class="line">root      57262      1  0 01:44 ?        00:00:00 redis-server *:7002 [cluster]</span><br><span class="line">root      57266      1  0 01:44 ?        00:00:00 redis-server *:7003 [cluster]</span><br><span class="line">root      57270      1  0 01:44 ?        00:00:00 redis-server *:7004 [cluster]</span><br><span class="line">root      57274      1  0 01:44 ?        00:00:00 redis-server *:7005 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试连接</span></span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">(error) CLUSTERDOWN The cluster is down</span><br></pre></td></tr></table></figure><blockquote><p>我们可发现当set值时，错误表示当前集群是一个下线状态，因为在集群模式下，只有成功分配了槽且16383都进行了完整的分配，才可进行对外提供服务</p></blockquote><h2 id="meet"><a href="#meet" class="headerlink" title="meet"></a>meet</h2><blockquote><p>port meet port<br>完成节点之间的通信</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7001</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7002</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7003</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7004</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7005</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster nodes</span><br><span class="line">9c736c0733323151ee5aeaa8444cf177ab9b312b 192.168.211.134:7005 master - 0 1554832945389 5 connected</span><br><span class="line">97ba85211fa2d68ebff5ae4848eb4a52a899be5a 192.168.211.134:7003 master - 0 1554832943331 4 connected</span><br><span class="line">0ed9079a0d32b7e926a96d6a03d431c1228deffb 192.168.211.134:7000 myself,master - 0 0 1 connected</span><br><span class="line">89d495be82b618256b5c79a56f6894658db4cfa8 192.168.211.134:7004 master - 0 1554832942315 3 connected</span><br><span class="line">b4c274d2501d4d105c8b7acf7787a66287a7406a 192.168.211.134:7001 master - 0 1554832941298 0 connected</span><br><span class="line">8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 192.168.211.134:7002 master - 0 1554832944358 2 connected</span><br></pre></td></tr></table></figure><blockquote><p>此时6个节点已经达成相互通信!</p></blockquote><h2 id="分配槽点"><a href="#分配槽点" class="headerlink" title="分配槽点"></a>分配槽点</h2><p>redis总共有16384个槽点，并且只有主节点需要分配槽点，这里我们使用的是三主三从，因此将槽点均分为三等分:0–5460，5461–10922，10923–16383</p><ul><li><p>首先我们编写一个sh脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line">port=$3</span><br><span class="line"></span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">        echo "slot:$&#123;slot&#125;"</span><br><span class="line">        redis-cli -h 192.168.211.134 -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>分别为7000、7001、7002三个从节点分配槽节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh add_slots.sh 0 5460 7000</span><br><span class="line">sh add_slots.sh 5461 10922 7001</span><br><span class="line">sh add_slots.sh 10923 16383 7002</span><br></pre></td></tr></table></figure></li><li><p>查看槽信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-16384.jpg" alt></p></li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-slots.jpg" alt></p><ul><li>设置值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ul><h2 id="主从关系分配"><a href="#主从关系分配" class="headerlink" title="主从关系分配"></a>主从关系分配</h2><blockquote><p>cluster replicate node-id<br>完成 7000-&gt;7003、7001-&gt;7004、7002-&gt;7005</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-cli -p 7003 cluster replicate 0ed9079a0d32b7e926a96d6a03d431c1228deffb</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7004 cluster replicate b4c274d2501d4d105c8b7acf7787a66287a7406a</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7005 cluster replicate 8465de32a8e17d23134d8ae8d62f2c78c9e40ef2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现7005-7004都成为了salve</span></span><br><span class="line">9c736c0733323151ee5aeaa8444cf177ab9b312b 192.168.211.134:7005 slave 8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 0 1554833875305 5 connected</span><br><span class="line">97ba85211fa2d68ebff5ae4848eb4a52a899be5a 192.168.211.134:7003 slave 9c736c0733323151ee5aeaa8444cf177ab9b312b 0 1554833874286 5 connected</span><br><span class="line">89d495be82b618256b5c79a56f6894658db4cfa8 192.168.211.134:7004 slave b4c274d2501d4d105c8b7acf7787a66287a7406a 0 1554833871215 3 connected</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3个主节点</span></span><br><span class="line">0ed9079a0d32b7e926a96d6a03d431c1228deffb 192.168.211.134:7000 myself,master - 0 0 1 connected</span><br><span class="line">b4c274d2501d4d105c8b7acf7787a66287a7406a 192.168.211.134:7001 master - 0 1554833873263 0 connected</span><br><span class="line">8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 192.168.211.134:7002 master - 0 1554833876331 2 connected</span><br></pre></td></tr></table></figure><h1 id="Ruby搭建集群"><a href="#Ruby搭建集群" class="headerlink" title="Ruby搭建集群"></a>Ruby搭建集群</h1><p>ruby是官方推荐的搭建集群方式，自动分配槽和主从复制</p><h2 id="安装ruby环境"><a href="#安装ruby环境" class="headerlink" title="安装ruby环境"></a>安装ruby环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ruby依赖</span></span><br><span class="line">yum install ruby rubygems -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gem-redis安装  https://rubygems.org/gems/redis/versions/3.0.0</span></span><br><span class="line">gem install -l redis-3.0.0.gem  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时redis3.0.0/src目录有 redis.trib.rb文件，将它拷贝到/usr/lcoal/bin</span></span><br><span class="line">cp redis-trib.rb /usr/local/bin/redis-trib</span><br></pre></td></tr></table></figure><ul><li>redis-trib用于管理集群的命令<br><img src="http://poporz7f8.bkt.clouddn.com/redis-trib.jpg" alt></li></ul><h2 id="配置6个节点并启动"><a href="#配置6个节点并启动" class="headerlink" title="配置6个节点并启动"></a>配置6个节点并启动</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">port</span> <span class="number">7001</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"7001.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"dump-7001.rdb"</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-7001.conf</span></span><br><span class="line"><span class="string">cluster-require-full-coverage</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><blockquote><p>其他节点修改端口即可，分别启动：<br><img src="http://poporz7f8.bkt.clouddn.com/ztai.jpg" alt></p></blockquote><h2 id="使用redis-trib搭建集群"><a href="#使用redis-trib搭建集群" class="headerlink" title="使用redis-trib搭建集群"></a>使用redis-trib搭建集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib create --replicas 1 192.168.211.136:7001 192.168.211.136:7002 192.168.211.136:7003 192.168.211.136:7004 192.168.211.136:7005 192.168.211.136:7006</span><br></pre></td></tr></table></figure><ul><li><p>启动状态如下<br><img src="http://poporz7f8.bkt.clouddn.com/redis-ruby-cluster.jpg" alt></p></li><li><p>cluster info打印集群信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiqungeshu.jpg" alt></p></li><li><p>cluster nodes列出集群已知节点<br><img src="http://poporz7f8.bkt.clouddn.com/cluster-nodes.jpg" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sentinel问题引入&quot;&gt;&lt;a href=&quot;#sentinel问题引入&quot; class=&quot;headerlink&quot; title=&quot;sentinel问题引入&quot;&gt;&lt;/a&gt;sentinel问题引入&lt;/h1&gt;&lt;p&gt;上一篇章中，我们讲述了redis sentinel实现高可用
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis集群——哨兵</title>
    <link href="http://yoursite.com/2019/04/08/redis/redis%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%93%A8%E5%85%B5/"/>
    <id>http://yoursite.com/2019/04/08/redis/redis集群——哨兵/</id>
    <published>2019-04-08T08:59:57.000Z</published>
    <updated>2019-04-17T18:19:49.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制问题引入"><a href="#主从复制问题引入" class="headerlink" title="主从复制问题引入"></a>主从复制问题引入</h1><p>当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。我们希望可做到高可用的故障转移，也就是说如果有一个服务宕机了，希望有另一台服务可顶替。通俗的将就是将故障进行转移，保证redis整体服务是可运行的</p><h2 id="master故障"><a href="#master故障" class="headerlink" title="master故障"></a>master故障</h2><p>如果slave出现故障，问题并不是很大，因为可以从master进行读写操作。如果master故障了，那么其他从节点将会断开与master的连接，此时客户端只可进行读的操作<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault.jpg" alt></p><h2 id="master宕机处理"><a href="#master宕机处理" class="headerlink" title="master宕机处理"></a>master宕机处理</h2><p>首先我们要保证有写数据，可以将一台slave成为master，另外一台成为从节点<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault-success.jpg" alt></p><p>上述问题并没有解决自动故障转移的主要问题：自动让slave成为master，让其他slave同步master</p><h1 id="redis-sentinel架构"><a href="#redis-sentinel架构" class="headerlink" title="redis sentinel架构"></a>redis sentinel架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel1.jpg" alt></p><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案, Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。它的主要功能有如下几点</p><ol><li><p>不时地监控redis是否按照预期良好地运行</p></li><li><p>如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端)</p></li><li><p>能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址</p></li></ol><h2 id="sentinel核心配置"><a href="#sentinel核心配置" class="headerlink" title="sentinel核心配置"></a>sentinel核心配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 去掉注释查看文件</span></span><br><span class="line">[root@localhost config]# cat sentinel.conf | grep -v "#" | grep -v "^$"</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel默认端口</span></span><br><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控主节点 2标识你需要几个sentinel对master进行发现问题</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障时间</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制同时并发执行</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障转移时间</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><h1 id="sentinel实验"><a href="#sentinel实验" class="headerlink" title="sentinel实验"></a>sentinel实验</h1><p>实现如下配置</p><ul><li>master-7000、slave-7001、slave-7002</li><li>sentinel-26379(默认端口)、sentinel-26380、sentinel-26381</li></ul><h2 id="开启主从节点"><a href="#开启主从节点" class="headerlink" title="开启主从节点"></a>开启主从节点</h2><h3 id="redis-7000-conf-master"><a href="#redis-7000-conf-master" class="headerlink" title="redis-7000.conf(master)"></a>redis-7000.conf(master)</h3><blockquote><p>vim redis-{port}.conf: 分别添加如下配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="redis-7001-conf-slave"><a href="#redis-7001-conf-slave" class="headerlink" title="redis-7001.conf(slave)"></a>redis-7001.conf(slave)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7001.pid</span><br><span class="line">logfile "7001.log"</span><br><span class="line">dir ./</span><br><span class="line">slaveof 192.168.211.134 7000</span><br></pre></td></tr></table></figure><blockquote><p>redis-7002.conf修改端口即可</p></blockquote><h3 id="启动一主二从"><a href="#启动一主二从" class="headerlink" title="启动一主二从"></a>启动一主二从</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-server redis-7000.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7001.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7002.conf </span><br><span class="line">[root@localhost config]# redis-cli -p 7000 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7001 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7002 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7000 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.211.134,port=7001,state=online,offset=197,lag=0</span><br><span class="line">slave1:ip=192.168.211.134,port=7002,state=online,offset=197,lag=1</span><br></pre></td></tr></table></figure><h2 id="开启sentinel"><a href="#开启sentinel" class="headerlink" title="开启sentinel"></a>开启sentinel</h2><h3 id="sentinel-26379-conf"><a href="#sentinel-26379-conf" class="headerlink" title="sentinel-26379.conf"></a>sentinel-26379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir /tmp</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><blockquote><p>其他sentinel-26380.conf、sentinel-26381.conf修改端口即可</p></blockquote><h2 id="测试sentinel"><a href="#测试sentinel" class="headerlink" title="测试sentinel"></a>测试sentinel</h2><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26379.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26380.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><h3 id="sentinel-info"><a href="#sentinel-info" class="headerlink" title="sentinel info"></a>sentinel info</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 26379</span><br><span class="line">127.0.0.1:26379&gt; set hello world</span><br><span class="line">(error) ERR unknown command 'set'</span><br><span class="line">127.0.0.1:26379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:26379&gt; info</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel 的一些信息</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinels=3 有三个sentinel</span></span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.211.134:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><blockquote><p>我们可发现sentinel监控的master和开启了多少个sentinel进行监控主从的信息</p></blockquote><h3 id="查看sentinel的变化"><a href="#查看sentinel的变化" class="headerlink" title="查看sentinel的变化"></a>查看sentinel的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# cat redis-sentinel-26379.conf </span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir "/tmp"</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7001</span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by CONFIG REWRITE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7002</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><blockquote><p>sentinel会自动发现slave信息</p></blockquote><h1 id="客户端连接sentinel"><a href="#客户端连接sentinel" class="headerlink" title="客户端连接sentinel"></a>客户端连接sentinel</h1><p>为什么我们不直接连接master? 因为我们采用高可用的方式，如果服务器端master宕机了，sentinel会完成自动的故障转移，那么此时客户端就不知道master节点的ip了。</p><blockquote><p>基本原理：</p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-client.jpg" alt></p><h1 id="故障转移实验"><a href="#故障转移实验" class="headerlink" title="故障转移实验"></a>故障转移实验</h1><p>我们将实现从master-7000端口中不断的set值，然后将master进程kill看看sentinel会不会自动处理故障转移</p><h2 id="mavean依赖"><a href="#mavean依赖" class="headerlink" title="mavean依赖"></a>mavean依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ResisSentinelTest-java"><a href="#ResisSentinelTest-java" class="headerlink" title="ResisSentinelTest.java"></a>ResisSentinelTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResisSentinelTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisPipelineTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26379"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26380"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26381"</span>);</span><br><span class="line">        JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取连接</span></span><br><span class="line">                jedis = sentinelPool.getResource();</span><br><span class="line">                <span class="comment">// 不断的set值</span></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</span><br><span class="line">                String key = <span class="string">"k-"</span> + index;</span><br><span class="line">                String value = <span class="string">"v-"</span> + index;</span><br><span class="line">                jedis.set(key, value);</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">"&#123;&#125; value is &#123;&#125; "</span>, key, jedis.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行上述代码之后会不断的输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_1.jpg" alt></p></li><li><p>当我们在进行kill master之后控制台会输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_2.jpg" alt></p></li></ul><p><strong>当过了30秒之后sentinel会进行故障转移，恢复set的操作</strong></p><ul><li>我们可以查看salve-7001和slave和7002哪个成为了master<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br></pre></td></tr></table></figure></li></ul><h1 id="sentinel原理"><a href="#sentinel原理" class="headerlink" title="sentinel原理"></a>sentinel原理</h1><p>sentinel可以对redis节点作失败判定以及故障转移，在sentinel内部有三个定时任务作为基础来实现上述所描述的</p><ul><li><p>每10秒每个sentinel对master和slave执行info</p><blockquote><p>发现slave</p></blockquote><blockquote><p>确认主从关系</p></blockquote></li><li><p>每两秒每个sentinel和master进行发布订阅模式的形式，达成整体的信息交互平台</p><blockquote><p>通过<em>sentinel</em>:hello频道交互</p></blockquote><blockquote><p>交互对节点的”看法”和自身信息</p></blockquote></li><li><p>每一秒每个sentinel对其他sentinel和redis执行ping</p><blockquote><p>心跳检测、失败判定的依据</p></blockquote></li></ul><h2 id="主观下线-客观下线"><a href="#主观下线-客观下线" class="headerlink" title="主观下线|客观下线"></a>主观下线|客观下线</h2><p>sentinel核心配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor [master-group-name] [ip] [port] [quorum]</span><br></pre></td></tr></table></figure><p>这一行用于告诉Redis监控一个master叫做mymaster，它的地址在127.0.0.1，端口为6379，票数是2，<strong>票数个数建议为奇数, 且个数=1/2+1</strong></p><p><strong>quorun</strong>：票数，sentinel需要协商同意master是否可到达的数量，举个例子，redis集群中有5个sentinel实例，其中master挂掉啦，如果这里的票数是2，表示有2个sentinel认为master挂掉啦，才能被认为是正真的挂掉啦</p><h3 id="down-after-milliseconds"><a href="#down-after-milliseconds" class="headerlink" title="down-after-milliseconds"></a>down-after-milliseconds</h3><p>sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会<strong>主观</strong>地认为这个master已经不可用了。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。</p><p><strong>主观下线</strong>：每个sentinel节点对redis节点的失败的”偏见”</p><p><strong>客观下线</strong>：所有sentinel节点对redis节点失败”达成共识”（超过票数个统一）</p><h3 id="parallel-syncs"><a href="#parallel-syncs" class="headerlink" title="parallel-syncs"></a>parallel-syncs</h3><p>在发生failover主从切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成主从故障转移所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为主从同步而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</p><h2 id="领导则选举"><a href="#领导则选举" class="headerlink" title="领导则选举"></a>领导则选举</h2><p>我们知道之际上完成故障转移的任务只需要一个sentinel即可。选举通过sentinel is-master-down-by-addr命令都希望成为领导者，此命令的作用: 一<strong>确认下线判定</strong>，二是进行<strong>领导者选举</strong></p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>1）每个做主观下线的sentinel节点向其他sentinel节点发送上面那条命令，要求将它设置为领导者。</p><p>2）收到命令的sentinel节点如果还没有同意过其他的sentinel发送的命令（还未投过票），那么就会同<br>意，否则拒绝。</p><p>3）如果该sentinel节点发现自己的票数已经过半且达到了quorum的值，就会成为领导者</p><p>4）如果这个过程出现多个sentinel成为领导者，则会等待一段时间重新选举</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>redis-sentinel是redis实现高可用的方案：故障发现、故障自动转移、配置中心、客户端通知</p></li><li><p>redis-sentinel是redis2.8版本才开始正式使用 </p></li><li><p>尽可能在不同的物理机上部署redis-sentinel所有节点</p></li><li><p>redis-sentinel中的sentinel节点个数应该为大于等于3且最好为奇数</p></li><li><p>客户端初始化连接的是sentinel节点集合，不再是具体的redis节点，但是sentinel只是配置中心不是代理</p></li><li><p>redis-sentinel通过三个定时任务实现了sentinel节点对主从节点、其余sentinel节点的监控</p></li><li><p>redis-sentinel在对节点做失败判定时分为主管下线和和客观下线</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制问题引入&quot;&gt;&lt;a href=&quot;#主从复制问题引入&quot; class=&quot;headerlink&quot; title=&quot;主从复制问题引入&quot;&gt;&lt;/a&gt;主从复制问题引入&lt;/h1&gt;&lt;p&gt;当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
