<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-17T18:15:02.091Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeperACL权限控制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeperACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeperACL权限控制/</id>
    <published>2019-04-17T16:12:12.000Z</published>
    <updated>2019-04-17T18:15:02.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为ACL-access-control-lists"><a href="#何为ACL-access-control-lists" class="headerlink" title="何为ACL(access control lists)?"></a>何为ACL(access control lists)?</h1><p>可以对节点设置读写等权限，来保障数据的安全性，权限permission可以指定不同的范围以及角色<br></p><h1 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h1><ul><li>getAcl：获取某个节点的权限信息</li><li>setAcl：设置某个节点的权限</li><li>addauth： 输入认证授权信息，注册用户将用户根据指定的权限才可登入</li></ul><h2 id="ACL的构成一"><a href="#ACL的构成一" class="headerlink" title="ACL的构成一"></a>ACL的构成一</h2><ul><li><p>zookeeper的ACL通过[scheme:id:permission]来构成权限列表</p><blockquote><p>scheme: 代表采用的某种全新机制</p></blockquote><blockquote><p>id: 代表允许访问的用户</p></blockquote><blockquote><p>permission: 权限组合字符串</p></blockquote></li></ul><h2 id="ACL的构成二-scheme"><a href="#ACL的构成二-scheme" class="headerlink" title="ACL的构成二 - scheme"></a>ACL的构成二 - scheme</h2><ul><li><p>world：只有一个用户, 语法: world:anyone:[permission] 默认情况下它表示任何人都可访问这一节点</p></li><li><p>auth：认证登入，需要注册用户且有权限。语法：auth:user:password:[permission]</p></li><li><p>digest：需要对密码进行加密才可访问，语法：digest：username:BASE64(SHA1(password)):[permission]</p></li><li><p>ip: 可限制某个ip的访问，语法：ip:192.168.1.1:[permission]</p></li><li><p>super: 代表超级管理员，拥有所有权限</p></li></ul><h2 id="ACL的构成三-permission"><a href="#ACL的构成三-permission" class="headerlink" title="ACL的构成三 - permission"></a>ACL的构成三 - permission</h2><p>权限字符串使用缩写 crdwa，分别表示：</p><ul><li>c: create创建子节点。表示设置了改权限才可进行创建子节点</li><li>r: read获取节点/子节点列表的权限 </li><li>d: delete删除子节点权限</li><li>w: write写节点数据权限</li><li>a: admin权限才可分配permission</li></ul><h1 id="ACL实战"><a href="#ACL实战" class="headerlink" title="ACL实战"></a>ACL实战</h1><h2 id="world"><a href="#world" class="headerlink" title="world"></a>world</h2><p><em>创建一个节点并查看默认的权限</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /imooc/abc data </span><br><span class="line">Created /imooc/abc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] getAcl /imooc/abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拥有所有权限</span></span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure></p><p><em>设置权限：禁止删除</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] setAcl /imooc/abc world:anyone:crwa</span><br></pre></td></tr></table></figure></p><p><em>此时节点的权限、后新创建一个节点再进行删除测试（因为当前节点拥有之前的权限）</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /imooc/abc</span><br><span class="line">'world,'anyone</span><br><span class="line">: crwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] create /imooc/abc/xyz new-data-isnotdelete </span><br><span class="line">Created /imooc/abc/xyz</span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] delete /imooc/abc/xyz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示权限不足</span></span><br><span class="line">Authentication is not valid : /imooc/abc/xyz</span><br></pre></td></tr></table></figure></p><h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>明文登入<br><em>注册账号并登入</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 39] create /name/zhangsan zs </span><br><span class="line">Created /name/zhangsan</span><br><span class="line">[zk: localhost:2181(CONNECTED) 40] getAcl /name/zhangsan</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登入提示没有这个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] setAcl /name/zhangsan auth:zhangsan:123:cdrwa     </span><br><span class="line">Acl is not valid : /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注册一个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 42] addauth digest zhangsan:zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次登入</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] setAcl /name/zhangsan auth:zhangsan:123:cdrwa</span><br></pre></td></tr></table></figure></p><p><em>此时权限信息</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 44] getAcl /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码存在数据库中是一个密文</span></span><br><span class="line">'digest,'zhangsan:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdrwa</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># digest</span></span></span><br><span class="line">使用密文方式登入</span><br><span class="line"></span><br><span class="line">*创建新的节点 并设置登入账号以及密码*</span><br><span class="line">```shell</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /name/lisi</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码（密文）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] setAcl /name/lisi digest:lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=:cdra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /name/lisi</span><br><span class="line">'digest,'lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdra</span><br></pre></td></tr></table></figure></p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>控制某个网段是否有权限来访问目录节点，通常用于控制客户端</p><p><em>创建一个新的节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] create /name/ip ip</span><br><span class="line">Created /name/ip</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /name/ip</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] setAcl /name/ip ip:192.168.117.1:cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] getAcl /name/ip</span><br><span class="line">'ip,'192.168.117.1</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时虚拟机不可访问</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] get /name/ip</span><br><span class="line">Authentication is not valid : /name/ip</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper的ACL可对节点进行权限控制来保障数据安全性</li><li>world：默认所有用户登入</li><li>auth：注册用户登入，注册密码时为明文</li><li>digest：注册用户登入，注册密码时为密文</li><li>ip: 可限制网段访问</li><li>super: 可访问所有权限</li><li>ACL使用场景一：开发/测试环境分离，开发者无权操作测试库的节点，只能看</li><li>ACL使用场景二：生产环境上控制指定IP的服务可以访问相关节点，防止混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为ACL-access-control-lists&quot;&gt;&lt;a href=&quot;#何为ACL-access-control-lists&quot; class=&quot;headerlink&quot; title=&quot;何为ACL(access control lists)?&quot;&gt;&lt;/a&gt;何为ACL(
      
    
    </summary>
    
      <category term="zookeeper与dubbo" scheme="http://yoursite.com/categories/zookeeper%E4%B8%8Edubbo/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper的watch机制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper%E7%9A%84watch%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper的watch机制/</id>
    <published>2019-04-17T16:11:33.000Z</published>
    <updated>2019-04-17T16:39:05.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为watch"><a href="#何为watch" class="headerlink" title="何为watch?"></a>何为watch?</h1><p>针对每个节点的操作，都会有一个监督者<strong>watch</strong>。当节点发现变化时，如create、set、delete都会触发一个watch事件。<br><br>zookeeper中的watch是一次性的，<em>触发后立即销毁</em>。注意是在zookeeper中</p><ul><li><p>父节点，子节点增删改都会触发watch</p></li><li><p>针对不同类型的操作，触发的watch事件不同：如节点创建事件、节点删除事件、节点数据变化事件</p></li></ul><h1 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h1><h2 id="父节点watch事件"><a href="#父节点watch事件" class="headerlink" title="父节点watch事件"></a>父节点watch事件</h2><ul><li>创建父节点触发: NodeCreated</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先设置一个事件（<span class="built_in">set</span> get都可以 使用<span class="built_in">help</span>查看）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] stat /imooc watch  </span><br><span class="line">Node does not exist: /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发了事件</span></span><br><span class="line">watch::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/imooc</span><br><span class="line">Created /imooc</span><br></pre></td></tr></table></figure><ul><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li></ul><h2 id="子节点watch事件"><a href="#子节点watch事件" class="headerlink" title="子节点watch事件"></a>子节点watch事件</h2><p>ls为父节点设置watch</p><ul><li>创建子节点触发：NodeChildrenChanged<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /imooc</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /imooc watch </span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /imooc/abc 88 </span><br><span class="line">Created /imooc/abc</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/imooc</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>触发了NodeChildrenChanged</p></blockquote><ul><li>删除子节点也是触发：NodeChildrenChanged</li><li><p>修改子节点不会触发事件</p></li><li><p>TODO：增加和删除触发的事件为什么一样：因为它们为子节点，子节点和父节点需要进行区分，父节点有不同的事件，对于父节点来说不需要关注子节点的事件。因为父节点只需要告诉客户端 哦我的子节点改变了NodeChildrenChanged事件</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper节点（子父）发生变化时，会触发watch事件，并且出发后立即销毁（在zookeeper中)不同的类型操作watch事件也不同（增、删、改）</li><li>在修改节点数据之前可设置watch，如果下次获取该节点时会触发不同的watch类似</li><li>父节点触发watch事件有： NodeCreated（增）、NodeDeleted（删）、NodeDataChanged（改）</li><li>子节点触发watch事件有:  NodeChildrenChanged（增删）、修改不会触发事件因为对于父节点来说并不关心</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为watch&quot;&gt;&lt;a href=&quot;#何为watch&quot; class=&quot;headerlink&quot; title=&quot;何为watch?&quot;&gt;&lt;/a&gt;何为watch?&lt;/h1&gt;&lt;p&gt;针对每个节点的操作，都会有一个监督者&lt;strong&gt;watch&lt;/strong&gt;。当节点发现变化
      
    
    </summary>
    
      <category term="zookeeper与dubbo" scheme="http://yoursite.com/categories/zookeeper%E4%B8%8Edubbo/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper命令使用</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper命令使用/</id>
    <published>2019-04-17T16:10:33.000Z</published>
    <updated>2019-04-17T16:38:47.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>通过 ./zkCli.sh打开客户端进行命令行后台操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# zkCli.sh</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="ls-ls2"><a href="#ls-ls2" class="headerlink" title="ls | ls2"></a>ls | ls2</h2><p><strong>查看zookeeper路径</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p><strong>查看状态信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建了之后，zk为这个节点所分配的ID</span></span><br><span class="line">cZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> create-time</span></span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后zk的ID</span></span><br><span class="line">mZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后节点的时间</span></span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点ID</span></span><br><span class="line">pZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点发生变化后的version值</span></span><br><span class="line">cversion = -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点数据的version，修改后累加1</span></span><br><span class="line">dataVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 权限</span></span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点个数（ls /）</span></span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p><h2 id="get-stat"><a href="#get-stat" class="headerlink" title="get | stat"></a>get | stat</h2><ul><li><p>stat命令：ls2 = ls + stat</p></li><li><p>get：取出当前节点数据，如果没有数据，与上述内容一至</p></li></ul><h1 id="节点操作命令"><a href="#节点操作命令" class="headerlink" title="节点操作命令"></a>节点操作命令</h1><p>讲述该节内容前，我们先阐述session的基本原理：</p><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都可设置一个超时时间（30分钟不操作session失效）：心跳结束，则session过期</li><li>session过期，临时节点znode会被抛弃</li><li>心跳机制： 客户端向服务端的ping包请求</li></ul><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><ul><li><p>创建默认节点节点（持久化节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc immoc-data </span><br><span class="line">Created /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] get /immoc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点的持久化数据</span></span><br><span class="line">immoc-data</span><br><span class="line">..</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 10</span><br></pre></td></tr></table></figure></li><li><p>创建节点后目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /     </span><br><span class="line">[zookeeper, imooc]</span><br></pre></td></tr></table></figure></li><li><p>创建临时节点: create -e /imooc/tmp immoc-data</p></li><li><p>创建顺序节点: 每个节点后缀都会增加数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s /imooc/sec seq </span><br><span class="line">Created /imooc/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s /imooc/sec seq</span><br><span class="line">Created /imooc/sec0000000002</span><br></pre></td></tr></table></figure></li></ul><h2 id="set-delete"><a href="#set-delete" class="headerlink" title="set | delete"></a>set | delete</h2><ul><li><p>set path data [version]：修改节点如果默认不设置版本号，直接删除。加上版本号可实现乐观锁(只能修改最新的数据)</p></li><li><p>delete path [version]: 直接删除节点, 加上版本号只能删除最新数据</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ls / 查看zk目录</li><li>ls2 / 查看节点信息</li><li>get / 取出当前节点信息</li><li>zookeeper存储了节点的各种状态，如数据的大小、修改时间等</li><li>ephemeralOwner = 0x0属性如果为0x0那么为临时节点，否则为持久节点（后面是一串数据）。临时节点在断开连接后消失（10秒左右延迟 - 心跳机制）</li><li>create path data创建持久化节点</li><li>set path data [version]修改节点</li><li>delete path data [version]删除节点</li><li>使用set和delete时候，建议根据version删除，可达到<em>乐观锁的</em>效果，不会删除到之前旧的数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;通过 ./zkCli.sh打开客户端进行命令行后台操作&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="zookeeper与dubbo" scheme="http://yoursite.com/categories/zookeeper%E4%B8%8Edubbo/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="乐观锁" scheme="http://yoursite.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper基本数据模型</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper基本数据模型/</id>
    <published>2019-04-17T01:29:33.000Z</published>
    <updated>2019-04-17T16:38:15.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper模型介绍"><a href="#zookeeper模型介绍" class="headerlink" title="zookeeper模型介绍"></a>zookeeper模型介绍</h1><ul><li><p>数据为树形结构，可理解为Linux的目录结构 /usr/local/..</p></li><li><p>每一个节点成为znode，它可有子节点，也可以有数据</p></li><li><p>每个节点分为临时节点和永久节点，临时节点在客户端断开连接后消失。永久节点是一个持久化的节点</p></li><li><p>每个zk节点都有各自的版本号，可通过命令显示节点信息</p></li><li><p>每当节点数据发生变化时，那么该节点的版本号就会累加（乐观锁）</p></li><li><p>删除/修改过时的节点，版本号不匹配则会报错</p></li><li><p>每一个zk节点存储的数据不易过大，几k即可</p></li><li><p>节点可设置权限ACL，可通过权限来限制用户访问</p></li></ul><h1 id="数据模型基本操作"><a href="#数据模型基本操作" class="headerlink" title="数据模型基本操作"></a>数据模型基本操作</h1><ul><li>客户端连接 - 查看znode结构 - 关闭客户端连接</li></ul><p><strong>连接客户端</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkCli.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示一推信息...</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里需要回车</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></p><p><strong>zookeeper命令</strong></p><p><img src="http://poporz7f8.bkt.clouddn.com/02.jpg" alt></p><p><strong>查看znode</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zookeeper/quota</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p><h1 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h1><ul><li><p>master节点选举，当主节点挂了，从节点就会接手工作，从而保证集群是高可用的</p></li><li><p>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，例如在一个集群的生产环境下，修改了一个redis的配置那么其他服务都需要进行修改，这样就很麻烦</p></li><li><p>发布订阅模式，类似消息队列MQ, dubbo发布者把数据数据存储到znode节点上，订阅者会读取这个数据</p></li><li><p>提供<em>分布式锁</em>，分布式环境中不同<strong>进程</strong>之间争夺资源，类似于多线程中的锁<br><img src="http://poporz7f8.bkt.clouddn.com/003.jpg" alt></p><blockquote><p>当A处理完B、C、D</p></blockquote></li><li><p>集群管理，集群中保证数据的强一致性</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>zookeeper的结构为树形结构，节点分为临时节点和永久节点。前者会在客户端断开后消失，后者是一个持久化的节点</p></li><li><p>zookeeper可保证集群高可用、提供了分布式锁保证数据一致性、可以统一管理集群中的配置文件进行同步</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper模型介绍&quot;&gt;&lt;a href=&quot;#zookeeper模型介绍&quot; class=&quot;headerlink&quot; title=&quot;zookeeper模型介绍&quot;&gt;&lt;/a&gt;zookeeper模型介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据为树形结构，可理解为Linux
      
    
    </summary>
    
      <category term="zookeeper与dubbo" scheme="http://yoursite.com/categories/zookeeper%E4%B8%8Edubbo/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper概述</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper概述/</id>
    <published>2019-04-17T00:29:33.000Z</published>
    <updated>2019-04-17T16:37:28.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户</p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p><img src="http://poporz7f8.bkt.clouddn.com/01.jpg" alt></p><ul><li>很多台计算机组成一个整体，一个整体一致对外并处理同一个请求</li><li>内部的每台计算机都可相互通信（rest/rpc）</li><li>客户端到服务端的一次请求到响应结束会历经多台计算机</li></ul><h1 id="zookeeper特性"><a href="#zookeeper特性" class="headerlink" title="zookeeper特性"></a>zookeeper特性</h1><ul><li>一致性：数据一致性，将数据按照顺序分批入库</li><li>原子性： 事务要么成功要么失败，不会局部化</li><li>单一视图： 客户端连接集群中的任一zookeeper节点，数据都是一致的</li><li>可靠性： 每次对zookeeper的操作状态都会保存在服务端</li><li>实时性: 客户端可以读取到zookeeper服务端的最新数据</li></ul><h1 id="zookeeper的安装"><a href="#zookeeper的安装" class="headerlink" title="zookeeper的安装"></a>zookeeper的安装</h1><h2 id="JDK依赖"><a href="#JDK依赖" class="headerlink" title="JDK依赖"></a>JDK依赖</h2><ul><li>安装解压好后配置环境变量，java-version查看是否安装成功</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set java</span></span><br><span class="line"><span class="comment"># java安装路径</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure><h2 id="zookeeper配置"><a href="#zookeeper配置" class="headerlink" title="zookeeper配置"></a>zookeeper配置</h2><ul><li><p>下载地址：<a href="https://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/</a></p></li><li><p>安装解压后配置环境变量</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">ZOOKEEPER_HOME=/usr/local/server/zookeeper/zookeeper-3.4.11</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span>    </span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$ZOOKEEPER_HOME/bin:JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心配置文件</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于计算时间的单元, 比如session超时（N * tickTime）</span></span><br><span class="line"><span class="attr">tickTime:</span> </span><br><span class="line"><span class="comment">#用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime的倍数来表示</span></span><br><span class="line"><span class="attr">initLimit:</span> </span><br><span class="line"><span class="comment">#用于集群，master主节点与从节点之间的消息通信，请求和答应的时间（心跳机制）</span></span><br><span class="line"><span class="attr">syncLimit:</span></span><br><span class="line"><span class="comment">#必须要配置的。用来zookeeper存储的数据(手动创建) </span></span><br><span class="line"><span class="attr">dataDir:</span> </span><br><span class="line"><span class="comment">#日志目录，如果不配置会和data目录公用（手动创建）</span></span><br><span class="line"><span class="attr">dataLogDir:</span> </span><br><span class="line"><span class="comment">#连接服务器的端口，默认2181</span></span><br><span class="line"><span class="attr">clientPort:</span></span><br></pre></td></tr></table></figure></p><p><strong>启动</strong></p><ul><li>./zkServer.sh 命令帮助</li><li>./zkServer.sh start 启动<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li></ul><p><strong>查看启动状态</strong></p><ul><li>./zkServer.sh status<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示单机状态</span></span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper用于提供协调服务，作用与分布式，发挥其优势，可为大数据服务</li><li>一次请求历经了多台服务器，这是分布式系统的最简单</li><li>zookeeper协调服务可理解为交通堵塞时交警的作用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群
      
    
    </summary>
    
      <category term="zookeeper与dubbo" scheme="http://yoursite.com/categories/zookeeper%E4%B8%8Edubbo/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存使用与优化</title>
    <link href="http://yoursite.com/2019/04/16/redis%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/16/redis缓存使用与优化/</id>
    <published>2019-04-15T17:21:17.000Z</published>
    <updated>2019-04-16T06:34:15.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h1><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><p>加速读写：CPU L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器读写、Ehcache缓存数据库结果</p></li><li><p>降低后端负载：降低MySQL的负载等</p></li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><p>数据不一致：缓存层和数据层有时间窗口不一致，和<em>更新策略</em>有关。也就是说，需要将数据库中的数据存入redis进行缓存，如果数据库更新了，那么缓存如何更新呢? </p></li><li><p>代码维护成本高： 多了一层缓存逻辑</p></li><li><p>运维成本：例如redis-cluster，或者使用云服务</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>降低后端负载：对高消耗的SQL, 如join结果集 / 分组结果集</p></li><li><p>加速请求响应：优化IO响应时间</p></li><li><p>大量写合并为批量写： 计数器先在redis累加，再批量写入DB</p></li></ul><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><p>当数据库数据更新时，那么缓存将如何进行更新维护呢？<br></p><ol><li><p>先进先出算法剔除：例如<em>maxmemory-policy</em>(最大内存限制)，当超过指定值之后，删除过期的key。不需担心每一个key是如何删除的。适用场景：控制内存</p></li><li><p>超时剔除：设置过期时间<em>expire</em>。适用场景：存储不是很重要的数据</p></li><li><p>主动更新：开发控制生命周期，由自己来控制每一个key的更新周期</p></li></ol><blockquote><p>开发建议： 超时剔除 + 主动更新</p></blockquote><h1 id="缓存颗粒控制"><a href="#缓存颗粒控制" class="headerlink" title="缓存颗粒控制"></a>缓存颗粒控制</h1><p>通常我们都是这样设计一个缓存系统的：先从redis查询数据，如果有直接返回。如果没有则从数据库中查询然后再加入缓存中。<br><br><em>伪代码如下</em>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set userid <span class="string">'select * from user where id=1'</span></span><br><span class="line"></span><br><span class="line">set userid <span class="string">'select column.. from user where id=1'</span></span><br></pre></td></tr></table></figure></p><ul><li>那么到底要缓存select * 还是部分字段的数据？该问题为缓存粒度问题</li></ul><h2 id="缓存粒度控制-三个角度"><a href="#缓存粒度控制-三个角度" class="headerlink" title="缓存粒度控制 - 三个角度"></a>缓存粒度控制 - 三个角度</h2><ul><li>通用性：全部属性更好</li><li>占用空间：部分数据更好</li><li>代码维护：表面上全部属性更好</li></ul><blockquote><p>生产环境通常采用部分属性，缓存需要考虑到性能问题、序列化问题</p></blockquote><h1 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h1><p>通常情况下缓存设计是这样的：第一次访问redis没有数据就去从数据库中查询，然后将数据加入缓存中，当下此访问redis时就直接从缓存中获取了。这是通常的情况下，如果第二个步骤访问数据库没有数据会怎样？如下如图结构：<br><img src="http://poporz7f8.bkt.clouddn.com/redis-chuantou.jpg" alt></p><p>此时就失去了缓存的意义，因为缓存就是用来保存持久层。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li><p>业务代码问题： 本身你编写的接口就拿不到持久层数据或是调用别的接口拿不到持久层数据</p></li><li><p>恶意攻击、爬虫等等: 根据URI一定的规则访问到接口</p></li></ul><h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><ul><li>业务的相应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>缓存空对象</strong><br><br>如果从数据库中查询的值不存在，进行一个判断直接将null就作为’数据’存入缓存中</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-chuantou2.jpg" alt></p><p>但是这种解决方案还是有问题，<em>持久层和缓存层数据”短期”不一致</em>。比如业务上的接口问题调用时可能出现网络原因拿不到结果，此时你将它作为null缓存了。如果恢复了，此时缓存是一个null的状态</p><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(cacheValue) )&#123;</span><br><span class="line">        <span class="comment">// 为空从持久层获取数据</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 加入缓存</span></span><br><span class="line">        jedis.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 防止缓存穿透, 如果数据库值真为空，设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(storageValue) )&#123;</span><br><span class="line">            jedis.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>布隆过滤器拦截</strong><br><br>通过很少的内存对数据的过滤, 例如在一个电话本中判断一个电话是否在电话本中，通常不会将电话本存储到内存中，占用内存可能会很大。布隆过滤器就是解决这种类似的问题，它通过一些算法，将电话本存入过滤器，当要判断电话是否在电话本中时，通过很少的算法来进行解决</p><blockquote><p>布隆过滤器用于检索一个元素是否在一个集合中</p></blockquote><h1 id="缓存无底洞问题"><a href="#缓存无底洞问题" class="headerlink" title="缓存无底洞问题"></a>缓存无底洞问题</h1><ul><li>2010年，Facebook有3000个memcache节点</li><li>发现问题： 加机器性能没有提升反而下降</li></ul><p><strong>问题关键点</strong></p><ul><li>更多的j机器 != 更高的性能</li><li>批量接口需求（mget、mset等）</li><li>数据增长与水平扩展需求</li></ul><h1 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h1><p>当缓存服务承载大量请求，如果缓存服务异常/宕机，流量直接压向后端DB，造成级联故障</p><p><strong>优化方案</strong><br></p><ul><li>保证缓存高可用：个别节点、个别机器、甚至是机房</li><li>依赖隔离组件为后端限流</li><li>提前演练：压力测试</li><li>cache服务高可用：redis-sentinel、redis-cluster、redis-VIP</li></ul><h1 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h1><p>缓存重建过程：我们知道使用缓存首先从缓存中获取,如果获取不到从数据库中获取，如果获取到了将数据写入缓存，该过程为缓存的重建的过程。该过程可能会出现的问题<br><br><img src="http://poporz7f8.bkt.clouddn.com/redis-redian01.jpg" alt></p><p>热点key（访问量大） + 较长的重建时间： 大量的线程作查询数据源和缓存重建的工作。解决方案：</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>第一个获取缓存的线程需要做重建的时候，将重建过程加锁。完成了重建工作再将锁解开。在这期间其他线程的发现重建过程处于等待状态，直到最后一个发现锁解开就可直接获取缓存进行输出<br><img src="http://poporz7f8.bkt.clouddn.com/redis-unlock.jpg" alt></p><blockquote><p>该解决方案没有大量的重建过程，但有等待的问题</p></blockquote><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key;</span><br><span class="line">    <span class="keyword">if</span>(cacheValue == <span class="keyword">null</span>)&#123; <span class="comment">// 重建工作</span></span><br><span class="line">        <span class="comment">// 设置互斥锁key</span></span><br><span class="line">        String mutexKey = <span class="string">"mutexKey:"</span> + key;</span><br><span class="line">        <span class="comment">//setnx命令：key不存在才进行设置</span></span><br><span class="line">        <span class="keyword">if</span>(redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>) )&#123; </span><br><span class="line">            <span class="comment">// 开始重建</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value);</span><br><span class="line">            <span class="comment">// 删除锁        </span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 存在该key，让其他线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 再次尝试获取key</span></span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h2><ul><li>缓存层面： 没有设置过期时间</li><li>功能层面： 为每一个value添加<em>逻辑过期时间</em>，发现过期了，使用单独线程去完成缓存的重建工作</li><li>该方案相比互斥锁没有等待的过程</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>缓存的收益: 加速读写、降低后端存储负载</li><li>缓存成本: 缓存和存储数据不一致性、代码维护成本、运维成本</li><li>缓存更新策略：超时删除 + 主动更新</li><li>缓存穿透问题：使用缓存空对象和布隆过滤器解决，注意他们各自使用场景</li><li>缓存雪崩问题： 缓存层的高可用、客户端降级、提前压力测试</li><li>热点key重建问题： 互斥锁、”永不过期” 来解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存的收益与成本&quot;&gt;&lt;a href=&quot;#缓存的收益与成本&quot; class=&quot;headerlink&quot; title=&quot;缓存的收益与成本&quot;&gt;&lt;/a&gt;缓存的收益与成本&lt;/h1&gt;&lt;h2 id=&quot;收益&quot;&gt;&lt;a href=&quot;#收益&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构与存储引擎</title>
    <link href="http://yoursite.com/2019/04/15/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/15/MySQL存储引擎概述/</id>
    <published>2019-04-15T12:48:06.000Z</published>
    <updated>2019-04-16T06:35:51.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><blockquote><p>本章节来自 <strong>高性能MySQL</strong> 第一章 MySQL架构与历史</p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><ul><li><p>最上层服务是多数基于网络的客户端/服务器都有类似的架构</p></li><li><p>第二层是MySQL核心服务功能，查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等</p></li><li><p>第三层包含存储存储引擎，它负责MySQL中数据的存储和提取，存储引擎API包含几十个底层函数，例如执行<em>开始一个事务</em>等操作。注意：存储引擎并不会提取SQL</p></li></ul><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是mysql的默认<em>事务型引擎</em>, 使用最为广泛的的存储引擎。它的作用是处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>在MySQL5.1及之前的版本，默认使用MyISAM存储引擎。它提供了全文索引、压缩、空间函数等特性，它不支持事务和行级锁。不要默认开启此引擎，应当使用InnoDB。</p><p><br></p><h1 id="MySQL内建的其他存储引擎"><a href="#MySQL内建的其他存储引擎" class="headerlink" title="MySQL内建的其他存储引擎"></a>MySQL内建的其他存储引擎</h1><h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>它只支持insert、select操作，archive引擎会缓存所有的写并利用zlib对插入的行进行压缩，比MyISAM更少的IO</p><h2 id="Blackhole"><a href="#Blackhole" class="headerlink" title="Blackhole"></a>Blackhole</h2><p>它没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。可用于复制数据库进行备份，可在复制架构和日志审核时发挥作用。但是并不推荐</p><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>它可将普通的CSV文件（逗号分隔的文件）作为MySQL的表来处理，但这种表不支持索引。可将excel中的数据存储为CSV文件然后复制到MySQL数据目录。它可作为一种数据交换的机制</p><h2 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h2><p>该引擎是访问其他MySQL服务器的一个代理，默认是禁用的，它有一个后续的版本为FederatedX</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>如果需要快速访问数据，且这些数据不会被修改，它把数据保存在内存, 重启之后表结构还存在但是数据会丢失。使用场景：</p><ul><li>查询或映射表</li><li>缓存周期性聚合数据的结果</li><li>保存数据分析中产生的中间数据</li></ul><blockquote><p>memory支持hash索引，因此查询很快</p></blockquote><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>MyISAM的变种引擎，由多个表合并出来的虚拟表，该引擎已被放弃</p><h2 id="NDB"><a href="#NDB" class="headerlink" title="NDB"></a>NDB</h2><p>当时的MySQL AB公司从索尼爱立信公司收购了NDB数据库，开发了自己的NDB集群存储引擎</p><h1 id="第三方引擎"><a href="#第三方引擎" class="headerlink" title="第三方引擎"></a>第三方引擎</h1><p>MySQL从2007年提供了插件式的存储引擎API，因此由大多数的第三方产品或开源项目</p><h2 id="OLTP类引擎"><a href="#OLTP类引擎" class="headerlink" title="OLTP类引擎"></a>OLTP类引擎</h2><p>InnoDB是该类型的引擎，还有其他比如支持事务和MVCC的其中一个由PBXT</p><h2 id="面向列的存储引擎"><a href="#面向列的存储引擎" class="headerlink" title="面向列的存储引擎"></a>面向列的存储引擎</h2><p>MySQL默认是面向行的，没一行的数据是一起存储的，查询也是以行为单位处理。而在大数据量处理时，面向队列方式可能效率更高<br><br><strong>infobright</strong> 是一种面向列的存储引擎，在非常大的数据量（数十TB）时，该引擎工作良好。<br>它为数据分析和数据仓库而设计。该引擎不支持索引，不过在这么大的数据量，索引也很难发挥作用</p><h2 id="社区存储引擎"><a href="#社区存储引擎" class="headerlink" title="社区存储引擎"></a>社区存储引擎</h2><p>社区所提供的存储引擎很多，这里只介绍常见的</p><ul><li>Groonga： 全文索引引擎，号称可以提供准确高效的全文索引</li><li>OQGraph: 支持图操作，比如最短路径问题，用SQL很难实现该问题</li><li>Q4M：该引擎在MySQL内部实现了队列操作，用SQL很难实现该问题</li><li>SphinxSE: 该引擎为Sphinx全文索引搜索服务器提供了SQL接口</li><li>Spider: 该引擎可将数据切分为不同的分区，高效透明的实现了分片，并可分片执行并行查询</li><li>VPForMySQL: 该引擎支持垂直分区，指的是将表分成不同列的组合，进行单独存储。但是对于查询来说，看到的还是一张表</li></ul><h1 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h1><p>多数情况下，innoDB都是正确的选择, Oracle在MySQL5.5将innoDB作为默认引擎。如何选择归纳一句话 <strong>除非要用到innoDB不具备的特性，并且没有其他办法可替代</strong> ,</p><ul><li>如果需要事务，InnoDB是目前最稳定的选择</li><li>如果不需要要事务，并主要是SELECT和INSERT那么使用MyISAM</li></ul><h1 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h1><p>每种方法都有优缺点，以下只讲述三种方法：</p><ul><li>alter table<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure></li></ul><p>上诉语法可适用任何存储引擎，但有一个问题：需要执行很长时间，MySQL会按行将数据从原表复制一张新的表中，在复制期间可能会消耗系统所有的IO资源，同时原来的表会加上读锁</p><ul><li><p>导出于导入</p></li><li><p>创建于查询（create、select）</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>MySQL拥有分层架构，上层是服务器层的服务、和查询执行引擎。下层存储引擎</p></li><li><p>mysql的引擎和区别：InnoDB、MyISAM, 5.1之前的版本采用MyIsAM。InnoDB支持事务而MyISAM不支持事务，如果需要大量的插入数据操作使用MyISAM，其他情况优先使用InnoDB</p></li><li><p>如果要处理大数据量使用第三方引擎 infobright</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/stron
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis集群总结</title>
    <link href="http://yoursite.com/2019/04/15/redis%E9%9B%86%E7%BE%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/redis集群总结/</id>
    <published>2019-04-15T08:47:57.000Z</published>
    <updated>2019-04-15T09:54:26.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群总结"><a href="#集群总结" class="headerlink" title="集群总结"></a>集群总结</h1><p>redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写服务<br></p><ul><li><p>那么从节点的数据怎么和主节点的数据达到一致性呢？首先从节点拿到数据的原理是通过<em>RDB传输(主从复制原理)</em> 的方式来获取数据，而主从数据的一致性通过<em>偏移量</em>来判断数据的一致性。</p></li><li><p>数据一致性问题解决了，而故障转移redis是如何做到的？ 官方的两种方案： <strong>redis-sentinel</strong> 和 <strong>redis-cluster</strong>，redis-sentinel（哨兵）是一个独立的程序，它的作用是监控多个主从节点，如果发现主节点挂了会进行内部选举的模式让一个从节点成为主节点。而redis-cluster专门用于搭建集群模式的情况下使用，因此它本身就具备了高可用的特性。</p></li></ul><h1 id="rediscluster总结"><a href="#rediscluster总结" class="headerlink" title="rediscluster总结"></a>rediscluster总结</h1><ol><li><p>rediscluster数据分区规则使用虚拟槽（16384），每个节点负责一部分槽和相关数据，实现数据的和请求的均衡负载</p></li><li><p>搭建集群步骤：准备节点、节点握手、分配槽、复制。redis.trib.rb工具用于快速搭建集群</p></li><li><p>集群伸缩实现是通过节点之间移动槽和相关数据的实现</p></li></ol><ul><li>加入：把槽从原来的节点迁移到新节点</li><li>退出：如果要退出集群的节点中槽有数据，那么将它迁移到其他节点，在通过cluster forget命令广播集群让所有节点忘记</li></ul><ol start="4"><li>集群故障转移过程为故障发现和节点恢复。节点的下线分为主观下线和客观下线，当半数主节点认为你是故障了标记为客观下线。从节点负责故障恢复的过程，保证集群可用性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集群总结&quot;&gt;&lt;a href=&quot;#集群总结&quot; class=&quot;headerlink&quot; title=&quot;集群总结&quot;&gt;&lt;/a&gt;集群总结&lt;/h1&gt;&lt;p&gt;redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>rediscluster常见运维问题</title>
    <link href="http://yoursite.com/2019/04/15/rediscluster%E5%B8%B8%E8%A7%81%E8%BF%90%E7%BB%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/15/rediscluster常见运维问题/</id>
    <published>2019-04-15T07:54:03.000Z</published>
    <updated>2019-04-15T09:15:22.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助</p><h1 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h1><p>也就是我们在rediscluster篇章中配置的 <em>cluster-require-full-coverage </em> 默认true<br><br>它表示是否需要集群中的所有节点都是一个在线的状态，所有的0-16384槽都在一个服务的状态，才认为整个集群是完整的，才会对外提供服务<br></p><ul><li><p>但是对于大多数的业务都无法容忍，如果我们有1000主从节点，当其中一节点进行故障转移的期间（clusterdown the cluster is down）那么此时整个集群就不可用了</p></li><li><p>在实际生产过程中设置为 <em>no</em></p></li><li><p>为何默认为yes？ 集群中16384个槽全部不可用，这也设计就是为了保证集群完整性</p></li></ul><h1 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h1><p>我们知道集群节点之间使用信息的交换(gossip)，所以一定有带宽的开销。官方建议：最多1000个节点当节点规模较大时候，会有不容忽视的带宽消耗</p><ul><li><p>消息发送的频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</p></li><li><p>消息数据量：消息会槽信息，槽数组(2kb)，集群的1/10状态数据(10个节点1kb)</p></li><li><p>集群规模越高带宽越高</p></li><li><p>优化： cluster-node-timeout带宽和故障转移的速度的均衡</p></li></ul><h1 id="发布-订阅广播"><a href="#发布-订阅广播" class="headerlink" title="发布/订阅广播"></a>发布/订阅广播</h1><p>类似于mq的生产消息于订阅消息。当某个节点要通知集群中其他节点的时候，例如故障恢复。其他节点就会收到该消息，这样会产生一个问题，节点的带宽开销会很大。</p><ul><li><p>publish在集群每个节点广播，会加重带宽</p></li><li><p>解决: 如果只需要做到高可用，单独使用redissentinel</p></li></ul><h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><p>如果将原来节点的数据分布到多个节点上，可能会产生数据的倾斜，有如下原因</p><ul><li><p>节点和槽分配不均匀</p></li><li><p>不同槽对应键值数量差距大</p></li><li><p>包含bigkey</p></li><li><p>内存相关配置不一致</p></li></ul><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><ul><li><p>只读连接：集群模式的从节点不接受任何读写请求，会跳转到数据对应槽的主节点上，如果需要读（每次客户端执行readonly）</p></li><li><p>读写分离跟为复杂不建议在集群模式下实现，需要考虑复制延迟、读取过期数据、从节点故障。如果真要实现需要维护slave（思路类似redis-sentinel）</p></li></ul><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><p>如果我们需要将原来的单机节点迁移到rediscluster，这种模式如何实现？</p><ul><li><p>redis-trib.rb import可将单节点数据迁移到集群。不支持在线迁移，b不支持断点续传，单线程迁移</p></li><li><p>在线迁移：唯品会&gt;redis-migrate-tool、豌豆荚&gt;redis-port</p></li></ul><h1 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h1><ul><li><p>集群批量操作有限：如mget、mset必须在一个槽</p></li><li><p>集群事务和lua无法跨节点使用</p></li><li><p>集群模式只有一个db0，没有16个数据库</p></li><li><p>集群模式复制只支持一层，不支持树形复制结构</p></li></ul><p>rediscluster满足容量和新能的扩展性，但很多业务达不到一定的QPS，很多场景下redis-sentinel已经足够好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助&lt;/p&gt;
&lt;h1 id=&quot;集群
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>rediscluster高可用</title>
    <link href="http://yoursite.com/2019/04/15/rediscluster%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/15/rediscluster高可用/</id>
    <published>2019-04-15T07:49:51.000Z</published>
    <updated>2019-04-15T08:59:23.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><p>rediscluster不需要到sentinel即可完成故障转移，实现高可用的集群特性。它与sentinel很相似，分为故障发现和故障恢复的过程</p><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><p>依赖节点之间的通信使用ping/pong消息实现故障的发现，不需要sentinel</p><h2 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h2><p>定义：某个节点认为另一个节点不可用，”偏见”，代表一个节点对另一个节点的认知<br><br>流程：<br><img src="http://poporz7f8.bkt.clouddn.com/zhuguanxiaxian.jpg" alt></p><blockquote><p>当某个节点断开连接之后，超过node-timeout超时时间，那么标记为pfaill</p></blockquote><h2 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h2><p>定义： 持有半数以上的槽的节点都标记某个节点时，就认为那个节点不可用<br><br>流程：<br><img src="http://poporz7f8.bkt.clouddn.com/keguanxiaxianmoshi.jpg" alt></p><blockquote><p>记录每个节点的状态，如果状态不可用，会将信息添加到故障列表中，列表用于维护故障列表，后再尝试客观下线。之后通知集群内所有节点标记故障节点为客观下线，通知故障节点的从节点准备执行转移</p></blockquote><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>客观下线通知从节点，从节点接收到消息开始准备进行故障的恢复，从而保证集群的高可用，实现流程有：</p><ul><li>资格检查<br>检查哪些从节点可能成为主节点的资格条件：</li></ul><ol><li>每个从节点检查与故障主节点的断线时间</li><li>超过cluster-node-timeout(15) * cluster-slave-validity-factory(10)取消资格</li></ol><ul><li><p>选举<br>具备更大的偏移量（更接近主节点）成为主节点的可能性更大，选举的时间更小且投票个数更高，收集3张选票大于N/2+1，那么执行替换主节点工作</p></li><li><p>替换主节点</p></li></ul><ol><li>当前节点取消从节点复制，变为主节点（slaveof one one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己</li><li>集群广播消息，表明已经替换了故障从节点</li></ol><h1 id="故障转移实验"><a href="#故障转移实验" class="headerlink" title="故障转移实验"></a>故障转移实验</h1><p><strong>环境</strong>: springboot + 3主3从节点<br><br><strong>目的</strong>: 不断的从节点中set值, 中途将其中一个master kill观察情况</p><h2 id="maven依赖和配置"><a href="#maven依赖和配置" class="headerlink" title="maven依赖和配置"></a>maven依赖和配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>TODO: spring-boot-starter-data-redis内部使用的不是jedis实现的连接池，经过之前的测试，如果使用lettuce-core这个连接池没有达到故障转移的效果, 所以这次实验使用jedis内部的连接池完成</p><p><strong>application.yml</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    cluster:</span></span><br><span class="line"><span class="attr">      nodes:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7001</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7002</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7003</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7004</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7005</span></span><br><span class="line"><span class="bullet">        -</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.136</span><span class="string">:7006</span></span><br></pre></td></tr></table></figure></p><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootRedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(SpringbootRedisApplicationTests.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 不断的set值</span></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</span><br><span class="line">                String key = <span class="string">"k-"</span> + index;</span><br><span class="line">                String value = <span class="string">"v-"</span> + index;</span><br><span class="line">                redisTemplate.boundValueOps(key).set(value);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出日志</span></span><br><span class="line">                logger.info(<span class="string">"&#123;&#125; value is &#123;&#125;"</span>, key, redisTemplate.boundValueOps(key).get());              </span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>此时节点状态：<br><img src="http://poporz7f8.bkt.clouddn.com/clustertest01.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/clustertest02.jpg" alt></p></li><li><p>开始不断的set值，在进行kill主节点，观察日志输出：<br><img src="http://poporz7f8.bkt.clouddn.com/clustertest03.jpg" alt></p></li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/clustertest04.jpg" alt></p><p><img src="http://poporz7f8.bkt.clouddn.com/clustertest05.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;故障转移&quot;&gt;&lt;a href=&quot;#故障转移&quot; class=&quot;headerlink&quot; title=&quot;故障转移&quot;&gt;&lt;/a&gt;故障转移&lt;/h1&gt;&lt;p&gt;rediscluster不需要到sentinel即可完成故障转移，实现高可用的集群特性。它与sentinel很相似，分为故障
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>springboot原理</title>
    <link href="http://yoursite.com/2019/04/14/springboot%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/14/springboot原理/</id>
    <published>2019-04-13T17:43:31.000Z</published>
    <updated>2019-04-15T16:19:20.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Boot是Spring旗下众多的子项目之一。其理念是约定优于配置，它通过实现了自动配置（大多数用户平时习惯设置的配置作为默认配置）的功能来为用户快速构建出标准化的应用。内置了嵌入式的Tomcat、Jetty等Servlet容器，应用可以不用打包成War格式，而是可以直接以Jar格式运行</p><blockquote><p>特点：spring boot不是对spring的增强，而是提供了一种<strong>快速</strong>使用spring的方式</p></blockquote><blockquote><p>核心：起步依赖、自动配置</p></blockquote><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>使用idea快速搭建一个springboot项目：<br></p><ul><li><p>创建springboot项目<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-01.jpg" alt></p></li><li><p>指定包名和项目名<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-02.jpg" alt></p></li><li><p>选择需要的依赖文件<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-03.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-04.jpg" alt></p></li><li><p>项目结构如下<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-05.jpg" alt></p></li><li><p>pom依赖文件如下<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-06.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-07.jpg" alt></p></li><li><p>编写一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/info.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"这是我的第一个spring boot程序"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动spring boot引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问8080<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-08.jpg" alt><br><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-09.jpg" alt></p></li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>起步依赖是spring boot的核心功能之一，起步依赖本质是maven定义了对其他库的传递依赖，简单的说，起步依赖就是将具备某种功能的坐标打包在一起，并提供一些默认的功能<br></p><ul><li>springboot的起步依赖核心坐标<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>它提供了大量的Maven默认依赖。使用它之后，常用的包依赖可以省去version标签</p><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>spring boot默认配置了一些用户常用的配置，因此不需要我们先编写xml（如web.xml）在编写代码进行开发，那么它是如何做到的呢?</p><p>我们开发一个spring boot都会有如下启动类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SpringBootApplication注解结构"><a href="#SpringBootApplication注解结构" class="headerlink" title="SpringBootApplication注解结构"></a>SpringBootApplication注解结构</h3><p><img src="http://poporz7f8.bkt.clouddn.com/springboot-10.jpg" alt></p><ul><li><p>@SpringBootConfiguration: 继承了Configuration（可进入查看），作用是取代xml的方式(spring的纯注解开发)</p></li><li><p>@ComponentScan：组件扫描，表示其他包可使用spring组件</p></li></ul><h3 id="EnableAutoConfiguration注解"><a href="#EnableAutoConfiguration注解" class="headerlink" title="EnableAutoConfiguration注解:"></a>EnableAutoConfiguration注解:</h3><p>开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助，将所有符合自动配置条件的bean定义加载到IOC容器中。<br>EnableAutoConfiguration有如下信息<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-11.jpg" alt></p><h3 id="AutoConfigurationImportSelector类"><a href="#AutoConfigurationImportSelector类" class="headerlink" title="AutoConfigurationImportSelector类"></a>AutoConfigurationImportSelector类</h3><p>该类用于管理加载默认的配置信息，例如我们使用springmvc必须会经过<br>dispatchservlet，那么spring boot会将这些配置存储到如下文件中：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-12.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-13.jpg" alt><br>可发现这些类都AutoConfiguraion作为结尾, spring boot会将这些存有自动配置的类获取并加载, 我们分析其源代码：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-14.jpg" alt><br>可发现@bean，作用是取代xml的bean标签(spring的纯注解开发)</p><h3 id="EnableConfigurationProperties注解"><a href="#EnableConfigurationProperties注解" class="headerlink" title="EnableConfigurationProperties注解"></a>EnableConfigurationProperties注解</h3><p>该注解的作用是加载ServerProperties服务器相关配置属性类，例如上述搭建的程序，访问tomcat默认端口为8080，这些默认配置存储在如下文件中：<br><img src="http://poporz7f8.bkt.clouddn.com/springboot-15.jpg" alt><br><img src="http://poporz7f8.bkt.clouddn.com/springboot-16.jpg" alt></p><blockquote><p>当需要覆盖默认配置，在application.xml中指定即可</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>springboot的启动类会加载SpringBootApplication注解，该注解包含了@configuration（该类为配置类，取代xml）、@import（加入其他配置类）、自动装配的核心注解EnableAutoConfiguration，它用于完成记录默认的配置信息（web.xml）、服务器的配置信息(tomcat)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Spring Boot是Spring旗下众多的子项目之一。其理念是约定优于配置，它通过实现了自动配置（大多数用户平时习惯设置的配置作为默认配
      
    
    </summary>
    
      <category term="springboot" scheme="http://yoursite.com/categories/springboot/"/>
    
    
      <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>redis集群伸缩</title>
    <link href="http://yoursite.com/2019/04/12/redis%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9/"/>
    <id>http://yoursite.com/2019/04/12/redis集群伸缩/</id>
    <published>2019-04-12T07:53:48.000Z</published>
    <updated>2019-04-15T08:59:30.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>上一篇章中，我们分析了节点取余和一致性哈希产生数据迁移的问题，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的，每个节点与槽的分配都具备权力</p><h1 id="集群伸缩原理"><a href="#集群伸缩原理" class="headerlink" title="集群伸缩原理"></a>集群伸缩原理</h1><p>它的原理其实就是rediscluster的基本架构（在rediscluster文章所讲述）：</p><ul><li>节点: 每个节点负责读写</li><li>meet: 完成节点之间通信工作 A meet C; A meet B; B &gt; C</li><li>指派槽: 只有给节点指派了槽才可以进行读写</li><li>复制: 为了达到高可用，有主从复制概念</li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-shensuo.jpg" alt></p><blockquote><p>集群伸缩 = 槽和数据在节点之间的移动</p></blockquote><h1 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h1><p>首先加入集群的作用有：实现扩容、作为从节点负责故障转移，实现扩容的步骤：</p><h2 id="准备新的节点"><a href="#准备新的节点" class="headerlink" title="准备新的节点"></a>准备新的节点</h2><ul><li>集群模式</li><li>配置和其他节点统一</li><li>启动后是孤儿节点</li></ul><h2 id="加入集群（meet）"><a href="#加入集群（meet）" class="headerlink" title="加入集群（meet）"></a>加入集群（meet）</h2><p>将两个孤儿节点加入到集群中，(可通过cluster-meet完成，不推荐)，推荐使用redis-trib.rb加入集群，它会检测你加入的节点是否为孤儿节点，是才可进行加入</p><h2 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h2><blockquote><p>把其他节点负责的槽均匀的迁移到新节点，让它工作起来</p></blockquote><ul><li>槽迁移规划<br><br>  我们需要将槽进行均衡的分配<br><img src="http://poporz7f8.bkt.clouddn.com/redis-qianyicaojihua.jpg" alt></li></ul><ul><li>迁移数据<br><br><img src="http://poporz7f8.bkt.clouddn.com/redis-caoqianyiliuche.jpg" alt></li></ul><ol><li>让目标节点准备导入槽的数据: cluster setslot {slot} importing {sourceNodeId}</li><li>对源节迁移出槽数据：cluster setslot {slot} migrating {targetNodeId}</li><li>对源节点循环遍历槽，获取count个槽的key：cluster getkeysinslot {slot} {count}</li><li>在源节点执行：migrate {targetIp} {targetPort} key 0 {timeout}</li><li>重复执行步骤3-4直到槽下所有的键数据迁移到目标节点</li><li>通知槽分配个目标节点：cluster setslot {slot} node {targetNodeId}</li></ol><h1 id="加入集群实战"><a href="#加入集群实战" class="headerlink" title="加入集群实战"></a>加入集群实战</h1><blockquote><p>此时的集群状态<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiedianxinxi.jpg" alt></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动7006和7007(拷贝文件和修改配置文件不在阐述)</span></span><br><span class="line">root      52263      1  0 05:10 ?        00:00:00 redis-server *:7006 [cluster]</span><br><span class="line">root      52272      1  1 05:10 ?        00:00:00 redis-server *:7007 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时为孤立状态</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7006</span><br><span class="line">127.0.0.1:7006&gt; cluster nodes</span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 :7006 myself,master - 0 0 0 connected</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入集群</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 192.168.211.136 7006</span><br><span class="line">127.0.0.1:7000&gt; cluster meet 192.168.211.136 7007</span><br><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时已经加入了集群</span></span><br><span class="line">0936d215f3adc8aad93f935ba5ea72c7d6cc7bd0 192.168.211.136:7007 master - 0 1555017424796 7 connected</span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 192.168.211.136:7006 master - 0 1555017423368 0 connected</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 7007（从）复制 7006（主）配置</span></span><br><span class="line">[root@zhongjinlang redis]# redis-cli -p 7007 cluster replicate d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为7006主节点分配槽，在/usr/<span class="built_in">local</span>/bin</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard 192.168.211.136:7000</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示输入</span></span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 4096</span><br><span class="line">What is the receiving node ID? d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type 'all' to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type 'done' once you entered all the source nodes IDs.</span><br><span class="line">Source node #1:all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看槽信息</span></span><br><span class="line">[root@zhongjinlang bin]# redis-cli -p 7006 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可发现槽有三份数据</span></span><br><span class="line">d65a5d7b0dcc09542761ac746ab4058fd002a5a4 192.168.211.136:7006 myself,master - 0 0 8 connected 0-1364 5461-6826 10923-12287</span><br></pre></td></tr></table></figure><h1 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-shousuojiqun.jpg" alt><br>收缩集群就是对一个节点进行下线，实现步骤如下：</p><h2 id="下线迁移槽"><a href="#下线迁移槽" class="headerlink" title="下线迁移槽"></a>下线迁移槽</h2><p>我们将下线7006和7007，并将他们的槽均匀的给其他节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看集群</span></span><br><span class="line">redis-cli -p 7000 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将7006节点的槽（有三段）迁移给主节点7000</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to 5fe9ca13ded00d87f3271380f9e0c7278ec8c483 --slots 1366 192.168.211.136:7006</span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移给7001</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to d0941ed132c5a495545e1e30808cefd243942309 --slots 1365 192.168.211.136:7006</span><br><span class="line"><span class="meta">#</span><span class="bash"> 迁移给7002</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib reshard --from d65a5d7b0dcc09542761ac746ab4058fd002a5a4 --to 3f3b1a02189aa7b27d5ebc2038a07441933b7327 --slots 1365 192.168.211.136:7006</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先下线7006的从节点7000</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib del-node 192.168.211.136:7000 0936d215f3adc8aad93f935ba5ea72c7d6cc7bd0</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; SHUTDOWN the node.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下线7006</span></span><br><span class="line">[root@zhongjinlang bin]# redis-trib del-node 192.168.211.136:7000 d65a5d7b0dcc09542761ac746ab4058fd002a5a4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时集群状态</span></span><br><span class="line">[root@zhongjinlang bin]# redis-cli -p 7000 cluster nodes</span><br><span class="line">bf5e78c9bc9728a2af1ac4077a539207146963a9 192.168.211.136:7004 slave d0941ed132c5a495545e1e30808cefd243942309 0 1555021435868 10 connected</span><br><span class="line">3a959f75d04e953b71c80f74f4d5c63b9fd319fd 192.168.211.136:7003 slave 5fe9ca13ded00d87f3271380f9e0c7278ec8c483 0 1555021438977 9 connected</span><br><span class="line">3f3b1a02189aa7b27d5ebc2038a07441933b7327 192.168.211.136:7002 master - 0 1555021437945 11 connected 10924-16383</span><br><span class="line">5fe9ca13ded00d87f3271380f9e0c7278ec8c483 192.168.211.136:7000 myself,master - 0 0 9 connected 0-5461</span><br><span class="line">d0941ed132c5a495545e1e30808cefd243942309 192.168.211.136:7001 master - 0 1555021440005 10 connected 5462-10923</span><br><span class="line">a9b8f471b99a598cf295f3c15dcb12325302d1bd 192.168.211.136:7005 slave 3f3b1a02189aa7b27d5ebc2038a07441933b7327 0 1555021434839 11 connected</span><br></pre></td></tr></table></figure><h1 id="rediscluster客户端"><a href="#rediscluster客户端" class="headerlink" title="rediscluster客户端"></a>rediscluster客户端</h1><p>当我们对一个rediscluster执行set或get时，rediscluster的计算规则是怎样的?</p><h2 id="move重定向"><a href="#move重定向" class="headerlink" title="move重定向"></a>move重定向</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-move-send.jpg" alt></p><p>当客户端拿到moved异常后，需要对目标执行命令，注意此时客户端并不会自动找到目标节点进行重定向发送(如果使用redis-cli)。而redis-cli-c内部完成了重定向</p><ul><li>槽命中和不命中情况<br><br>计算某个key所对应的槽位置的命令: cluster keyslot key<blockquote><p>如果set值，并在槽的范围内，返回OK</p></blockquote></li></ul><blockquote><p>如果不在槽返回为返回moved异常 + 槽位置 + 节点位置。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用redis-cli设置值</span></span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 因为php不在7000负责的槽范围内</span></span><br><span class="line">127.0.0.1:7000&gt; set php one</span><br><span class="line">(error) MOVED 9244 192.168.211.136:7001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用redis-cli-c集群模式连接</span></span><br><span class="line">127.0.0.1:7000&gt; set php best</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [9244] located at 192.168.211.136:7001</span></span><br><span class="line">OK</span><br><span class="line">192.168.211.136:7001&gt; get php</span><br><span class="line">"best"</span><br></pre></td></tr></table></figure><h2 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h2><p>当进行集群缩容和扩容时，由于槽处于迁移的过程。例如：一个slot存在三个key，分别为hello1、hello2、hello3，假设此时槽正在处于迁移状态，hello1已经迁移到了目标节点，此时如果在源节点获取hello1，则会报出ask重定向错误</p><h2 id="move异常和ask异常"><a href="#move异常和ask异常" class="headerlink" title="move异常和ask异常"></a>move异常和ask异常</h2><ul><li>两者都是客户端重定向</li><li>moved: 槽已经确定迁移</li><li>ask： 槽还在迁移的过程中</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;上一篇章中，我们分析了节点取余和一致性哈希产生数据迁移的问题，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redisCluster</title>
    <link href="http://yoursite.com/2019/04/11/redisCluster/"/>
    <id>http://yoursite.com/2019/04/11/redisCluster/</id>
    <published>2019-04-11T13:37:51.000Z</published>
    <updated>2019-04-14T13:18:38.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sentinel问题引入"><a href="#sentinel问题引入" class="headerlink" title="sentinel问题引入"></a>sentinel问题引入</h1><p>上一篇章中，我们讲述了redis sentinel实现高可用。我们发现使用哨兵，每个slave都是全量存储数据，每个redis存储的内容都是完整的数据，浪费内存且有木桶效应。我们希望最大化的利用内存，采用集群，分布式存储。即每台redis都存储不同的内容。redisCluster是redis3.0推出的功能，有效的解决了redis分布式方面的需求，当遇到单机内存、并发、流量等瓶颈时，可采用cluster架构达到均衡负载的目的。</p><h2 id="sentinel和cluster"><a href="#sentinel和cluster" class="headerlink" title="sentinel和cluster"></a>sentinel和cluster</h2><p>sentinel与cluster是两个独立的功能，从特性来看sentinel可视为集群的子集，当不需要数据分片或已在客户端分片的场景下，sentinel足够使用了。如果需要进行水平扩容，那么cluster是一个很好的选择</p><h1 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h1><p>集群首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集<br><img src="http://poporz7f8.bkt.clouddn.com/redis-partition.jpg" alt></p><h2 id="顺序分区-哈希分区"><a href="#顺序分区-哈希分区" class="headerlink" title="顺序分区 | 哈希分区"></a>顺序分区 | 哈希分区</h2><ul><li><p>顺序分区保证每个节点的数据均衡<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sxufenbu.jpg" alt></p></li><li><p>哈希分区 对每一个数字进行哈希函数，按照节点取余(实现之一)<br><img src="http://poporz7f8.bkt.clouddn.com/redis-hashfenbu.jpg" alt></p></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-fenquduibi.jpg" alt></p><h1 id="哈希分区探究"><a href="#哈希分区探究" class="headerlink" title="哈希分区探究"></a>哈希分区探究</h1><p>redis-cluster采用哈希分区的方式进行数据分布，为此我们将进一步分析</p><h2 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h2><p>对每一个key对3（节点个数）取余，如果余数为0则分布到第一个节点，余数为2则分布到第二个节点，余数为3则分布到第三个节点<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiedianquyu.jpg" alt></p><ul><li>客户端分片: 哈希 + 取余</li><li>节点伸缩： 节点变化，数据迁移量巨大</li></ul><h2 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h2><p>解决了节点取余的缺点<br>token表示一个数据范围，为每一个节点分配一个token，每一个节点负责一部分token数据。当对key进行hash计算后按照顺时针的规则寻找离它最近的节点</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-yizhixhash.jpg" alt></p><ul><li>客户端分片: 哈希 + 取余(优化取余)</li><li>节点伸缩： 只影响临近节点，但还是有数据迁移</li></ul><h2 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h2><p>Redis Cluster中有一个16384长度的槽的概念, 每个槽映射一个数据子集, 按照一定的hash计算对16383取余, 如果它落在某个槽的范围内，那么就证明这个槽必须所管理的数据，它是由服务端管理接节点槽之间的关系<br><img src="http://poporz7f8.bkt.clouddn.com/redis-xunicao.jpg" alt></p><p>节点取余分区和一致性哈希分区当节点伸缩时，都会进行数据的迁移，而rediscluster并不会有这种情况，因为每个节点负责槽的范围都是固定的，每个节点与槽的分配都具备权力</p><h1 id="redisCluster架构"><a href="#redisCluster架构" class="headerlink" title="redisCluster架构"></a>redisCluster架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-jiagou.jpg" alt></p><p>服务端有多个节点，<strong>每个节点都负责读写，节点之间是彼此通信的</strong>。如果节点A覆盖0－5460、节点B覆盖5461－10922、节点C覆盖10923－16383。 如果存入一个值，按照redis cluster哈希槽的算法： CRC16(‘key’)384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取’key’这个key时，也会这样的算法，然后内部跳转到B节点上获取数据</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><ul><li><p>节点: 每个节点负责读写</p></li><li><p>meet: 完成节点之间通信工作 A meet C; A meet B; B &gt; C</p></li><li><p>指派槽: 只有给节点指派了槽才可以进行读写</p></li><li><p>复制: 为了达到高可用，有主从复制概念</p></li></ul><blockquote><p>rediscluster特性：复制、高可用、分片</p></blockquote><h1 id="原生命令安装"><a href="#原生命令安装" class="headerlink" title="原生命令安装"></a>原生命令安装</h1><blockquote><p><strong>环境</strong></p><ul><li>3主3从</li></ul></blockquote><pre><code>&gt; 192.168.211.134:7000(主)&gt; 192.168.211.134:7001(主)&gt; 192.168.211.134:7002(主)&gt; 192.168.211.134:7003(从)&gt; 192.168.211.134:7004(从)&gt; 192.168.211.134:7005(从)</code></pre><h2 id="redis-7000-70005-conf"><a href="#redis-7000-70005-conf" class="headerlink" title="redis-[7000-70005].conf"></a>redis-[7000-70005].conf</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">dir ./</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dbfilename "dump-7000.rdb"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启cluster</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> cluster配置文件</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有一个master宕机，没有故障恢复，整个集群不可用（默认<span class="literal">true</span>）</span></span><br><span class="line">cluster-require-full-coverage no</span><br></pre></td></tr></table></figure><blockquote><p>其他配置文件只需修改端口即可</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-server redis-7000.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7001.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7002.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7003.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7004.conf</span><br><span class="line">[root@localhost cluster]# redis-server redis-7005.conf</span><br><span class="line">[root@localhost cluster]# ps -ef | grep redis</span><br><span class="line">root      57254      1  0 01:44 ?        00:00:00 redis-server *:7000 [cluster]</span><br><span class="line">root      57258      1  0 01:44 ?        00:00:00 redis-server *:7001 [cluster]</span><br><span class="line">root      57262      1  0 01:44 ?        00:00:00 redis-server *:7002 [cluster]</span><br><span class="line">root      57266      1  0 01:44 ?        00:00:00 redis-server *:7003 [cluster]</span><br><span class="line">root      57270      1  0 01:44 ?        00:00:00 redis-server *:7004 [cluster]</span><br><span class="line">root      57274      1  0 01:44 ?        00:00:00 redis-server *:7005 [cluster]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试连接</span></span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">(error) CLUSTERDOWN The cluster is down</span><br></pre></td></tr></table></figure><blockquote><p>我们可发现当set值时，错误表示当前集群是一个下线状态，因为在集群模式下，只有成功分配了槽且16383都进行了完整的分配，才可进行对外提供服务</p></blockquote><h2 id="meet"><a href="#meet" class="headerlink" title="meet"></a>meet</h2><blockquote><p>port meet port<br>完成节点之间的通信</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7001</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7002</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7003</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7004</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster meet 192.168.211.134 7005</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster nodes</span><br><span class="line">9c736c0733323151ee5aeaa8444cf177ab9b312b 192.168.211.134:7005 master - 0 1554832945389 5 connected</span><br><span class="line">97ba85211fa2d68ebff5ae4848eb4a52a899be5a 192.168.211.134:7003 master - 0 1554832943331 4 connected</span><br><span class="line">0ed9079a0d32b7e926a96d6a03d431c1228deffb 192.168.211.134:7000 myself,master - 0 0 1 connected</span><br><span class="line">89d495be82b618256b5c79a56f6894658db4cfa8 192.168.211.134:7004 master - 0 1554832942315 3 connected</span><br><span class="line">b4c274d2501d4d105c8b7acf7787a66287a7406a 192.168.211.134:7001 master - 0 1554832941298 0 connected</span><br><span class="line">8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 192.168.211.134:7002 master - 0 1554832944358 2 connected</span><br></pre></td></tr></table></figure><blockquote><p>此时6个节点已经达成相互通信!</p></blockquote><h2 id="分配槽点"><a href="#分配槽点" class="headerlink" title="分配槽点"></a>分配槽点</h2><p>redis总共有16384个槽点，并且只有主节点需要分配槽点，这里我们使用的是三主三从，因此将槽点均分为三等分:0–5460，5461–10922，10923–16383</p><ul><li><p>首先我们编写一个sh脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start=$1</span><br><span class="line">end=$2</span><br><span class="line">port=$3</span><br><span class="line"></span><br><span class="line">for slot in `seq $&#123;start&#125; $&#123;end&#125;`</span><br><span class="line">do</span><br><span class="line">        echo "slot:$&#123;slot&#125;"</span><br><span class="line">        redis-cli -h 192.168.211.134 -p $&#123;port&#125; cluster addslots $&#123;slot&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>分别为7000、7001、7002三个从节点分配槽节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh add_slots.sh 0 5460 7000</span><br><span class="line">sh add_slots.sh 5461 10922 7001</span><br><span class="line">sh add_slots.sh 10923 16383 7002</span><br></pre></td></tr></table></figure></li><li><p>查看槽信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-16384.jpg" alt></p></li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-cluster-slots.jpg" alt></p><ul><li>设置值<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set hello world</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ul><h2 id="主从关系分配"><a href="#主从关系分配" class="headerlink" title="主从关系分配"></a>主从关系分配</h2><blockquote><p>cluster replicate node-id<br>完成 7000-&gt;7003、7001-&gt;7004、7002-&gt;7005</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cluster]# redis-cli -p 7003 cluster replicate 0ed9079a0d32b7e926a96d6a03d431c1228deffb</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7004 cluster replicate b4c274d2501d4d105c8b7acf7787a66287a7406a</span><br><span class="line">OK</span><br><span class="line">[root@localhost cluster]# redis-cli -p 7005 cluster replicate 8465de32a8e17d23134d8ae8d62f2c78c9e40ef2</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">[root@localhost cluster]# redis-cli -p 7000 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现7005-7004都成为了salve</span></span><br><span class="line">9c736c0733323151ee5aeaa8444cf177ab9b312b 192.168.211.134:7005 slave 8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 0 1554833875305 5 connected</span><br><span class="line">97ba85211fa2d68ebff5ae4848eb4a52a899be5a 192.168.211.134:7003 slave 9c736c0733323151ee5aeaa8444cf177ab9b312b 0 1554833874286 5 connected</span><br><span class="line">89d495be82b618256b5c79a56f6894658db4cfa8 192.168.211.134:7004 slave b4c274d2501d4d105c8b7acf7787a66287a7406a 0 1554833871215 3 connected</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3个主节点</span></span><br><span class="line">0ed9079a0d32b7e926a96d6a03d431c1228deffb 192.168.211.134:7000 myself,master - 0 0 1 connected</span><br><span class="line">b4c274d2501d4d105c8b7acf7787a66287a7406a 192.168.211.134:7001 master - 0 1554833873263 0 connected</span><br><span class="line">8465de32a8e17d23134d8ae8d62f2c78c9e40ef2 192.168.211.134:7002 master - 0 1554833876331 2 connected</span><br></pre></td></tr></table></figure><h1 id="Ruby搭建集群"><a href="#Ruby搭建集群" class="headerlink" title="Ruby搭建集群"></a>Ruby搭建集群</h1><p>ruby是官方推荐的搭建集群方式，自动分配槽和主从复制</p><h2 id="安装ruby环境"><a href="#安装ruby环境" class="headerlink" title="安装ruby环境"></a>安装ruby环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ruby依赖</span></span><br><span class="line">yum install ruby rubygems -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> gem-redis安装  https://rubygems.org/gems/redis/versions/3.0.0</span></span><br><span class="line">gem install -l redis-3.0.0.gem  </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时redis3.0.0/src目录有 redis.trib.rb文件，将它拷贝到/usr/lcoal/bin</span></span><br><span class="line">cp redis-trib.rb /usr/local/bin/redis-trib</span><br></pre></td></tr></table></figure><ul><li>redis-trib用于管理集群的命令<br><img src="http://poporz7f8.bkt.clouddn.com/redis-trib.jpg" alt></li></ul><h2 id="配置6个节点并启动"><a href="#配置6个节点并启动" class="headerlink" title="配置6个节点并启动"></a>配置6个节点并启动</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">port</span> <span class="number">7001</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"7001.log"</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"dump-7001.rdb"</span></span><br><span class="line"><span class="string">cluster-enabled</span> <span class="literal">yes</span></span><br><span class="line"><span class="string">cluster-config-file</span> <span class="string">nodes-7001.conf</span></span><br><span class="line"><span class="string">cluster-require-full-coverage</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure><blockquote><p>其他节点修改端口即可，分别启动：<br><img src="http://poporz7f8.bkt.clouddn.com/ztai.jpg" alt></p></blockquote><h2 id="使用redis-trib搭建集群"><a href="#使用redis-trib搭建集群" class="headerlink" title="使用redis-trib搭建集群"></a>使用redis-trib搭建集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-trib create --replicas 1 192.168.211.136:7001 192.168.211.136:7002 192.168.211.136:7003 192.168.211.136:7004 192.168.211.136:7005 192.168.211.136:7006</span><br></pre></td></tr></table></figure><ul><li><p>启动状态如下<br><img src="http://poporz7f8.bkt.clouddn.com/redis-ruby-cluster.jpg" alt></p></li><li><p>cluster info打印集群信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-jiqungeshu.jpg" alt></p></li><li><p>cluster nodes列出集群已知节点<br><img src="http://poporz7f8.bkt.clouddn.com/cluster-nodes.jpg" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sentinel问题引入&quot;&gt;&lt;a href=&quot;#sentinel问题引入&quot; class=&quot;headerlink&quot; title=&quot;sentinel问题引入&quot;&gt;&lt;/a&gt;sentinel问题引入&lt;/h1&gt;&lt;p&gt;上一篇章中，我们讲述了redis sentinel实现高可用
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis集群——哨兵</title>
    <link href="http://yoursite.com/2019/04/08/redis%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%93%A8%E5%85%B5/"/>
    <id>http://yoursite.com/2019/04/08/redis集群——哨兵/</id>
    <published>2019-04-08T08:59:57.000Z</published>
    <updated>2019-04-15T06:27:57.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制问题引入"><a href="#主从复制问题引入" class="headerlink" title="主从复制问题引入"></a>主从复制问题引入</h1><p>当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。我们希望可做到高可用的故障转移，也就是说如果有一个服务宕机了，希望有另一台服务可顶替。通俗的将就是将故障进行转移，保证redis整体服务是可运行的</p><h2 id="master故障"><a href="#master故障" class="headerlink" title="master故障"></a>master故障</h2><p>如果slave出现故障，问题并不是很大，因为可以从master进行读写操作。如果master故障了，那么其他从节点将会断开与master的连接，此时客户端只可进行读的操作<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault.jpg" alt></p><h2 id="master宕机处理"><a href="#master宕机处理" class="headerlink" title="master宕机处理"></a>master宕机处理</h2><p>首先我们要保证有写数据，可以将一台slave成为master，另外一台成为从节点<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault-success.jpg" alt></p><p>上述问题并没有解决自动故障转移的主要问题：自动让slave成为master，让其他slave同步master</p><h1 id="redis-sentinel架构"><a href="#redis-sentinel架构" class="headerlink" title="redis sentinel架构"></a>redis sentinel架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel1.jpg" alt></p><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案, Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。它的主要功能有如下几点</p><ol><li><p>不时地监控redis是否按照预期良好地运行</p></li><li><p>如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端)</p></li><li><p>能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址</p></li></ol><h2 id="sentinel核心配置"><a href="#sentinel核心配置" class="headerlink" title="sentinel核心配置"></a>sentinel核心配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 去掉注释查看文件</span></span><br><span class="line">[root@localhost config]# cat sentinel.conf | grep -v "#" | grep -v "^$"</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel默认端口</span></span><br><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控主节点 2标识你需要几个sentinel对master进行发现问题</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障时间</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制同时并发执行</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障转移时间</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><h1 id="sentinel实验"><a href="#sentinel实验" class="headerlink" title="sentinel实验"></a>sentinel实验</h1><p>实现如下配置</p><ul><li>master-7000、slave-7001、slave-7002</li><li>sentinel-26379(默认端口)、sentinel-26380、sentinel-26381</li></ul><h2 id="开启主从节点"><a href="#开启主从节点" class="headerlink" title="开启主从节点"></a>开启主从节点</h2><h3 id="redis-7000-conf-master"><a href="#redis-7000-conf-master" class="headerlink" title="redis-7000.conf(master)"></a>redis-7000.conf(master)</h3><blockquote><p>vim redis-{port}.conf: 分别添加如下配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="redis-7001-conf-slave"><a href="#redis-7001-conf-slave" class="headerlink" title="redis-7001.conf(slave)"></a>redis-7001.conf(slave)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7001.pid</span><br><span class="line">logfile "7001.log"</span><br><span class="line">dir ./</span><br><span class="line">slaveof 192.168.211.134 7000</span><br></pre></td></tr></table></figure><blockquote><p>redis-7002.conf修改端口即可</p></blockquote><h3 id="启动一主二从"><a href="#启动一主二从" class="headerlink" title="启动一主二从"></a>启动一主二从</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-server redis-7000.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7001.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7002.conf </span><br><span class="line">[root@localhost config]# redis-cli -p 7000 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7001 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7002 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7000 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.211.134,port=7001,state=online,offset=197,lag=0</span><br><span class="line">slave1:ip=192.168.211.134,port=7002,state=online,offset=197,lag=1</span><br></pre></td></tr></table></figure><h2 id="开启sentinel"><a href="#开启sentinel" class="headerlink" title="开启sentinel"></a>开启sentinel</h2><h3 id="sentinel-26379-conf"><a href="#sentinel-26379-conf" class="headerlink" title="sentinel-26379.conf"></a>sentinel-26379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir /tmp</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><blockquote><p>其他sentinel-26380.conf、sentinel-26381.conf修改端口即可</p></blockquote><h2 id="测试sentinel"><a href="#测试sentinel" class="headerlink" title="测试sentinel"></a>测试sentinel</h2><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26379.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26380.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><h3 id="sentinel-info"><a href="#sentinel-info" class="headerlink" title="sentinel info"></a>sentinel info</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 26379</span><br><span class="line">127.0.0.1:26379&gt; set hello world</span><br><span class="line">(error) ERR unknown command 'set'</span><br><span class="line">127.0.0.1:26379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:26379&gt; info</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel 的一些信息</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinels=3 有三个sentinel</span></span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.211.134:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><blockquote><p>我们可发现sentinel监控的master和开启了多少个sentinel进行监控主从的信息</p></blockquote><h3 id="查看sentinel的变化"><a href="#查看sentinel的变化" class="headerlink" title="查看sentinel的变化"></a>查看sentinel的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# cat redis-sentinel-26379.conf </span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir "/tmp"</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7001</span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by CONFIG REWRITE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7002</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><blockquote><p>sentinel会自动发现slave信息</p></blockquote><h1 id="客户端连接sentinel"><a href="#客户端连接sentinel" class="headerlink" title="客户端连接sentinel"></a>客户端连接sentinel</h1><p>为什么我们不直接连接master? 因为我们采用高可用的方式，如果服务器端master宕机了，sentinel会完成自动的故障转移，那么此时客户端就不知道master节点的ip了。</p><blockquote><p>基本原理：</p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-client.jpg" alt></p><h1 id="故障转移实验"><a href="#故障转移实验" class="headerlink" title="故障转移实验"></a>故障转移实验</h1><p>我们将实现从master-7000端口中不断的set值，然后将master进程kill看看sentinel会不会自动处理故障转移</p><h2 id="mavean依赖"><a href="#mavean依赖" class="headerlink" title="mavean依赖"></a>mavean依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ResisSentinelTest-java"><a href="#ResisSentinelTest-java" class="headerlink" title="ResisSentinelTest.java"></a>ResisSentinelTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResisSentinelTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisPipelineTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26379"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26380"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26381"</span>);</span><br><span class="line">        JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取连接</span></span><br><span class="line">                jedis = sentinelPool.getResource();</span><br><span class="line">                <span class="comment">// 不断的set值</span></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</span><br><span class="line">                String key = <span class="string">"k-"</span> + index;</span><br><span class="line">                String value = <span class="string">"v-"</span> + index;</span><br><span class="line">                jedis.set(key, value);</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">"&#123;&#125; value is &#123;&#125; "</span>, key, jedis.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行上述代码之后会不断的输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_1.jpg" alt></p></li><li><p>当我们在进行kill master之后控制台会输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_2.jpg" alt></p></li></ul><p><strong>当过了30秒之后sentinel会进行故障转移，恢复set的操作</strong></p><ul><li>我们可以查看salve-7001和slave和7002哪个成为了master<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br></pre></td></tr></table></figure></li></ul><h1 id="sentinel原理"><a href="#sentinel原理" class="headerlink" title="sentinel原理"></a>sentinel原理</h1><p>sentinel可以对redis节点作失败判定以及故障转移，在sentinel内部有三个定时任务作为基础来实现上述所描述的</p><ul><li><p>每10秒每个sentinel对master和slave执行info</p><blockquote><p>发现slave</p></blockquote><blockquote><p>确认主从关系</p></blockquote></li><li><p>每两秒每个sentinel和master进行发布订阅模式的形式，达成整体的信息交互平台</p><blockquote><p>通过<em>sentinel</em>:hello频道交互</p></blockquote><blockquote><p>交互对节点的”看法”和自身信息</p></blockquote></li><li><p>每一秒每个sentinel对其他sentinel和redis执行ping</p><blockquote><p>心跳检测、失败判定的依据</p></blockquote></li></ul><h2 id="主观下线-客观下线"><a href="#主观下线-客观下线" class="headerlink" title="主观下线|客观下线"></a>主观下线|客观下线</h2><p>sentinel核心配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor [master-group-name] [ip] [port] [quorum]</span><br></pre></td></tr></table></figure><p>这一行用于告诉Redis监控一个master叫做mymaster，它的地址在127.0.0.1，端口为6379，票数是2，<strong>票数个数建议为奇数, 且个数=1/2+1</strong></p><p><strong>quorun</strong>：票数，sentinel需要协商同意master是否可到达的数量，举个例子，redis集群中有5个sentinel实例，其中master挂掉啦，如果这里的票数是2，表示有2个sentinel认为master挂掉啦，才能被认为是正真的挂掉啦</p><h3 id="down-after-milliseconds"><a href="#down-after-milliseconds" class="headerlink" title="down-after-milliseconds"></a>down-after-milliseconds</h3><p>sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会<strong>主观</strong>地认为这个master已经不可用了。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。</p><p><strong>主观下线</strong>：每个sentinel节点对redis节点的失败的”偏见”</p><p><strong>客观下线</strong>：所有sentinel节点对redis节点失败”达成共识”（超过票数个统一）</p><h3 id="parallel-syncs"><a href="#parallel-syncs" class="headerlink" title="parallel-syncs"></a>parallel-syncs</h3><p>在发生failover主从切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成主从故障转移所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为主从同步而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</p><h2 id="领导则选举"><a href="#领导则选举" class="headerlink" title="领导则选举"></a>领导则选举</h2><p>我们知道之际上完成故障转移的任务只需要一个sentinel即可。选举通过sentinel is-master-down-by-addr命令都希望成为领导者，此命令的作用: 一<strong>确认下线判定</strong>，二是进行<strong>领导者选举</strong></p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>1）每个做主观下线的sentinel节点向其他sentinel节点发送上面那条命令，要求将它设置为领导者。</p><p>2）收到命令的sentinel节点如果还没有同意过其他的sentinel发送的命令（还未投过票），那么就会同<br>意，否则拒绝。</p><p>3）如果该sentinel节点发现自己的票数已经过半且达到了quorum的值，就会成为领导者</p><p>4）如果这个过程出现多个sentinel成为领导者，则会等待一段时间重新选举</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>redis-sentinel是redis实现高可用的方案：故障发现、故障自动转移、配置中心、客户端通知</p></li><li><p>redis-sentinel是redis2.8版本才开始正式使用 </p></li><li><p>尽可能在不同的物理机上部署redis-sentinel所有节点</p></li><li><p>redis-sentinel中的sentinel节点个数应该为大于等于3且最好为奇数</p></li><li><p>客户端初始化连接的是sentinel节点集合，不再是具体的redis节点，但是sentinel只是配置中心不是代理</p></li><li><p>redis-sentinel通过三个定时任务实现了sentinel节点对主从节点、其余sentinel节点的监控</p></li><li><p>redis-sentinel在对节点做失败判定时分为主管下线和和客观下线</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制问题引入&quot;&gt;&lt;a href=&quot;#主从复制问题引入&quot; class=&quot;headerlink&quot; title=&quot;主从复制问题引入&quot;&gt;&lt;/a&gt;主从复制问题引入&lt;/h1&gt;&lt;p&gt;当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis集群——复制</title>
    <link href="http://yoursite.com/2019/04/07/redis%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/07/redis集群——复制/</id>
    <published>2019-04-07T01:45:28.000Z</published>
    <updated>2019-04-15T09:10:52.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-master-slave.jpg" alt></p><p>单机部署redis所存在的问题：机器故障数据转移、容量瓶颈、QPS瓶颈</p><p>主节点master负责<strong>写数据</strong>，从节点slave负责<strong>读数据</strong>，主节点定期把数据同步到从节点保证数据的一致性</p><blockquote><p>主从复制的作用：数据副本（高可用分布式基础）、读写分离提高性能</p></blockquote><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><p><strong>命令slaveof</strong>和配置文件的方式</p><h3 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a>slaveof</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6380节点（从）复制6379节点（主）</span></span><br><span class="line">redis-6380 &gt; slaveof 192.168.211.134:6379 OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消复制（不希望成为从），此时会断开连接（从数据并不会丢失，而是主的数据不会同步给从）</span></span><br><span class="line">redis-6380 &gt; slaveof no one OK</span><br></pre></td></tr></table></figure><h2 id="主从复制实验"><a href="#主从复制实验" class="headerlink" title="主从复制实验"></a>主从复制实验</h2><ul><li><p>我们通过配置文件的方式实现 6379作为主节点、6380为从节点</p></li><li><p>其中有两个中要的配置slaveof ip port、slave-read-only yes（期望从节点只作读操作）目的是达到主从复制数据的一致性效果。保证主节写操作，而从节点只作为读操作</p></li><li><p>cp redis.conf两份分别命名为 redis-6379.conf、redis-6380.conf</p></li></ul><h3 id="redis-6379-conf"><a href="#redis-6379-conf" class="headerlink" title="redis-6379.conf"></a>redis-6379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后台启动</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta">#</span><span class="bash">进程id</span></span><br><span class="line">pidfile /var/run/redis-6379.pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主节点密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile "6379.log"</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb文件</span></span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置主从关系</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只读，主节点不关心</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分片信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication </span><br><span class="line">role:master # 主节点</span><br><span class="line">connected_slaves:0 # 所连接的从节点个数</span><br></pre></td></tr></table></figure></li></ul><h3 id="redis-6380-conf"><a href="#redis-6380-conf" class="headerlink" title="redis-6380.conf"></a>redis-6380.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 开启守护者进程</span><br><span class="line">pidfile /var/run/redis-6380.pid #进程id</span><br><span class="line">port 6380</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dbfilename dump-6380.rdb # rdb文件</span><br><span class="line">slaveof 192.168.211.134 6379 # 成为6379的从节点</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从节点只作为读操作</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">127.0.0.1:6379&gt; info replication # 查看分片信息</span><br><span class="line">role:slave # 已成为从节点</span><br><span class="line">master_host:192.169.211.134 # 主节点地址</span><br><span class="line">master_port:6379 # 主节点端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>从主节点6379端口中set值，从节点会复制主节点的数据<br><img src="http://poporz7f8.bkt.clouddn.com/redis-test.jpg" alt></p><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><p>主从复制的读写分离实际上内部使用命令的方式进行数据的同步，我们可以分析两个日志文件</p><h2 id="6379-log"><a href="#6379-log" class="headerlink" title="6379.log"></a>6379.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6379log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示6380需要进行复制操作</span></span><br><span class="line">Slave 192.168.211.134:6380 asks for synchronization</span><br><span class="line"><span class="meta">#</span><span class="bash"> resync 全量复制操作</span></span><br><span class="line">Full resync requested by slave 192.168.211.134:6380</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现复制操作是使用RDB进行实现的，实际就是将快照进行同步</span></span><br><span class="line">Starting BGSAVE for SYNC with target: disk</span><br></pre></td></tr></table></figure><h2 id="6380-log"><a href="#6380-log" class="headerlink" title="6380.log"></a>6380.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6380log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接主节点</span></span><br><span class="line">Connecting to MASTER 192.168.211.134:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主从复制</span></span><br><span class="line">MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master的runid（每一个redis启动时的随机ID）</span></span><br><span class="line">Full resync from master: f45a09af5ab5fe887ad7a33b451e4955b1dafebd:1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master节点数据(rbd)</span></span><br><span class="line">receiving 31 bytes from master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空之前的数据(全量复制的情况下)</span></span><br><span class="line">Flushing old data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载rdb</span></span><br><span class="line">Loading DB in memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载成功</span></span><br><span class="line">Finished with success</span><br></pre></td></tr></table></figure><h2 id="验证Flushing-old-data"><a href="#验证Flushing-old-data" class="headerlink" title="验证Flushing old data"></a>验证Flushing old data</h2><p>我们可以看到上述6380日志，当拿到master节点之后做的事情，清空旧的数据、加载RDB，如下实验验证是否安装该流程进行的</p><ul><li><p>先将6380成为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> slaveof no one</span></span><br></pre></td></tr></table></figure></li><li><p>切换到6379添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">mset a b c d</span><br></pre></td></tr></table></figure></li><li><p>再切换到6380执行如下操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时成为master当然不能同步数据</span></span><br><span class="line">keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一些数据</span></span><br><span class="line">127.0.0.1:6380&gt; set abc6380 hello</span><br><span class="line">127.0.0.1:6380&gt; slaveof 192.168.211.134 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) "c"</span><br><span class="line">2) "a"</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们可以看到当slaveof继续成为从节点时候，再获取数据时之前的abc6379已被删除</p></blockquote><h1 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h1><p>我们在分析日志的时候发现，master有resync(全量复制)、slave有获取masterRUNID的一些操作，引入我们引入两个概念 <strong>runid</strong> 以及 <strong>偏移量</strong></p><h2 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h2><p>每一个redis服务启动时，都会随机一个字符串id，作为一个标识。如果重启之后，runid会消失</p><ul><li>查看runid<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 6379 info server | grep run</span><br><span class="line">run_id:f45a09af5ab5fe887ad7a33b451e4955b1dafebd</span><br><span class="line">[root@localhost config]# redis-cli -p 6380 info server | grep run</span><br><span class="line">run_id:e93481fdcc9e791516c77f8a61a3e7e5e2db4f9e</span><br></pre></td></tr></table></figure></li></ul><p>当复制时发现和之前的 run_id不同时（重启），将会对数据全量同步，一般用于初次复制场景</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>一个数据写入量的字节(如 set a b)，此时从节点会同步记录偏移量，当主从偏移量达到一至时，那么就完成了数据同步的过程。简言之：通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致 </p><blockquote><p>如果主、从偏移量不一至。master &gt; slave可能会出现主从不一致</p></blockquote><ul><li>查看偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:48425</span><br></pre></td></tr></table></figure></li></ul><p>当我们添加值时，偏移量也会随着增加</p><ul><li>查看主、从偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:49146</span><br><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6380 info replication</span><br><span class="line">slave_repl_offset:49170</span><br></pre></td></tr></table></figure></li></ul><p>为什么主从偏移量不一致呢？实际上主从的偏移量是一个同步更新的状态，从节点会将一些状态向主节点上报。我们也可查看主从的同步状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">slave0:ip=192.168.211.134,port=6380,state=online,offset=49482,lag=2</span><br><span class="line">master_repl_offset:49482</span><br></pre></td></tr></table></figure></p><blockquote><p>通常offset差距不会太大，否则可能有其他问题如网络、阻塞</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-slavecopy.jpg" alt></p><p>如果对于一个存了很多数据的master，slave期望复制master中的数据，并且这些数据是时刻同步的、完整的。这样就可达到完整的数据同步效果。</p><ul><li>首先将本身的RDB文件同步给slave，为了达到时刻同步，在此期间，master写入的命令也会记录下来。当slave将RDB加载完后，会通过偏移量的对比将这期间master写入的值同步给slave</li></ul><ol><li><p>首先slave发送命令psync ? -1，参数1:runid，参数2：偏移量（报告主节点偏移量）。由于第一次复制不知道runid和偏移量，所以参数为?和-1</p></li><li><p>master接收到此命令，将runid和偏移量发送给slave</p></li><li><p>slave保存master的基本信息</p></li><li><p>master会执行bgsave（rdb生成）</p></li></ol><blockquote><p>此时怎么将RDB发送给salve呢？master内部有复制缓冲区reple_back_buffer，它可记录最新的数据</p></blockquote><ol start="5"><li><p>经过了缓冲区的过滤，将RDB和缓存的一些信息发送给slave(5-6步骤)</p></li><li><p>slave先清空自己old数据</p></li><li><p>加载RDB以及缓存数据完成同步</p></li></ol><h1 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h1><p>经过上述分析，我们可以明显感受到，全量复制的开销是巨大的。有如下几个问题</p><ul><li>bgsave时间，需要生成RDB</li><li>RDB文件网络传输时间</li><li>slave清空old的时间</li><li>slave加载RDB的时间</li><li>可能的AOF重写时间</li></ul><h2 id="为什么需要部分复制"><a href="#为什么需要部分复制" class="headerlink" title="为什么需要部分复制"></a>为什么需要部分复制</h2><p> 在redis2.8版本之前，如果master和slave之间的网络发生了抖动连接断开，就会导致slave完全不知道master的动作，同步就会出问题，而为了保证数据一致，等网络恢复后进行一次全量复制。而全量复制的开销是很大的，redis2.8版本就提个了一个部分复制的功能</p><h2 id="部分复制的实现原理"><a href="#部分复制的实现原理" class="headerlink" title="部分复制的实现原理"></a>部分复制的实现原理</h2><p>当master和slave断开连接时，master会将期间所做的操作记录到复制缓存区当中（可以看成是一个队列，其大小默认1M）。待slave重连后，slave会向master发送psync命令并传入offset和runId，这时候，如果master发现slave传输的偏移量的值，在缓存区队列范围中，就会将从offset开始到队列结束的数据传给slave，从而达到同步，降低了使用全量复制的开销</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://poporz7f8.bkt.clouddn.com/redis-master-slave.
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch+filebeat+kibana日志收集</title>
    <link href="http://yoursite.com/2019/04/06/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/04/06/ELK日志收集/</id>
    <published>2019-04-06T13:18:14.000Z</published>
    <updated>2019-04-15T16:18:17.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>对大规模日志数据进行采集、追踪、分析及处理</p><p>目前主流的分布式日志框架有：</p><ul><li><p>Logstash ELK(ElasticsSearch, Logstash, Kibana) – 一套强大的日志收集系统，由于Logstash消耗资源过大，官方推荐使用filebeat取代</p></li><li><p>Flume – 由Apache基金会提供的一个分布式、高可靠、高可用的服务</p></li><li><p>filebeat用于日志的收集、elasticsearch用于存储日志、kibana实现数据的展示</p></li><li><p>download: <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases</a></p></li></ul><h1 id="elasticsearch-install"><a href="#elasticsearch-install" class="headerlink" title="elasticsearch install"></a>elasticsearch install</h1><ul><li><p>es启动不能使用root，因此需要创建一个用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd es</span><br><span class="line">useradd es -g es</span><br><span class="line">passwd es</span><br></pre></td></tr></table></figure></li><li><p>切换root进入es目录为es文件给予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es es es-5.6.16</span><br></pre></td></tr></table></figure></li><li><p>修改/conf/elasticsearch.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Network </span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">network.host: ip  </span><br><span class="line"><span class="meta">#</span> 默认http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta">#</span> 默认tcp端口</span><br><span class="line">transport.tcp.port: 9300</span><br></pre></td></tr></table></figure></li><li><p>修改jvm内存大小 /conf/jvm.options</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xms1g</span><br></pre></td></tr></table></figure></li><li><p>由于es启动需要开启大量线程，需要修改系统文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vi /etc/security/limits.conf</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> cd /etc/security/limits.d</span><br><span class="line">vi 20-nproc.conf</span><br><span class="line">root       soft    nproc     2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> vi /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>su es &gt; ./elasticsearch 如果启动不了设置防火墙</p></blockquote><h1 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h1><p>Filebeat是一个轻量型日志采集器，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放</p><ul><li>安装完之后编辑核心配置文件filebeat.yml</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 指定被探测的日志文件, 可添加多个该配置</span><br><span class="line">paths:</span><br><span class="line">    - /install/logs/*.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置多行合并</span><br><span class="line">multiline.pattern: ^\[</span><br><span class="line">multiline.negate: true</span><br><span class="line">multiline.match: after    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定es的位置，将日志收集到es存储</span><br><span class="line">output.elasticsearch:</span><br><span class="line"><span class="meta">  #</span> Array of hosts to connect to.</span><br><span class="line">  hosts: ["192.168.211.134:9200"]</span><br></pre></td></tr></table></figure><blockquote><p>./filebeat 启动</p></blockquote><blockquote><p>日志收集测试 : 当配置的探测日志文件发生变化时，filebeat会将数据发送给ES进行存储</p></blockquote><h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p>kibana可取代elastic-head，提供了更为专业的可视化界面、日志分析系统，它是ES的成员之一</p><ul><li>安装完之后配置kibana.yml核心配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认端口</span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">server.host: "192.168.211.134"</span><br><span class="line"><span class="meta">#</span> 指定es的地址</span><br><span class="line">elasticsearch.url: "http://192.168.211.134:9200"</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">cd bin &gt; ./kibana</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;p&gt;对大规模日志数据进行采集、追踪、分析及处理&lt;/p&gt;
&lt;p&gt;目前主流的分布式日志框架有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Logstash E
      
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="http://yoursite.com/tags/elasticsearch/"/>
    
      <category term="Kibana" scheme="http://yoursite.com/tags/Kibana/"/>
    
      <category term="Logstash" scheme="http://yoursite.com/tags/Logstash/"/>
    
  </entry>
  
  <entry>
    <title>redis的持久化</title>
    <link href="http://yoursite.com/2019/04/06/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/06/redis的持久化/</id>
    <published>2019-04-05T16:55:05.000Z</published>
    <updated>2019-04-15T16:14:05.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h1><p>redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 <strong>Redis</strong> 提供了两种<strong>持久化</strong>的方案，将内存中的数据保存到磁盘中，避免数据的丢失</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><blockquote><p>该机制使用快照方式，在指定的时间内将内存中的数据写入到硬盘（rdb文件），也可手动执行命令</p></blockquote><ul><li>文件策略：如果存在老的RDB文件，会进行替换</li><li>优点：RBD作为一个备份文件容易恢复，性能好，通过子进程fork生成rdb，用于备份</li><li>缺点：容易造成数据丢失，如果fork花费时间大，那么将会阻塞redis服务、耗时耗性能</li></ul><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><ul><li>save命令（同步 ） — 可能会产生阻塞</li><li>bgsave命令（异步）— <strong>创建一个子进程fork() </strong>生成rdb文件（阻塞发生在<br>fork），创建完毕返回给主进程bgsave successfully</li><li>自动 — 根据save配置自动生成，例如如果在60秒内改变了1w条数据则生成rdb、300-10、900-1满足任一个条件（底层使用fork）</li></ul><p>在redis.conf中节点为SNAPSHOTTING中有如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta">#</span><span class="bash"> bgsave发生错误是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb是否采用压缩格式</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd校验</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认rbd文件名，在/bin目录</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志等文件存储位置</span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p>推荐配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不采用自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd文件名称采用+端口形式区分</span></span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议指定容量较大硬盘位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他默认</span></span><br></pre></td></tr></table></figure><blockquote><p>不容忽略的方式：主从复制、debug reload、shutdown可能会触发</p></blockquote><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB快照方式并不是很可靠，如果服务器宕机，那么最新的数据就会丢失。而AOF文件提供一种更为可靠的的持久化方式。当进行set操作时，会追加到AOF文件中。当redis重启之后，AOF中的命令会被重新执行一次，重建数据</p><h2 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-aof.jpg" alt></p><ul><li>always：每条命令都会持久化一次（执行写操作时，先进入缓冲区后写入到硬盘）</li><li>everysec：每秒持久化一次</li><li>no：缓冲区的刷新策略根据OS决定</li></ul><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>由于每条命令都会追加到AOF文件中，随着时间的推移，AOF文件必然逐渐变大。AOF重写解决了这一问题</p><ul><li>例 ：命令优化、过期数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hello one</span><br><span class="line">set hello two</span><br><span class="line">set hello three</span><br></pre></td></tr></table></figure><p>当连续执行上诉命令最终的结果为three，而AOF并不会写入三次命令，而只会追加有效的命令set hello three</p><ul><li><p>AOF重写实现的两种方式</p><blockquote><p>bgrewriteaof命令：（类似RDB的bgsave）开启子线程完成AOF重写</p></blockquote><blockquote><p>AOF重写配置</p></blockquote></li></ul><p>在/redis.conf配置文件有APPEND ONLY MODE节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要完成aof功能开启为yes</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 三种同步策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always</span></span><br><span class="line">appendfsync everysec -- 每秒写入（默认）</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入aof文件，不等待磁盘同步（安全，但可能阻塞）</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><h1 id="RDB和AOF的抉择"><a href="#RDB和AOF的抉择" class="headerlink" title="RDB和AOF的抉择"></a>RDB和AOF的抉择</h1><blockquote><p>比较 </p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-rdb-aof.jpg" alt></p><blockquote><p>RDB最佳策略</p></blockquote><ul><li>“关闭”rdb</li><li>集中管理，指定时间内进行大量的数据备份</li><li>从节点开启</li><li>分片</li></ul><blockquote><p>AOF最佳策略</p></blockquote><ul><li>“开启” ： 缓存和存储</li><li>AOF重写集中管理</li><li>everysec策略</li><li>分片</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>当进行 RDB的<strong>bgsave</strong>操作和AOF的<strong>bgrewriteaof</strong>会产生子线程进行持久化的相关操作，如果fork操作执行慢，此时会将redis主线程阻塞。 </p><ul><li>查看fork持久化的时间</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latest_fork_usec</span><br></pre></td></tr></table></figure><ul><li><p>改善</p><blockquote><p>物理机或支持fork操作的虚拟化技术</p></blockquote><blockquote><p>控制redis实例最大可用内存：maxmemory</p></blockquote><blockquote><p>合理配置Linux内存分配策略：vm.overcommit_memory=1（默认0）</p></blockquote><blockquote><p>放宽AOF重写自动触发机制，不必全量复制</p></blockquote></li></ul><h2 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h2><blockquote><p>bgsave和bgrewriteaof是将内存中的数据写入到硬盘，此时会集中消耗CPU、rork内存开销、硬盘</p></blockquote><ul><li><p>优化</p><blockquote><p>不做CPU绑定，不和CPU密集部署，单机部署不要大量的AOF和RDB持久化的过程</p></blockquote><blockquote><p>echo never &gt; 追加配置文件</p></blockquote><blockquote><p>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</p></blockquote><blockquote><p>配置no-appendfsync-on-rewrite yes </p></blockquote><blockquote><p>ssd介质</p></blockquote></li></ul><h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><p>如果我们使用了AOF的每秒刷盘策略，如果fork执行大于2秒，那么主线程阻塞</p><ul><li><p>阻塞定位</p><blockquote><p>redis日志</p></blockquote><blockquote><p>info persistence收集记录</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持久化的作用&quot;&gt;&lt;a href=&quot;#持久化的作用&quot; class=&quot;headerlink&quot; title=&quot;持久化的作用&quot;&gt;&lt;/a&gt;持久化的作用&lt;/h1&gt;&lt;p&gt;redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 &lt;
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>瑞士军刀redis</title>
    <link href="http://yoursite.com/2019/04/05/%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80redis/"/>
    <id>http://yoursite.com/2019/04/05/瑞士军刀redis/</id>
    <published>2019-04-05T14:51:03.000Z</published>
    <updated>2019-04-15T15:58:37.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><p>许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息（例如：发生时间、耗时、命令的详细信息）记录下来，Redis也提供了类似的功能。</p><ul><li>首先我们需要先了解client和serve的生命周期</li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-server.jpg" alt></p><hr><blockquote><p>慢查询发生在第三阶段</p></blockquote><blockquote><p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p></blockquote><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><p>多数情况下，我们会通过请求-响应的机制来操作redis。当要执行多个命令时，由于redis是单线程的，那么下一次请求必须等待上一次请求完成之后才可继续执行。而pipeline模式，客户端可一次性将命令打包发送，</p><blockquote><p>无需等待服务端返回。这样就减少了网络往返时间。</p></blockquote><ul><li>使用传统方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashKey:"</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">//2983</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用pipeline</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        pipeline.hset(<span class="string">"hashKey: "</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">// 38</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>位图：基于最小的单位bit进行存储，非常省空间、二进制数据存储，计算快</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取出位图指定索引的值</span></span><br><span class="line">getbit element 0</span><br></pre></td></tr></table></figure><ul><li>使用场景：独立用户统计（一亿用户，五千万独立）</li></ul><blockquote><p>set存储: 内存量200mb</p></blockquote><blockquote><p>bitmap存储：内存量12.5mb</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;慢查询&quot;&gt;&lt;a href=&quot;#慢查询&quot; class=&quot;headerlink&quot; title=&quot;慢查询&quot;&gt;&lt;/a&gt;慢查询&lt;/h1&gt;&lt;p&gt;许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis api</title>
    <link href="http://yoursite.com/2019/04/05/redis-api/"/>
    <id>http://yoursite.com/2019/04/05/redis-api/</id>
    <published>2019-04-05T14:50:50.000Z</published>
    <updated>2019-04-15T16:28:57.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><ul><li>keys[patten]（查看所有的key）</li><li>dbsiz（查看所有key的大小）</li><li>exists key（判断一个key是否存在）</li><li>del key [key ..] （删除key）</li><li>expice key seconds（为key设置过期时间）</li><li>type key（查看key类型）</li></ul><h1 id="内部编码架构"><a href="#内部编码架构" class="headerlink" title="内部编码架构"></a>内部编码架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-code.jpg" alt></p><hr><h1 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sing.jpg" alt></p><hr><blockquote><p><strong>当我们在操作redis时，时刻要明白redis在一个瞬间只会执行一条命令，不会执行两条命令</strong></p></blockquote><ul><li><p>单线程为何快？</p><blockquote><p>纯内存</p></blockquote><blockquote><p>非阻塞IO</p></blockquote><blockquote><p>避免线程之间的切换和竞态消耗</p></blockquote></li></ul><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><ul><li>redis所有的key都为字符串，value可存储普通字符串、数值、二进制</li><li>使用场景：缓存、计数器、分布式锁</li><li><p>字符串的value不能大于512MB</p></li><li><p>基本命令  get、set、del（O1）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取key对应的value</span></span><br><span class="line">get key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key-value</span></span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key-value</span></span><br><span class="line">del key</span><br></pre></td></tr></table></figure></li><li><p>计数命令 incr 、decr、incrby、decrby（O1）：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key自增1，0开始</span></span><br><span class="line">incr key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反</span></span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 期望自增指定值，key自增k</span></span><br><span class="line">incrby key k</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反</span></span><br><span class="line">decrby key k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浮点数的自增3.5</span></span><br><span class="line">incrbyfloat key 3.5</span><br></pre></td></tr></table></figure><ul><li>其他set命令 set、setnx、setxx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不管key是否存在，都设置</span></span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> key不存在才进行设置（add操作）</span></span><br><span class="line">setnx key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> key存在才设置（update操作）</span></span><br><span class="line">set key value xx</span><br></pre></td></tr></table></figure><ul><li>批量处理命令：mget  mset</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 批量获取key</span></span><br><span class="line">mget key1 key2 ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置key-value</span></span><br><span class="line">mset key1 value1 key2 value2 ...</span><br></pre></td></tr></table></figure><blockquote><p>如果传输n次get命令，那么 <strong>n次get = n次网络时间 + n次命令时间</strong></p></blockquote><blockquote><p>如果1次将命令批量传输给服务端，那么 <strong>1次mget = 1次网络时间 + n次命令时间</strong></p></blockquote><ul><li>其他命令 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为key设置新的值，并返回之前的值</span></span><br><span class="line">getset key newvalue</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为key追加值</span></span><br><span class="line">append key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回字符串长度</span></span><br><span class="line">strlen key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：</p></blockquote><ul><li>记录网站每个用户个人主页的访问量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr userid:pageview</span><br></pre></td></tr></table></figure><ul><li>缓存视频的基本信息（数据源在mysql）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 从redis中取数据，存在数据直接返回，则不需要访问mysql</span><br><span class="line"><span class="number">2</span>. 若不存在，访问mysql，获取到数据，加入到redis缓存</span><br><span class="line"><span class="number">3</span>. 当下此访问此接口时，会从redis中访问</span><br></pre></td></tr></table></figure><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>hash键值结构：</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-hash.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">hash</span> key对应的field的value</span></span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置<span class="built_in">hash</span> key对应file的value</span></span><br><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除<span class="built_in">hash</span> key对应file的value</span></span><br><span class="line">hdel key field value</span><br></pre></td></tr></table></figure><ul><li>hexists、hlen </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断<span class="built_in">hash</span> key是否有filed</span></span><br><span class="line">hexists key filed</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">hash</span> key fiedl的数量</span></span><br><span class="line">hlen key</span><br></pre></td></tr></table></figure><ul><li>批量操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 批量获取<span class="built_in">hash</span> key的一批field对应的值</span></span><br><span class="line">hmget key field1 field2...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span> key的一批field value</span></span><br><span class="line">hmset key field1 value2 ...</span><br></pre></td></tr></table></figure><ul><li>其他命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回<span class="built_in">hash</span> key对应的所有field和value</span></span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回所有的值</span></span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回所有的field</span></span><br><span class="line">hkeys key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>和string 的使用场景类似、数据缓存等</li></ul><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list 队列结构：有序、可重复、左右两边插入弹出</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-list.jpg" alt></p><hr><ul><li>增加操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从列表左边插入值</span></span><br><span class="line">lpush key val1 val2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表右边插入值</span></span><br><span class="line">rpush key val1 val2 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在列表指定值的前|后插入新的值</span></span><br><span class="line">linsert key before|after value newvalue</span><br></pre></td></tr></table></figure><ul><li>删除操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从列表左边弹出一个元素</span></span><br><span class="line">lpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表右边弹出一个元素</span></span><br><span class="line">rpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表删除所有value相等的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count=0删除所有、count&gt;0左边开始删除、count&lt;0右边开始删除</span></span><br><span class="line">lrem key count value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保留指定索引内的列表元素</span></span><br><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure><ul><li>查询操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取索引内范围的元素</span></span><br><span class="line">lrange key start end(包含)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据指定索引获取元素</span></span><br><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表长度</span></span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><ul><li>修改操作 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置指定索引的值</span></span><br><span class="line">lset key index newvalue</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>用户抢购进入排队状态（加入队列）</li><li>你关注的人更新文博（LPUSH可看到最新状态、lrange范围查询）</li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>集合特点：无序、无重复、可进行集合间操作（交集、并集）</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-set.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 向集合key添加元素（如果元素存在添加失败）</span></span><br><span class="line">sadd key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合中某个元素</span></span><br><span class="line">srem key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算集合size</span></span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断元素是否在在集合中存在</span></span><br><span class="line">sismember key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中挑选一个元素（不删除）</span></span><br><span class="line">srandmember key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中弹出一个元素(删除)</span></span><br><span class="line">spop key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出集合中所有元素</span></span><br><span class="line">smembers key</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用命令&quot;&gt;&lt;a href=&quot;#通用命令&quot; class=&quot;headerlink&quot; title=&quot;通用命令&quot;&gt;&lt;/a&gt;通用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;keys[patten]（查看所有的key）&lt;/li&gt;
&lt;li&gt;dbsiz（查看所有key的大小）&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis初识</title>
    <link href="http://yoursite.com/2019/04/05/redis%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2019/04/05/redis初识/</id>
    <published>2019-04-05T14:50:33.000Z</published>
    <updated>2019-04-14T04:57:49.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。</p><h1 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h1><ul><li>多种数据结构<br><img src="http://poporz7f8.bkt.clouddn.com/redis-datastructure.jpg" alt></li></ul><hr><blockquote><p>其中还扩展数据结构有</p></blockquote><blockquote><p>bitmaps：位图 ，（布隆过滤器可使用位图来实现）</p></blockquote><blockquote><p>hyperloglog：超小内存唯一值计数（12k</p></blockquote><blockquote><p>geo：地理信息位置</p></blockquote><ul><li>速度快</li></ul><blockquote><p>redis可达到10w读写速度，将数据存储到内存中，使用C语言编写（50000 line），单线程</p></blockquote><ul><li>持久化</li><li>功能丰富</li><li>主从复制</li><li>高可用、分布式</li></ul><h1 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h1><ul><li><p>缓存系统</p><blockquote><p>先从cache中获取数据，如果有返回数据，没有则从数据库中取数据并加入到缓存中</p></blockquote></li><li><p>计数器</p></li><li><p>消息队列系统</p></li><li><p>排行榜</p></li><li><p>社交网络</p></li><li><p>实时系统</p></li></ul><h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><blockquote><p><a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 依赖</span></span><br><span class="line">yum install gcc-c++</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到redis目录编译，会产生redis.conf、src等文件</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装到指定目录产生bin文件</span></span><br><span class="line">make install PREFIX=/install/redis</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果客户端连接不了请关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><ul><li><p>bin目录下6个可执行文件</p><blockquote><p>redis-server：redis服务器 </p></blockquote><blockquote><p>redis-cli：redis命令行客户端</p></blockquote><blockquote><p>redis-benchmark：基准测试</p></blockquote><blockquote><p>redis-check-aof：持久化aof文件修复工具</p></blockquote><blockquote><p>redis-check-dump：持久化rdb文件修复工具</p></blockquote><blockquote><p>redis-sentinel：sentinel服务器（2.8version）</p></blockquote></li></ul><ul><li><p>三种启动redis方式</p><blockquote><p>redis-serve（默认配置） </p></blockquote><blockquote><p>redis-serve – port 6380（动态参数启动，默认端口是6379）</p></blockquote><blockquote><p>redis-serve &amp;confipath（参与配置文件启动）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。&lt;/p&gt;
&lt;h1 id=&quot;redis的特性&quot;
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
