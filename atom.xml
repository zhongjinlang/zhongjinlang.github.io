<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-08T15:23:24.741Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis集群——sentinel</title>
    <link href="http://yoursite.com/2019/04/08/redis%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94sentinel/"/>
    <id>http://yoursite.com/2019/04/08/redis集群——sentinel/</id>
    <published>2019-04-08T08:59:57.000Z</published>
    <updated>2019-04-08T15:23:24.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制问题引入"><a href="#主从复制问题引入" class="headerlink" title="主从复制问题引入"></a>主从复制问题引入</h1><p>当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。我们希望可做到高可用的故障转移，也就是说如果有一个服务宕机了，希望有另一台服务可顶替。通俗的将就是将故障进行转移，保证redis整体服务是可运行的</p><h2 id="master故障"><a href="#master故障" class="headerlink" title="master故障"></a>master故障</h2><p>如果slave出现故障，问题并不是很大，因为可以从master进行读写操作。如果master故障了，那么其他从节点将会断开与master的连接，此时客户端只可进行读的操作<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault.jpg" alt></p><h2 id="master宕机处理"><a href="#master宕机处理" class="headerlink" title="master宕机处理"></a>master宕机处理</h2><p>首先我们要保证有写数据，可以将一台slave成为master，另外一台成为从节点<br><img src="http://poporz7f8.bkt.clouddn.com/redis-fault-success.jpg" alt></p><p>上述问题并没有解决自动故障转移的主要问题：自动让slave成为master，让其他slave同步master</p><h1 id="redis-sentinel架构"><a href="#redis-sentinel架构" class="headerlink" title="redis sentinel架构"></a>redis sentinel架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel1.jpg" alt></p><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案, Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。它的主要功能有如下几点</p><ol><li><p>不时地监控redis是否按照预期良好地运行</p></li><li><p>如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端)</p></li><li><p>能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址</p></li></ol><h2 id="sentinel核心配置"><a href="#sentinel核心配置" class="headerlink" title="sentinel核心配置"></a>sentinel核心配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 去掉注释查看文件</span></span><br><span class="line">[root@localhost config]# cat sentinel.conf | grep -v "#" | grep -v "^$"</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinel默认端口</span></span><br><span class="line">port 26379</span><br><span class="line">dir /tmp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 监控主节点 2标识你需要几个sentinel对master进行发现问题</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障时间</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制同时并发执行</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 故障转移时间</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><h1 id="sentinel实验"><a href="#sentinel实验" class="headerlink" title="sentinel实验"></a>sentinel实验</h1><p>实现如下配置</p><ul><li>master-7000、slave-7001、slave-7002</li><li>sentinel-26379(默认端口)、sentinel-26380、sentinel-26381</li></ul><h2 id="开启主从节点"><a href="#开启主从节点" class="headerlink" title="开启主从节点"></a>开启主从节点</h2><h3 id="redis-7000-conf-master"><a href="#redis-7000-conf-master" class="headerlink" title="redis-7000.conf(master)"></a>redis-7000.conf(master)</h3><blockquote><p>vim redis-{port}.conf: 分别添加如下配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line">logfile "7000.log"</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="redis-7001-conf-slave"><a href="#redis-7001-conf-slave" class="headerlink" title="redis-7001.conf(slave)"></a>redis-7001.conf(slave)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7001.pid</span><br><span class="line">logfile "7001.log"</span><br><span class="line">dir ./</span><br><span class="line">slaveof 192.168.211.134 7000</span><br></pre></td></tr></table></figure><blockquote><p>redis-7002.conf修改端口即可</p></blockquote><h3 id="启动一主二从"><a href="#启动一主二从" class="headerlink" title="启动一主二从"></a>启动一主二从</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-server redis-7000.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7001.conf </span><br><span class="line">[root@localhost config]# redis-server redis-7002.conf </span><br><span class="line">[root@localhost config]# redis-cli -p 7000 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7001 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7002 ping</span><br><span class="line">PONG</span><br><span class="line">[root@localhost config]# redis-cli -p 7000 info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.211.134,port=7001,state=online,offset=197,lag=0</span><br><span class="line">slave1:ip=192.168.211.134,port=7002,state=online,offset=197,lag=1</span><br></pre></td></tr></table></figure><h2 id="开启sentinel"><a href="#开启sentinel" class="headerlink" title="开启sentinel"></a>开启sentinel</h2><h3 id="sentinel-26379-conf"><a href="#sentinel-26379-conf" class="headerlink" title="sentinel-26379.conf"></a>sentinel-26379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir /tmp</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><blockquote><p>其他sentinel-26380.conf、sentinel-26381.conf修改端口即可</p></blockquote><h2 id="测试sentinel"><a href="#测试sentinel" class="headerlink" title="测试sentinel"></a>测试sentinel</h2><h3 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26379.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26380.conf </span><br><span class="line">[root@localhost config]# redis-sentinel redis-sentinel-26381.conf</span><br></pre></td></tr></table></figure><h3 id="sentinel-info"><a href="#sentinel-info" class="headerlink" title="sentinel info"></a>sentinel info</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 26379</span><br><span class="line">127.0.0.1:26379&gt; set hello world</span><br><span class="line">(error) ERR unknown command 'set'</span><br><span class="line">127.0.0.1:26379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:26379&gt; info</span><br><span class="line"><span class="meta">#</span><span class="bash"> Sentinel 的一些信息</span></span><br><span class="line">sentinel_masters:1</span><br><span class="line">sentinel_tilt:0</span><br><span class="line">sentinel_running_scripts:0</span><br><span class="line">sentinel_scripts_queue_length:0</span><br><span class="line"><span class="meta">#</span><span class="bash"> sentinels=3 有三个sentinel</span></span><br><span class="line">master0:name=mymaster,status=ok,address=192.168.211.134:7000,slaves=2,sentinels=3</span><br></pre></td></tr></table></figure><blockquote><p>我们可发现sentinel监控的master和开启了多少个sentinel进行监控主从的信息</p></blockquote><h3 id="查看sentinel的变化"><a href="#查看sentinel的变化" class="headerlink" title="查看sentinel的变化"></a>查看sentinel的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# cat redis-sentinel-26379.conf </span><br><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir "/tmp"</span><br><span class="line">logfile "26379.log"</span><br><span class="line">sentinel monitor mymaster 192.168.211.134 7000 2</span><br><span class="line">sentinel config-epoch mymaster 0</span><br><span class="line">sentinel leader-epoch mymaster 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7001</span><br><span class="line"><span class="meta">#</span><span class="bash"> Generated by CONFIG REWRITE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 【关键的信息】：sentinel发现了master有两个从节点</span></span><br><span class="line">sentinel known-slave mymaster 192.168.211.134 7002</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure><blockquote><p>sentinel会自动发现slave信息</p></blockquote><h1 id="客户端连接sentinel"><a href="#客户端连接sentinel" class="headerlink" title="客户端连接sentinel"></a>客户端连接sentinel</h1><p>为什么我们不直接连接master? 因为我们采用高可用的方式，如果服务器端master宕机了，sentinel会完成自动的故障转移，那么此时客户端就不知道master节点的ip了。</p><blockquote><p>基本原理：</p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-client.jpg" alt></p><h1 id="故障转移实验"><a href="#故障转移实验" class="headerlink" title="故障转移实验"></a>故障转移实验</h1><p>我们将实现从master-7000端口中不断的set值，然后将master进程kill看看sentinel会不会自动处理故障转移</p><h2 id="mavean依赖"><a href="#mavean依赖" class="headerlink" title="mavean依赖"></a>mavean依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ResisSentinelTest-java"><a href="#ResisSentinelTest-java" class="headerlink" title="ResisSentinelTest.java"></a>ResisSentinelTest.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResisSentinelTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisPipelineTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26379"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26380"</span>);</span><br><span class="line">        sentinels.add(<span class="string">"192.168.211.134:26381"</span>);</span><br><span class="line">        JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取连接</span></span><br><span class="line">                jedis = sentinelPool.getResource();</span><br><span class="line">                <span class="comment">// 不断的set值</span></span><br><span class="line">                <span class="keyword">int</span> index = <span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</span><br><span class="line">                String key = <span class="string">"k-"</span> + index;</span><br><span class="line">                String value = <span class="string">"v-"</span> + index;</span><br><span class="line">                jedis.set(key, value);</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.info(<span class="string">"&#123;&#125; value is &#123;&#125; "</span>, key, jedis.get(key));</span><br><span class="line">                &#125;</span><br><span class="line">                TimeUnit.MICROSECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>执行上述代码之后会不断的输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_1.jpg" alt></p></li><li><p>当我们在进行kill master之后控制台会输出如下日志信息<br><img src="http://poporz7f8.bkt.clouddn.com/redis-sentinel-log_2.jpg" alt></p></li></ul><p><strong>当过了30秒之后sentinel会进行故障转移，恢复set的操作</strong></p><ul><li>我们可以查看salve-7001和slave和7002哪个成为了master<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 7002</span><br><span class="line">127.0.0.1:7002&gt; info replication</span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br></pre></td></tr></table></figure></li></ul><h1 id="sentinel原理"><a href="#sentinel原理" class="headerlink" title="sentinel原理"></a>sentinel原理</h1><p>sentinel可以对redis节点作失败判定以及故障转移，在sentinel内部有三个定时任务作为基础来实现上述所描述的</p><ul><li><p>每10秒每个sentinel对master和slave执行info</p><blockquote><p>发现slave</p></blockquote><blockquote><p>确认主从关系</p></blockquote></li><li><p>每两秒每个sentinel和master进行发布订阅模式的形式，达成整体的信息交互平台</p><blockquote><p>通过<em>sentinel</em>:hello频道交互</p></blockquote><blockquote><p>交互对节点的”看法”和自身信息</p></blockquote></li><li><p>每一秒每个sentinel对其他sentinel和redis执行ping</p><blockquote><p>心跳检测、失败判定的依据</p></blockquote></li></ul><h2 id="主观下线-客观下线"><a href="#主观下线-客观下线" class="headerlink" title="主观下线|客观下线"></a>主观下线|客观下线</h2><p>sentinel核心配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure></p><h3 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor [master-group-name] [ip] [port] [quorum]</span><br></pre></td></tr></table></figure><p>这一行用于告诉Redis监控一个master叫做mymaster，它的地址在127.0.0.1，端口为6379，票数是2，<strong>票数个数建议为奇数, 且个数=1/2+1</strong></p><p><strong>quorun</strong>：票数，sentinel需要协商同意master是否可到达的数量，举个例子，redis集群中有5个sentinel实例，其中master挂掉啦，如果这里的票数是2，表示有2个sentinel认为master挂掉啦，才能被认为是正真的挂掉啦</p><h3 id="down-after-milliseconds"><a href="#down-after-milliseconds" class="headerlink" title="down-after-milliseconds"></a>down-after-milliseconds</h3><p>sentinel会向master发送心跳PING来确认master是否存活，如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会<strong>主观</strong>地认为这个master已经不可用了。而这个down-after-milliseconds就是用来指定这个“一定时间范围”的，单位是毫秒。</p><p><strong>主观下线</strong>：每个sentinel节点对redis节点的失败的”偏见”</p><p><strong>客观下线</strong>：所有sentinel节点对redis节点失败”达成共识”（超过票数个统一）</p><h3 id="parallel-syncs"><a href="#parallel-syncs" class="headerlink" title="parallel-syncs"></a>parallel-syncs</h3><p>在发生failover主从切换时，这个选项指定了最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成主从故障转移所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为主从同步而不可用。可以通过将这个值设为1来保证每次只有一个slave处于不能处理命令请求的状态。</p><h2 id="领导则选举"><a href="#领导则选举" class="headerlink" title="领导则选举"></a>领导则选举</h2><p>我们知道之际上完成故障转移的任务只需要一个sentinel即可。选举通过sentinel is-master-down-by-addr命令都希望成为领导者，此命令的作用: 一<strong>确认下线判定</strong>，二是进行<strong>领导者选举</strong></p><h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>1）每个做主观下线的sentinel节点向其他sentinel节点发送上面那条命令，要求将它设置为领导者。</p><p>2）收到命令的sentinel节点如果还没有同意过其他的sentinel发送的命令（还未投过票），那么就会同<br>意，否则拒绝。</p><p>3）如果该sentinel节点发现自己的票数已经过半且达到了quorum的值，就会成为领导者</p><p>4）如果这个过程出现多个sentinel成为领导者，则会等待一段时间重新选举</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>redis-sentinel是redis实现高可用的方案：故障发现、故障自动转移、配置中心、客户端通知</p></li><li><p>redis-sentinel是redis2.8版本才开始正式使用 </p></li><li><p>尽可能在不同的物理机上部署redis-sentinel所有节点</p></li><li><p>redis-sentinel中的sentinel节点个数应该为大于等于3且最好为奇数</p></li><li><p>客户端初始化连接的是sentinel节点集合，不再是具体的redis节点，但是sentinel只是配置中心不是代理</p></li><li><p>redis-sentinel通过三个定时任务实现了sentinel节点对主从节点、其余sentinel节点的监控</p></li><li><p>redis-sentinel在对节点做失败判定时分为主管下线和和客观下线</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制问题引入&quot;&gt;&lt;a href=&quot;#主从复制问题引入&quot; class=&quot;headerlink&quot; title=&quot;主从复制问题引入&quot;&gt;&lt;/a&gt;主从复制问题引入&lt;/h1&gt;&lt;p&gt;当master和slave节点出现故障时，我们需要如何处理呢？首先我们知道故障是不可避免的。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis集群——复制</title>
    <link href="http://yoursite.com/2019/04/07/redis%E9%9B%86%E7%BE%A4%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/07/redis集群——复制/</id>
    <published>2019-04-07T01:45:28.000Z</published>
    <updated>2019-04-08T15:23:08.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-master-slave.jpg" alt></p><p>单机部署redis所存在的问题：机器故障数据转移、容量瓶颈、QPS瓶颈</p><p>主节点master负责<strong>写数据</strong>，从节点slave负责<strong>读数据</strong>，主节点定期把数据同步到从节点保证数据的一致性</p><blockquote><p>主从复制的作用：数据副本（高可用分布式基础）、读写分离提高性能</p></blockquote><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><p><strong>命令slaveof</strong>和配置文件的方式</p><h3 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a>slaveof</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6380节点（从）复制6379节点（主）</span></span><br><span class="line">redis-6380 &gt; slaveof 192.168.211.134:6379 OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消复制（不希望成为从），此时会断开连接（从数据并不会丢失，而是主的数据不会同步给从）</span></span><br><span class="line">redis-6380 &gt; slaveof no one OK</span><br></pre></td></tr></table></figure><h2 id="主从复制实验"><a href="#主从复制实验" class="headerlink" title="主从复制实验"></a>主从复制实验</h2><ul><li><p>我们通过配置文件的方式实现 6379作为主节点、6380为从节点</p></li><li><p>其中有两个中要的配置slaveof ip port、slave-read-only yes（期望从节点只作读操作）目的是达到主从复制数据的一致性效果。保证主节写操作，而从节点只作为读操作</p></li><li><p>cp redis.conf两份分别命名为 redis-6379.conf、redis-6380.conf</p></li></ul><h3 id="redis-6379-conf"><a href="#redis-6379-conf" class="headerlink" title="redis-6379.conf"></a>redis-6379.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 后台启动</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta">#</span><span class="bash">进程id</span></span><br><span class="line">pidfile /var/run/redis-6379.pid </span><br><span class="line"><span class="meta">#</span><span class="bash"> 主节点密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件</span></span><br><span class="line">logfile "6379.log"</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb文件</span></span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置主从关系</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 只读，主节点不关心</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line"></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分片信息</span></span><br><span class="line">127.0.0.1:6379&gt; info replication </span><br><span class="line">role:master # 主节点</span><br><span class="line">connected_slaves:0 # 所连接的从节点个数</span><br></pre></td></tr></table></figure></li></ul><h3 id="redis-6380-conf"><a href="#redis-6380-conf" class="headerlink" title="redis-6380.conf"></a>redis-6380.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 开启守护者进程</span><br><span class="line">pidfile /var/run/redis-6380.pid #进程id</span><br><span class="line">port 6380</span><br><span class="line">logfile "6380.log"</span><br><span class="line">dbfilename dump-6380.rdb # rdb文件</span><br><span class="line">slaveof 192.168.211.134 6379 # 成为6379的从节点</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从节点只作为读操作</span></span><br><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure><ul><li>开启服务并连接客户端<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">127.0.0.1:6379&gt; info replication # 查看分片信息</span><br><span class="line">role:slave # 已成为从节点</span><br><span class="line">master_host:192.169.211.134 # 主节点地址</span><br><span class="line">master_port:6379 # 主节点端口</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>从主节点6379端口中set值，从节点会复制主节点的数据<br><img src="http://poporz7f8.bkt.clouddn.com/redis-test.jpg" alt></p><h1 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h1><p>主从复制的读写分离实际上内部使用命令的方式进行数据的同步，我们可以分析两个日志文件</p><h2 id="6379-log"><a href="#6379-log" class="headerlink" title="6379.log"></a>6379.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6379log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示6380需要进行复制操作</span></span><br><span class="line">Slave 192.168.211.134:6380 asks for synchronization</span><br><span class="line"><span class="meta">#</span><span class="bash"> resync 全量复制操作</span></span><br><span class="line">Full resync requested by slave 192.168.211.134:6380</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以发现复制操作是使用RDB进行实现的，实际就是将快照进行同步</span></span><br><span class="line">Starting BGSAVE for SYNC with target: disk</span><br></pre></td></tr></table></figure><h2 id="6380-log"><a href="#6380-log" class="headerlink" title="6380.log"></a>6380.log</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis6380log.jpg" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接主节点</span></span><br><span class="line">Connecting to MASTER 192.168.211.134:6379</span><br><span class="line"><span class="meta">#</span><span class="bash"> 主从复制</span></span><br><span class="line">MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master的runid（每一个redis启动时的随机ID）</span></span><br><span class="line">Full resync from master: f45a09af5ab5fe887ad7a33b451e4955b1dafebd:1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拿到master节点数据(rbd)</span></span><br><span class="line">receiving 31 bytes from master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 清空之前的数据(全量复制的情况下)</span></span><br><span class="line">Flushing old data</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载rdb</span></span><br><span class="line">Loading DB in memory</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载成功</span></span><br><span class="line">Finished with success</span><br></pre></td></tr></table></figure><h2 id="验证Flushing-old-data"><a href="#验证Flushing-old-data" class="headerlink" title="验证Flushing old data"></a>验证Flushing old data</h2><p>我们可以看到上述6380日志，当拿到master节点之后做的事情，清空旧的数据、加载RDB，如下实验验证是否安装该流程进行的</p><ul><li><p>先将6380成为master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> slaveof no one</span></span><br></pre></td></tr></table></figure></li><li><p>切换到6379添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">mset a b c d</span><br></pre></td></tr></table></figure></li><li><p>再切换到6380执行如下操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时成为master当然不能同步数据</span></span><br><span class="line">keys *</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置一些数据</span></span><br><span class="line">127.0.0.1:6380&gt; set abc6380 hello</span><br><span class="line">127.0.0.1:6380&gt; slaveof 192.168.211.134 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) "c"</span><br><span class="line">2) "a"</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>我们可以看到当slaveof继续成为从节点时候，再获取数据时之前的abc6379已被删除</p></blockquote><h1 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h1><p>我们在分析日志的时候发现，master有resync(全量复制)、slave有获取masterRUNID的一些操作，引入我们引入两个概念 <strong>runid</strong> 以及 <strong>偏移量</strong></p><h2 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h2><p>每一个redis服务启动时，都会随机一个字符串id，作为一个标识。如果重启之后，runid会消失</p><ul><li>查看runid<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost config]# redis-cli -p 6379 info server | grep run</span><br><span class="line">run_id:f45a09af5ab5fe887ad7a33b451e4955b1dafebd</span><br><span class="line">[root@localhost config]# redis-cli -p 6380 info server | grep run</span><br><span class="line">run_id:e93481fdcc9e791516c77f8a61a3e7e5e2db4f9e</span><br></pre></td></tr></table></figure></li></ul><p>当复制时发现和之前的 run_id不同时（重启），将会对数据全量同步，一般用于初次复制场景</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>一个数据写入量的字节(如 set a b)，此时从节点会同步记录偏移量，当主从偏移量达到一至时，那么就完成了数据同步的过程。简言之：通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致 </p><blockquote><p>如果主、从偏移量不一至。master &gt; slave可能会出现主从不一致</p></blockquote><ul><li>查看偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:48425</span><br></pre></td></tr></table></figure></li></ul><p>当我们添加值时，偏移量也会随着增加</p><ul><li>查看主、从偏移量<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">master_repl_offset:49146</span><br><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6380 info replication</span><br><span class="line">slave_repl_offset:49170</span><br></pre></td></tr></table></figure></li></ul><p>为什么主从偏移量不一致呢？实际上主从的偏移量是一个同步更新的状态，从节点会将一些状态向主节点上报。我们也可查看主从的同步状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-3.0.7]# redis-cli -p 6379 info replication</span><br><span class="line">slave0:ip=192.168.211.134,port=6380,state=online,offset=49482,lag=2</span><br><span class="line">master_repl_offset:49482</span><br></pre></td></tr></table></figure></p><blockquote><p>通常offset差距不会太大，否则可能有其他问题如网络、阻塞</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-slavecopy.jpg" alt></p><p>如果对于一个存了很多数据的master，slave期望复制master中的数据，并且这些数据是时刻同步的、完整的。这样就可达到完整的数据同步效果。</p><ul><li>首先将本身的RDB文件同步给slave，为了达到时刻同步，在此期间，master写入的命令也会记录下来。当slave将RDB加载完后，会通过偏移量的对比将这期间master写入的值同步给slave</li></ul><ol><li><p>首先slave发送命令psync ? -1，参数1:runid，参数2：偏移量（报告主节点偏移量）。由于第一次复制不知道runid和偏移量，所以参数为?和-1</p></li><li><p>master接收到此命令，将runid和偏移量发送给slave</p></li><li><p>slave保存master的基本信息</p></li><li><p>master会执行bgsave（rdb生成）</p></li></ol><blockquote><p>此时怎么将RDB发送给salve呢？master内部有复制缓冲区reple_back_buffer，它可记录最新的数据</p></blockquote><ol start="5"><li><p>经过了缓冲区的过滤，将RDB和缓存的一些信息发送给slave(5-6步骤)</p></li><li><p>slave先清空自己old数据</p></li><li><p>加载RDB以及缓存数据完成同步</p></li></ol><h1 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h1><p>经过上述分析，我们可以明显感受到，全量复制的开销是巨大的。有如下几个问题</p><ul><li>bgsave时间，需要生成RDB</li><li>RDB文件网络传输时间</li><li>slave清空old的时间</li><li>slave加载RDB的时间</li><li>可能的AOF重写时间</li></ul><h2 id="为什么需要部分复制"><a href="#为什么需要部分复制" class="headerlink" title="为什么需要部分复制"></a>为什么需要部分复制</h2><p> 在redis2.8版本之前，如果master和slave之间的网络发生了抖动连接断开，就会导致slave完全不知道master的动作，同步就会出问题，而为了保证数据一致，等网络恢复后进行一次全量复制。而全量复制的开销是很大的，redis2.8版本就提个了一个部分复制的功能</p><h2 id="部分复制的实现原理"><a href="#部分复制的实现原理" class="headerlink" title="部分复制的实现原理"></a>部分复制的实现原理</h2><p>当master和slave断开连接时，master会将期间所做的操作记录到复制缓存区当中（可以看成是一个队列，其大小默认1M）。待slave重连后，slave会向master发送psync命令并传入offset和runId，这时候，如果master发现slave传输的偏移量的值，在缓存区队列范围中，就会将从offset开始到队列结束的数据传给slave，从而达到同步，降低了使用全量复制的开销</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://poporz7f8.bkt.clouddn.com/redis-master-slave.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>elasticsearch+filebeat+kibana日志收集</title>
    <link href="http://yoursite.com/2019/04/06/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/04/06/ELK日志收集/</id>
    <published>2019-04-06T13:18:14.000Z</published>
    <updated>2019-04-07T01:08:19.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>对大规模日志数据进行采集、追踪、分析及处理</p><p>目前主流的分布式日志框架有：</p><ul><li><p>Logstash ELK(ElasticsSearch, Logstash, Kibana) – 一套强大的日志收集系统，由于Logstash消耗资源过大，官方推荐使用filebeat取代</p></li><li><p>Flume – 由Apache基金会提供的一个分布式、高可靠、高可用的服务</p></li><li><p>filebeat用于日志的收集、elasticsearch用于存储日志、kibana实现数据的展示</p></li><li><p>download: <a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">https://www.elastic.co/cn/downloads/past-releases</a></p></li></ul><h1 id="elasticsearch-install"><a href="#elasticsearch-install" class="headerlink" title="elasticsearch install"></a>elasticsearch install</h1><ul><li><p>es启动不能使用root，因此需要创建一个用户组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd es</span><br><span class="line">useradd es -g es</span><br><span class="line">passwd es</span><br></pre></td></tr></table></figure></li><li><p>切换root进入es目录为es文件给予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R es:es es es-5.6.16</span><br></pre></td></tr></table></figure></li><li><p>修改/conf/elasticsearch.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Network </span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">network.host: ip  </span><br><span class="line"><span class="meta">#</span> 默认http端口</span><br><span class="line">http.port: 9200</span><br><span class="line"><span class="meta">#</span> 默认tcp端口</span><br><span class="line">transport.tcp.port: 9300</span><br></pre></td></tr></table></figure></li><li><p>修改jvm内存大小 /conf/jvm.options</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xms1g</span><br></pre></td></tr></table></figure></li><li><p>由于es启动需要开启大量线程，需要修改系统文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vi /etc/security/limits.conf</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 131072</span><br><span class="line">* soft nproc 2048</span><br><span class="line">* hard nproc 4096</span><br><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> cd /etc/security/limits.d</span><br><span class="line">vi 20-nproc.conf</span><br><span class="line">root       soft    nproc     2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> vi /etc/sysctl.conf</span><br><span class="line">vm.max_map_count=655360</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>su es &gt; ./elasticsearch 如果启动不了设置防火墙</p></blockquote><h1 id="filebeat"><a href="#filebeat" class="headerlink" title="filebeat"></a>filebeat</h1><p>Filebeat是一个轻量型日志采集器，在你的服务器上安装客户端后，filebeat会监控日志目录或者指定的日志文件，追踪读取这些文件（追踪文件的变化，不停的读），并且转发这些信息到elasticsearch或者logstarsh中存放</p><ul><li>安装完之后编辑核心配置文件filebeat.yml</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 指定被探测的日志文件, 可添加多个该配置</span><br><span class="line">paths:</span><br><span class="line">    - /install/logs/*.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 配置多行合并</span><br><span class="line">multiline.pattern: ^\[</span><br><span class="line">multiline.negate: true</span><br><span class="line">multiline.match: after    </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 指定es的位置，将日志收集到es存储</span><br><span class="line">output.elasticsearch:</span><br><span class="line"><span class="meta">  #</span> Array of hosts to connect to.</span><br><span class="line">  hosts: ["192.168.211.134:9200"]</span><br></pre></td></tr></table></figure><blockquote><p>./filebeat 启动</p></blockquote><blockquote><p>日志收集测试 : 当配置的探测日志文件发生变化时，filebeat会将数据发送给ES进行存储</p></blockquote><h1 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h1><p>kibana可取代elastic-head，提供了更为专业的可视化界面、日志分析系统，它是ES的成员之一</p><ul><li>安装完之后配置kibana.yml核心配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 默认端口</span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="meta">#</span> 绑定ip</span><br><span class="line">server.host: "192.168.211.134"</span><br><span class="line"><span class="meta">#</span> 指定es的地址</span><br><span class="line">elasticsearch.url: "http://192.168.211.134:9200"</span><br><span class="line"><span class="meta">#</span> 启动</span><br><span class="line">cd bin &gt; ./kibana</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h1&gt;&lt;p&gt;对大规模日志数据进行采集、追踪、分析及处理&lt;/p&gt;
&lt;p&gt;目前主流的分布式日志框架有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Logstash E
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis的持久化</title>
    <link href="http://yoursite.com/2019/04/06/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/06/redis的持久化/</id>
    <published>2019-04-05T16:55:05.000Z</published>
    <updated>2019-04-05T17:57:02.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h1><p>redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 <strong>Redis</strong> 提供了两种<strong>持久化</strong>的方案，将内存中的数据保存到磁盘中，避免数据的丢失</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><blockquote><p>该机制使用快照方式，在指定的时间内将内存中的数据写入到硬盘（rdb文件），也可手动执行命令</p></blockquote><ul><li>文件策略：如果存在老的RDB文件，会进行替换</li><li>优点：RBD作为一个备份文件容易恢复，性能好，通过子进程fork生成rdb，用于备份</li><li>缺点：容易造成数据丢失，如果fork花费时间大，那么将会阻塞redis服务、耗时耗性能</li></ul><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><ul><li>save命令（同步 ） — 可能会产生阻塞</li><li>bgsave命令（异步）— <strong>创建一个子进程fork() </strong>生成rdb文件（阻塞发生在<br>fork），创建完毕返回给主进程bgsave successfully</li><li>自动 — 根据save配置自动生成，例如如果在60秒内改变了1w条数据则生成rdb、300-10、900-1满足任一个条件（底层使用fork）</li></ul><p>在redis.conf中节点为SNAPSHOTTING中有如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"><span class="meta">#</span><span class="bash"> bgsave发生错误是否停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rdb是否采用压缩格式</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd校验</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认rbd文件名，在/bin目录</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志等文件存储位置</span></span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p>推荐配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不采用自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> rbd文件名称采用+端口形式区分</span></span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb</span><br><span class="line"><span class="meta">#</span><span class="bash"> 建议指定容量较大硬盘位置</span></span><br><span class="line">dir /bigdiskpath</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其他默认</span></span><br></pre></td></tr></table></figure><blockquote><p>不容忽略的方式：主从复制、debug reload、shutdown可能会触发</p></blockquote><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>RDB快照方式并不是很可靠，如果服务器宕机，那么最新的数据就会丢失。而AOF文件提供一种更为可靠的的持久化方式。当进行set操作时，会追加到AOF文件中。当redis重启之后，AOF中的命令会被重新执行一次，重建数据</p><h2 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h2><p><img src="http://poporz7f8.bkt.clouddn.com/redis-aof.jpg" alt></p><ul><li>always：每条命令都会持久化一次（执行写操作时，先进入缓冲区后写入到硬盘）</li><li>everysec：每秒持久化一次</li><li>no：缓冲区的刷新策略根据OS决定</li></ul><h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><p>由于每条命令都会追加到AOF文件中，随着时间的推移，AOF文件必然逐渐变大。AOF重写解决了这一问题</p><ul><li>例 ：命令优化、过期数据</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hello one</span><br><span class="line">set hello two</span><br><span class="line">set hello three</span><br></pre></td></tr></table></figure><p>当连续执行上诉命令最终的结果为three，而AOF并不会写入三次命令，而只会追加有效的命令set hello three</p><ul><li><p>AOF重写实现的两种方式</p><blockquote><p>bgrewriteaof命令：（类似RDB的bgsave）开启子线程完成AOF重写</p></blockquote><blockquote><p>AOF重写配置</p></blockquote></li></ul><p>在/redis.conf配置文件有APPEND ONLY MODE节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要完成aof功能开启为yes</span></span><br><span class="line">appendonly no</span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 三种同步策略</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync always</span></span><br><span class="line">appendfsync everysec -- 每秒写入（默认）</span><br><span class="line"><span class="meta">#</span><span class="bash"> appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入aof文件，不等待磁盘同步（安全，但可能阻塞）</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure><h1 id="RDB和AOF的抉择"><a href="#RDB和AOF的抉择" class="headerlink" title="RDB和AOF的抉择"></a>RDB和AOF的抉择</h1><blockquote><p>比较 </p></blockquote><p><img src="http://poporz7f8.bkt.clouddn.com/redis-rdb-aof.jpg" alt></p><blockquote><p>RDB最佳策略</p></blockquote><ul><li>“关闭”rdb</li><li>集中管理，指定时间内进行大量的数据备份</li><li>从节点开启</li><li>分片</li></ul><blockquote><p>AOF最佳策略</p></blockquote><ul><li>“开启” ： 缓存和存储</li><li>AOF重写集中管理</li><li>everysec策略</li><li>分片</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>当进行 RDB的<strong>bgsave</strong>操作和AOF的<strong>bgrewriteaof</strong>会产生子线程进行持久化的相关操作，如果fork操作执行慢，此时会将redis主线程阻塞。 </p><ul><li>查看fork持久化的时间</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latest_fork_usec</span><br></pre></td></tr></table></figure><ul><li><p>改善</p><blockquote><p>物理机或支持fork操作的虚拟化技术</p></blockquote><blockquote><p>控制redis实例最大可用内存：maxmemory</p></blockquote><blockquote><p>合理配置Linux内存分配策略：vm.overcommit_memory=1（默认0）</p></blockquote><blockquote><p>放宽AOF重写自动触发机制，不必全量复制</p></blockquote></li></ul><h2 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h2><blockquote><p>bgsave和bgrewriteaof是将内存中的数据写入到硬盘，此时会集中消耗CPU、rork内存开销、硬盘</p></blockquote><ul><li><p>优化</p><blockquote><p>不做CPU绑定，不和CPU密集部署，单机部署不要大量的AOF和RDB持久化的过程</p></blockquote><blockquote><p>echo never &gt; 追加配置文件</p></blockquote><blockquote><p>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</p></blockquote><blockquote><p>配置no-appendfsync-on-rewrite yes </p></blockquote><blockquote><p>ssd介质</p></blockquote></li></ul><h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><p>如果我们使用了AOF的每秒刷盘策略，如果fork执行大于2秒，那么主线程阻塞</p><ul><li><p>阻塞定位</p><blockquote><p>redis日志</p></blockquote><blockquote><p>info persistence收集记录</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;持久化的作用&quot;&gt;&lt;a href=&quot;#持久化的作用&quot; class=&quot;headerlink&quot; title=&quot;持久化的作用&quot;&gt;&lt;/a&gt;持久化的作用&lt;/h1&gt;&lt;p&gt;redis的所有数据存储到内存中，如果redis-server进程退出，那么数据将丢失。为了解决这个问题 &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>瑞士军刀redis</title>
    <link href="http://yoursite.com/2019/04/05/%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80redis/"/>
    <id>http://yoursite.com/2019/04/05/瑞士军刀redis/</id>
    <published>2019-04-05T14:51:03.000Z</published>
    <updated>2019-04-05T17:36:07.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><p>许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息（例如：发生时间、耗时、命令的详细信息）记录下来，Redis也提供了类似的功能。</p><ul><li>首先我们需要先了解client和serve的生命周期</li></ul><p><img src="http://poporz7f8.bkt.clouddn.com/redis-server.jpg" alt></p><hr><blockquote><p>慢查询发生在第三阶段</p></blockquote><blockquote><p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p></blockquote><h1 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h1><p>多数情况下，我们会通过请求-响应的机制来操作redis。当要执行多个命令时，由于redis是单线程的，那么下一次请求必须等待上一次请求完成之后才可继续执行。而pipeline模式，客户端可一次性将命令打包发送，</p><blockquote><p>无需等待服务端返回。这样就减少了网络往返时间。</p></blockquote><ul><li>使用传统方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        jedis.hset(<span class="string">"hashKey:"</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">//2983</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用pipeline</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pipeline pipeline = jedis.pipelined();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        pipeline.hset(<span class="string">"hashKey: "</span> + i, <span class="string">"field"</span> + i, <span class="string">"value"</span> + i); <span class="comment">// hashkey1 -&gt; field:1 : value:1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"花费时间为: "</span> + (end - start)); <span class="comment">// 38</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>位图：基于最小的单位bit进行存储，非常省空间、二进制数据存储，计算快</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取出位图指定索引的值</span></span><br><span class="line">getbit element 0</span><br></pre></td></tr></table></figure><ul><li>使用场景：独立用户统计（一亿用户，五千万独立）</li></ul><blockquote><p>set存储: 内存量200mb</p></blockquote><blockquote><p>bitmap存储：内存量12.5mb</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;慢查询&quot;&gt;&lt;a href=&quot;#慢查询&quot; class=&quot;headerlink&quot; title=&quot;慢查询&quot;&gt;&lt;/a&gt;慢查询&lt;/h1&gt;&lt;p&gt;许多存储系统（例如MySQL）提供慢查询日志帮助开发和运维人员定位系统存在的慢操作。所谓慢查询日志就是系统在命令执行前后计算每条命令
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis api</title>
    <link href="http://yoursite.com/2019/04/05/redis-api/"/>
    <id>http://yoursite.com/2019/04/05/redis-api/</id>
    <published>2019-04-05T14:50:50.000Z</published>
    <updated>2019-04-08T08:38:29.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><ul><li>keys[patten]（查看所有的key）</li><li>dbsiz（查看所有key的大小）</li><li>exists key（判断一个key是否存在）</li><li>del key [key ..] （删除key）</li><li>expice key seconds（为key设置过期时间）</li><li>type key（查看key类型）</li></ul><h1 id="内部编码架构"><a href="#内部编码架构" class="headerlink" title="内部编码架构"></a>内部编码架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-code.jpg" alt></p><hr><h1 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h1><p><img src="http://poporz7f8.bkt.clouddn.com/redis-sing.jpg" alt></p><hr><blockquote><p><strong>当我们在操作redis时，时刻要明白redis在一个瞬间只会执行一条命令，不会执行两条命令</strong></p></blockquote><ul><li><p>单线程为何快？</p><blockquote><p>纯内存</p></blockquote><blockquote><p>非阻塞IO</p></blockquote><blockquote><p>避免线程之间的切换和竞态消耗</p></blockquote></li></ul><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string的value可存储普通字符串、数值、二进制、JSON。使用场景：缓存、计数器、分布式锁</p><ul><li>基本命令  get、set、del（O1）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取key对应的value</span></span><br><span class="line">get key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置key-value</span></span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除key-value</span></span><br><span class="line">del key</span><br></pre></td></tr></table></figure><ul><li>计数命令 incr 、decr、incrby、decrby（O1）：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> key自增1，0开始</span></span><br><span class="line">incr key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反</span></span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 期望自增指定值，key自增k</span></span><br><span class="line">incrby key k</span><br><span class="line"><span class="meta">#</span><span class="bash"> 相反</span></span><br><span class="line">decrby key k</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 浮点数的自增3.5</span></span><br><span class="line">incrbyfloat key 3.5</span><br></pre></td></tr></table></figure><ul><li>其他set命令 set、setnx、setxx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不管key是否存在，都设置</span></span><br><span class="line">set key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> key不存在才进行设置（add操作）</span></span><br><span class="line">setnx key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> key存在才设置（update操作）</span></span><br><span class="line">set key value xx</span><br></pre></td></tr></table></figure><ul><li>批量处理命令：mget  mset</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 批量获取key</span></span><br><span class="line">mget key1 key2 ..</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置key-value</span></span><br><span class="line">mset key1 value1 key2 value2 ...</span><br></pre></td></tr></table></figure><blockquote><p>如果传输n次get命令，那么 <strong>n次get = n次网络时间 + n次命令时间</strong></p></blockquote><blockquote><p>如果1次将命令批量传输给服务端，那么 <strong>1次mget = 1次网络时间 + n次命令时间</strong></p></blockquote><ul><li>其他命令 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为key设置新的值，并返回之前的值</span></span><br><span class="line">getset key newvalue</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为key追加值</span></span><br><span class="line">append key value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回字符串长度</span></span><br><span class="line">strlen key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景：</p></blockquote><ul><li>记录网站每个用户个人主页的访问量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr userid:pageview</span><br></pre></td></tr></table></figure><ul><li>缓存视频的基本信息（数据源在mysql）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 从redis中取数据，存在数据直接返回，则不需要访问mysql</span><br><span class="line"><span class="number">2</span>. 若不存在，访问mysql，获取到数据，加入到redis缓存</span><br><span class="line"><span class="number">3</span>. 当下此访问此接口时，会从redis中访问</span><br></pre></td></tr></table></figure><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>hash键值结构：</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-hash.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">hash</span> key对应的field的value</span></span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置<span class="built_in">hash</span> key对应file的value</span></span><br><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除<span class="built_in">hash</span> key对应file的value</span></span><br><span class="line">hdel key field value</span><br></pre></td></tr></table></figure><ul><li>hexists、hlen </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 判断<span class="built_in">hash</span> key是否有filed</span></span><br><span class="line">hexists key filed</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取<span class="built_in">hash</span> key fiedl的数量</span></span><br><span class="line">hlen key</span><br></pre></td></tr></table></figure><ul><li>批量操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 批量获取<span class="built_in">hash</span> key的一批field对应的值</span></span><br><span class="line">hmget key field1 field2...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 批量设置<span class="built_in">hash</span> key的一批field value</span></span><br><span class="line">hmset key field1 value2 ...</span><br></pre></td></tr></table></figure><ul><li>其他命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回<span class="built_in">hash</span> key对应的所有field和value</span></span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回所有的值</span></span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回所有的field</span></span><br><span class="line">hkeys key</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>和string 的使用场景类似、数据缓存等</li></ul><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list 队列结构：有序、可重复、左右两边插入弹出</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-list.jpg" alt></p><hr><ul><li>增加操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从列表左边插入值</span></span><br><span class="line">lpush key val1 val2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表右边插入值</span></span><br><span class="line">rpush key val1 val2 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在列表指定值的前|后插入新的值</span></span><br><span class="line">linsert key before|after value newvalue</span><br></pre></td></tr></table></figure><ul><li>删除操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从列表左边弹出一个元素</span></span><br><span class="line">lpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表右边弹出一个元素</span></span><br><span class="line">rpop key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从列表删除所有value相等的值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> count=0删除所有、count&gt;0左边开始删除、count&lt;0右边开始删除</span></span><br><span class="line">lrem key count value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保留指定索引内的列表元素</span></span><br><span class="line">ltrim key start end</span><br></pre></td></tr></table></figure><ul><li>查询操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取索引内范围的元素</span></span><br><span class="line">lrange key start end(包含)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据指定索引获取元素</span></span><br><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表长度</span></span><br><span class="line">llen key</span><br></pre></td></tr></table></figure><ul><li>修改操作 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置指定索引的值</span></span><br><span class="line">lset key index newvalue</span><br></pre></td></tr></table></figure><blockquote><p>使用场景</p></blockquote><ul><li>用户抢购进入排队状态（加入队列）</li><li>你关注的人更新文博（LPUSH可看到最新状态、lrange范围查询）</li></ul><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>集合特点：无序、无重复、可进行集合间操作（交集、并集）</p><p><img src="http://poporz7f8.bkt.clouddn.com/redis-set.jpg" alt></p><hr><ul><li>基本命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 向集合key添加元素（如果元素存在添加失败）</span></span><br><span class="line">sadd key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除集合中某个元素</span></span><br><span class="line">srem key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算集合size</span></span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断元素是否在在集合中存在</span></span><br><span class="line">sismember key element</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中挑选一个元素（不删除）</span></span><br><span class="line">srandmember key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从集合中弹出一个元素(删除)</span></span><br><span class="line">spop key </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取出集合中所有元素</span></span><br><span class="line">smembers key</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;通用命令&quot;&gt;&lt;a href=&quot;#通用命令&quot; class=&quot;headerlink&quot; title=&quot;通用命令&quot;&gt;&lt;/a&gt;通用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;keys[patten]（查看所有的key）&lt;/li&gt;
&lt;li&gt;dbsiz（查看所有key的大小）&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis初识</title>
    <link href="http://yoursite.com/2019/04/05/redis%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2019/04/05/redis初识/</id>
    <published>2019-04-05T14:50:33.000Z</published>
    <updated>2019-04-05T17:34:26.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。</p><h1 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h1><ul><li>多种数据结构<br><img src="http://poporz7f8.bkt.clouddn.com/redis-datastructure.jpg" alt></li></ul><hr><blockquote><p>其中还扩展数据结构有</p></blockquote><blockquote><p>bitmaps：位图 ，（布隆过滤器可使用位图来实现）</p></blockquote><blockquote><p>hyperloglog：超小内存唯一值计数（12k</p></blockquote><blockquote><p>geo：地理信息位置</p></blockquote><ul><li>速度快</li></ul><blockquote><p>redis可达到10w读写速度，将数据存储到内存中，使用C语言编写（50000 line），单线程</p></blockquote><ul><li>持久化</li><li>功能丰富</li><li>主从复制</li><li>高可用、分布式</li></ul><h1 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h1><ul><li><p>缓存系统</p><blockquote><p>先从cache中获取数据，如果有返回数据，没有则从数据库中取数据并加入到缓存中</p></blockquote></li><li><p>计数器</p></li><li><p>消息队列系统</p></li><li><p>排行榜</p></li><li><p>社交网络</p></li><li><p>实时系统</p></li></ul><h1 id="redis的安装"><a href="#redis的安装" class="headerlink" title="redis的安装"></a>redis的安装</h1><blockquote><p><a href="http://download.redis.io/releases/" target="_blank" rel="noopener">http://download.redis.io/releases/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载</span></span><br><span class="line">wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span>到redis目录编译，会产生redis.conf、src等文件</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装到指定目录产生bin文件</span></span><br><span class="line">make install PREFIX=/install/redis</span><br></pre></td></tr></table></figure><ul><li><p>bin目录下6个可执行文件</p><blockquote><p>redis-server：redis服务器 </p></blockquote><blockquote><p>redis-cli：redis命令行客户端</p></blockquote><blockquote><p>redis-benchmark：基准测试</p></blockquote><blockquote><p>redis-check-aof：持久化aof文件修复工具</p></blockquote><blockquote><p>redis-check-dump：持久化rdb文件修复工具</p></blockquote><blockquote><p>redis-sentinel：sentinel服务器（2.8version）</p></blockquote></li></ul><ul><li><p>三种启动redis方式</p><blockquote><p>redis-serve（默认配置） </p></blockquote><blockquote><p>redis-serve – port 6380（动态参数启动，默认端口是6379）</p></blockquote><blockquote><p>redis-serve &amp;confipath（参与配置文件启动）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h1&gt;&lt;p&gt;redis是一款开源的nosql,基于key-value的键值对存储服务系统，支持多种数据结构。&lt;/p&gt;
&lt;h1 id=&quot;redis的特性&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/04/hello-world/"/>
    <id>http://yoursite.com/2019/04/04/hello-world/</id>
    <published>2019-04-04T07:41:28.062Z</published>
    <updated>2019-04-04T07:41:28.062Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
