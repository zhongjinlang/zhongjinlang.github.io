<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-25T06:49:14.195Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>J.U.C之AQS</title>
    <link href="http://yoursite.com/2019/04/25/concurrence/J.U.C%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/04/25/concurrence/J.U.C之AQS/</id>
    <published>2019-04-24T17:17:06.000Z</published>
    <updated>2019-04-25T06:49:14.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer-AQS-概述"><a href="#AbstractQueuedSynchronizer-AQS-概述" class="headerlink" title="AbstractQueuedSynchronizer(AQS)概述"></a>AbstractQueuedSynchronizer(AQS)概述</h1><p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock、Semaphore、CountDownLatch。它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><ul><li>使用Node实现FIFO队列，可以同于构建锁或其他同步装置的基础框架</li><li>利用了一个int类型表示状态</li><li>子类通过继承并通过实现它的方法管理其状态acquire和release的方法操纵状态</li><li>可以同时实现<em>排它锁</em>和<em>共享锁</em>模式（独占、共享）</li></ul><p><strong>JDK提供了许多AQS的子类，如下是常用的同步组件:</strong></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/13.jpg" alt><br>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行<br><br>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务<br><strong>使用场景</strong></p><ul><li>实现最大的并行性</li><li>开始执行前等待n个线程完成各自任务</li><li>死锁检测</li></ul><p><strong>使用演示</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定测试的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            <span class="comment">// 从线程池中开启线程</span></span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用方法</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 计数器-1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程等待</span></span><br><span class="line">        countDownLatch.await();      </span><br><span class="line">        log.info(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        exec.shutdown();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/22.jpg" alt><br>使用了await，从输出结果可看出”完成”这句话是在所有线程执行完之后才执行的。因此await可保证之前的线程执行完<br>例如我们写了很多个线程去完成一个任务，希望这个任务在指定的时间内完成可使用如下代码</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>它可控制同一时间并发线程的数目</p><ul><li>通常用于限制可以访问某些资源（物理或逻辑的）线程数目</li></ul><p><strong>面试题思考</strong><br>在很多情况下，可能有多个线程需要访问数目很少的资源。假想在服务器上运行着若干个回答客户端请求的线程。这些线程需要连接到同一数据库，但任一时刻只能获得一定数目的数据库连接。你要怎样才能够有效地将这些固定数目的数据库连接分配给大量的线程？ </p><ol><li>给方法加同步锁，保证同一时刻只能有一个人去调用此方法，其他所有线程排队等待，但是此种情况下即使你的数据库链接有10个，也始终只有一个处于使用状态。这样将会大大的浪费系统资源，而且系统的运行效率非常的低下</li><li>另外一种方法当然是使用信号量，通过信号量许可与数据库可用连接数相同的数目，将大大的提高效率和性能</li></ol><p><em>演示控制并发数量</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定测试的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 给定允许的并发数</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            <span class="comment">// 从线程池中开启线程</span></span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用方法</span></span><br><span class="line">                    <span class="comment">// 对并发控制的代码前后要包裹semaphore相关函数</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 获得许可</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/23.jpg" alt><br>输出结果可看出每一秒只有3个线程。证明了Semaphore对并发的控制</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier</p><ul><li>CountDownLatch和CyclicBarrier区别</li></ul><ol><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier</li></ol><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者</p><ul><li>Lock接口的实现之一：ReentrantLock(可重入性)</li><li>锁的实现：synchronization基于JVM</li><li>性能的区别</li><li>功能区别</li></ul><p>ReentrantLock独有的功能(CAS算法)</p><ul><li>可指定公平锁(先等待的线程先获取锁)还是非公平锁</li><li>提供了一个Condition类，可分组唤醒需要唤醒的线程</li><li>提供了中断等待锁线程的机制，lock.lockInterruptibly()</li></ul><p><em>演示使用ReentrantLock</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是哟个JUC的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量</p><p><strong>使用演示</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义读锁和写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供线程安全的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getAllKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock(); <span class="comment">// 写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>synchronization锁由JVM会自动加锁和解锁。Lock类的锁需要手动加锁和必须释放锁(放在finally保证安全)</li><li>当只有少量线程时推荐使用synchronization。当线程由趋势增长或可预算可使用ReentrantLock。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AbstractQueuedSynchronizer-AQS-概述&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer-AQS-概述&quot; class=&quot;headerlink&quot; title=&quot;AbstractQueuedSynchronizer
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程安全策略</title>
    <link href="http://yoursite.com/2019/04/24/concurrence/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/04/24/concurrence/线程安全策略/</id>
    <published>2019-04-23T17:18:43.000Z</published>
    <updated>2019-04-23T17:18:49.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><blockquote><p>不可变对象需要满足的条件</p></blockquote><ol><li>对象创建后状态不能修改</li><li>对象所有的域都是final</li><li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li></ol><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>使用final来定义不可变对象</p></blockquote><p>final关键字：类、方法、变量</p><ol><li>修饰类：不能被继承</li><li>修饰方法：锁定方法不被继承类修改</li><li>修饰变量：基本数据类型变量（数值被初始化后不能被修改）、引用类型的变量（对象被初始后不能改变引用）</li></ol><p><em>使用final修饰变量和引用</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基础数据类型不可修改</span></span><br><span class="line">        <span class="comment">//a = 2;</span></span><br><span class="line">        <span class="comment">//b = "3";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不可改变引用</span></span><br><span class="line">        <span class="comment">//map = Maps.newLinkedHashMap();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有安全发布可使用，它是线程不安全的</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>final修饰引用数据类型不可改变引用。<strong>但是可修改值</strong>，所以Map是线程不安全的类</p><h2 id="collections-unmodifiable"><a href="#collections-unmodifiable" class="headerlink" title="collections.unmodifiable"></a>collections.unmodifiable</h2><p>除了final，JDK还提供了utils.collections.unmodifiable前缀的方法来定义不可变的对象</p><p><em>使用unmodifiableMap</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 处理后的map不可被修改</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>)); <span class="comment">// 不可操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用unmodifiableMap使得map对象的值不可修改，因此上述代码达到了线程安全</p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/18.jpg" alt></p><h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>通过不可变对象在多个线程之间保证对象是线程安全的。归根到底我们是躲避了并发的问题。避免并发除了设计不可变对象，还有一个方法<em>线程封闭</em>：就是把对象封装到一个线程中，只有一个线程能看到该对象</p><p><strong>Ad-hoc</strong><br>完全使用逻辑代码来控制实现，最糟糕的方法</p><p><strong>堆栈封闭</strong><br>局部变量，多个线程访问一个方法的时候，方法中的局部变量都会被<em>拷贝</em>到一份到线程的栈中（我们经常在方法中声明的变量 ）</p><p><strong>ThreadLoad线程封闭</strong><br>特别好的封闭方法，内部实现通过一个mao，key是线程的名称，value为要封闭的对象。每一个线程中的对象都对应着它的map中的值</p><h1 id="线程不安全类与写法"><a href="#线程不安全类与写法" class="headerlink" title="线程不安全类与写法"></a>线程不安全类与写法</h1><p><em>线程不安全</em>：如果一个类的对象同时可以被多个线程访问，如果没有做同步或并发处理。那么可能就会表现出线程不安全的现象<br><br>本节介绍JDK自带的一些常用的类，这些类都不是线程安全的。</p><h2 id="StringBuilder-StringBuffer"><a href="#StringBuilder-StringBuffer" class="headerlink" title="StringBuilder | StringBuffer"></a>StringBuilder | StringBuffer</h2><ul><li>StringBuilder是线程不安全的，性能高</li><li>StringBuffer是线程安全的，性能低</li></ul><p><em>测试StringBuilder是否是线程安全</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExampele1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 输出累加字符串个数</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的个数不稳定，因此StringBuilder不是线程安全的。而采用StringBuffer是线程安全的<br><em>分析StringBuffer源码分析</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">super</span>.append(str);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p><em>SimpleDateFormat的错误写法</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormateExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 并不是局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"2019422"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码运行会有异常。这是常犯的错误，如果我们将对象声明为局部变量（堆栈封闭）就不会有这种情况了</p><p><em>正确的写法</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串累加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">    simpleDateFormat.parse(<span class="string">"2019422"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次声明一个对象来使用这样就不会出现线程不安全带来的异常</p><h2 id="ArrayList-HashSet-HashMap"><a href="#ArrayList-HashSet-HashMap" class="headerlink" title="ArrayList | HashSet | HashMap"></a>ArrayList | HashSet | HashMap</h2><p>集合类是我们最为常用的类，通常我们都将其定义在方法中（局部变量）。因此很少出现线程不安全的情况。但是一但当定义为static时且有多个线程修改时，就容易出现线程不安全的问题</p><p><strong>ArrayList</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果不是我们期望的值，说明arraylist在做add时有可能线程不安全。当然HashSet和HashMap同理</p><h1 id="写法需要多考虑"><a href="#写法需要多考虑" class="headerlink" title="写法需要多考虑"></a>写法需要多考虑</h1><p>线程不安全的写法通常是这样的：<strong>先检查再执行</strong>，例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断某个值)&#123;</span><br><span class="line">  <span class="comment">// 处理某个值...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们思考一下这种写法，当判断的时候它可能满足条件，如果两个线程都进入了判断，那么都会分别进行处理，这个时就会产生线程不安全。<br><br>出现不安全的点在于，分成了两个操作之后j即使之前的过程(判断)是线程安全的，后面(处理)也是线程安全的，但它们”间隙的过程中”并不是<em>原子性的</em><br><br>实际开发中，当我们在判断一个对象是否满足某个条件再执行某些处理的时候，需要考虑到这个对象是否是多线程共享的，如果是，那么就需要将对象加锁。或保证它们的操作具有原子性的</p><h1 id="线同步容器"><a href="#线同步容器" class="headerlink" title="线同步容器"></a>线同步容器</h1><p>针对上述线程不安全的类ArrayList、HashSet、HashMap。JDK提供了对应的线程安全的类来使用</p><h2 id="ArrayList-gt-Vectory-Stack"><a href="#ArrayList-gt-Vectory-Stack" class="headerlink" title="ArrayList &gt; Vectory | Stack"></a>ArrayList &gt; Vectory | Stack</h2><p>Vectory和stack类结构:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, ...</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用vector测试线程安全</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察其add的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>同步器也有不安全的情况</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步容器也有线程不安全的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectoryExample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 向集合中存10个值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * vector虽然能保证同一时刻只有一个线程能访问他，但是不排除如下情况</span></span><br><span class="line"><span class="comment">             * 1. 当t2线程执行到i &lt; list.size()时，t1线程也可能执行了i &lt; list.size()，它正好将当前i元素移出掉了</span></span><br><span class="line"><span class="comment">             * 2. 这个时候get方法就获取不了所删除的元素了，因此抛出数组越界异常</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 开启两个线程</span></span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">                    list.remove(i); <span class="comment">// 删除(synchronization)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">                    list.get(i); <span class="comment">// 获取(synchronization)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动两个线程</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap-gt-HashTable"><a href="#HashMap-gt-HashTable" class="headerlink" title="HashMap &gt; HashTable"></a>HashMap &gt; HashTable</h2><p>HashTable与HashMap不同，前者key和value不能为null。后者可以<br>HashTable类结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, ...</span></span><br></pre></td></tr></table></figure></p><p><strong>HashTable演示线程安全</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察其put的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure the value is not null</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure></p><h2 id="Collections-synchronization"><a href="#Collections-synchronization" class="headerlink" title="Collections.synchronization.."></a>Collections.synchronization..</h2><p>使用集合工具类来创建同步容器类</p><p><strong>将List构建为同步容器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将List构建为同步的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList() );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是线程安全的</p><h2 id="List-remove注意事项"><a href="#List-remove注意事项" class="headerlink" title="List.remove注意事项"></a>List.remove注意事项</h2><p>演示遍历集合并删除集合中指定元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectoryExample3</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三个方法：遍历集合对指定元素删除</span></span><br><span class="line">    <span class="comment">// ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer data : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Integer data = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.get(i).equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        vector.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        test1(vector);</span><br><span class="line">        <span class="comment">//test2(vector);</span></span><br><span class="line">        <span class="comment">//test3(vector);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行会出现如下异常信息<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/19.jpg" alt><br>我们进入checkForComodification观察源代码<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/20.jpg" alt><br>我们可以发现，对于一个集合遍历的同时，如果对集合进行修改的操作导致了modCount和expectedModCount不一致，从而抛出该异常</p><p><strong>结论</strong></p><ul><li>如果使用了foreach和iterator循环集合时，尽量不要在操作过程中做remove等相关的更新操作</li><li>如果需要删除，使用iterator.remove()方法，或for循环获取id再进行删除</li></ul><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>JDK提供了线程安全的集合和Map，在utils.concurrent包</p><ul><li>ArrayList-&gt; CopyOnWriteArrayList</li><li>HashSet-&gt; CopyOnWriteArraySet</li><li>TreeSet-&gt; ConcurrentSkipListSet</li></ul><p><strong>CopyOnWriteArrayList</strong><br>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而<strong>不需要加锁</strong>，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。使用场景：读多写少</p><ul><li>观察其add方法实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 采用lock锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 拷贝数组</span></span><br><span class="line">           newElements[len] = e; <span class="comment">// 创建一个数组后指向新的数组</span></span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>JDK提供的线程安全类<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/21.jpg" alt></p></li><li><p>根据实际分析变量，是否可以变为不可变对象，如果可以尽量将一个对象变为不可变对象。这样在多线程环境下就不会出现线程安全问题</p></li><li>线程封闭: 把对象封装到一个线程中，只有一个线程可以看到这个对象(ThreadLoad)</li><li>List删除指定元素要注意可能会抛出ConcurrentModificationException。解iterator.remove()方法或for循环或id再进行删除。如果在多线程环境下采用synchronization或并发容器代替vector(同步容器)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;不可变对象&quot;&gt;&lt;a href=&quot;#不可变对象&quot; class=&quot;headerlink&quot; title=&quot;不可变对象&quot;&gt;&lt;/a&gt;不可变对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不可变对象需要满足的条件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对象创建后
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>安全发布对象</title>
    <link href="http://yoursite.com/2019/04/22/concurrence/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/04/22/concurrence/安全发布对象/</id>
    <published>2019-04-22T09:34:20.000Z</published>
    <updated>2019-04-22T09:37:18.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是发布对象"><a href="#什么是发布对象" class="headerlink" title="什么是发布对象?"></a>什么是发布对象?</h1><p>发布对象：使一个对象能够被当前范围之外的外码所使用<br>对象逸出：一种错误的发布，当一个对象还没有构造完成时，就被其他线程所见了</p><p><em>不安全的发布对象案例</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] status = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStatus() &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStatus())); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">        unsafePublish.getStatus()[<span class="number">0</span>] = <span class="string">"z"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStatus())); <span class="comment">// zbc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>可能产生对象逸出</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> innerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">innerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对象没有被正确构造之前就发布对象，可能会不安全</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">innerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape); <span class="comment">// 启动了另一个对象引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h1><p>安全发布对象的四种方法：</p><ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确的构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><p>此时我们会想到采用单例模式来构建一个对象</p><h2 id="单例-懒汉模式"><a href="#单例-懒汉模式" class="headerlink" title="单例-懒汉模式"></a>单例-懒汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式：单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 单线程环境下安全，但是多线程环境不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>懒汉模式线程不安全，当然可以使用synchronization修饰方法这样就线程安全了。但是不推荐，会导致性能下降</p></blockquote><h2 id="单例-饿汉模式"><a href="#单例-饿汉模式" class="headerlink" title="单例-饿汉模式"></a>单例-饿汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汗模式：单例实例在类加载时就进行创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample2 instance = <span class="keyword">new</span> SingleExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>饿汉模式是线程安全的</p></blockquote><h2 id="优化懒汉模式"><a href="#优化懒汉模式" class="headerlink" title="优化懒汉模式"></a>优化懒汉模式</h2><p><em>使用双重检测机制</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双从检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample4.class)&#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleExample4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：必须加上volatile否则还是线程不安全的。因为可能会导致指令重排问题。而volatile有个使用场景其中的双重检测机制</p></blockquote><h2 id="枚举发布安全对象"><a href="#枚举发布安全对象" class="headerlink" title="枚举发布安全对象"></a>枚举发布安全对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回枚举声明的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingleExample5 single;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给私有变量创建对象</span></span><br><span class="line">        <span class="comment">// JVM保证这个方法只会被调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            single = <span class="keyword">new</span> SingleExample5();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回私有变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingleExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举发布安全对象是对比单例模式更为推荐的。因为它会在实际调用的时候才会初始化，不会造成资源的浪费</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>发布对象：使一个对象能够被当前范围之外的外码所使用</li><li>对象逸出：一种错误的发布，当一个对象还没有构造完成时，就被其他线程所见了</li><li>单例-懒汉模式：对象在第一次使用时进行创建，它是线程不安全的。可使用volatile的双重检测机制来实现</li><li>单例-饿汉模式：类装载的时候就进行创建，它是线程安全的</li><li>volatile可禁止指令重排，具有有序性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是发布对象&quot;&gt;&lt;a href=&quot;#什么是发布对象&quot; class=&quot;headerlink&quot; title=&quot;什么是发布对象?&quot;&gt;&lt;/a&gt;什么是发布对象?&lt;/h1&gt;&lt;p&gt;发布对象：使一个对象能够被当前范围之外的外码所使用&lt;br&gt;对象逸出：一种错误的发布，当一个对象还
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程安全性</title>
    <link href="http://yoursite.com/2019/04/22/concurrence/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/22/concurrence/线程安全性/</id>
    <published>2019-04-21T17:26:10.000Z</published>
    <updated>2019-04-22T09:21:36.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全性概述"><a href="#线程安全性概述" class="headerlink" title="线程安全性概述"></a>线程安全性概述</h1><p>当多个线程访问某个类时，不管运行时环境采用<em>何种调度方式</em>，或者这些进程将如何交替执行，并且在主调代码中<em>不需要任何额外的同步或协同</em>，这个类能表现出<em>正确的行为</em>，那么就称这个类是线程安全的<br><br>线程安全在主要三个方面体现：</p><ul><li><p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）</p></li><li><p>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）</p></li><li><p>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</p></li></ul><p>我们分别对上述概念进行一一描述</p><h1 id="原子性—Atomic"><a href="#原子性—Atomic" class="headerlink" title="原子性—Atomic"></a>原子性—Atomic</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/15.jpg" alt></p><h2 id="AtomicInteger、AtomicLong、LongAdder"><a href="#AtomicInteger、AtomicLong、LongAdder" class="headerlink" title="AtomicInteger、AtomicLong、LongAdder"></a>AtomicInteger、AtomicLong、LongAdder</h2><p>将上一篇的代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Atomic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Atomic</span></span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>此时测试数字为5000，保证了数据的一致性，我们来分析atomic源码</p></blockquote><blockquote><p>也可使用AtomicLong、LongAdder替代AtomicInteger</p></blockquote><p><strong>incrementAndGet()源码分析</strong><br><em>第一部分</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><em>第二部分</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在一个死循环内不断的尝试修改值，直到修改成功。实现原理采用CAS：</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p><blockquote><p>执行函数：CAS(V,E,N)</p><ul><li>V表示要更新的变量</li><li>E表示预期值<br>-N表示新值</li></ul></blockquote><p>CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”</p><h2 id="AtomicReference、AtomicIntegerFieldUpdater"><a href="#AtomicReference、AtomicIntegerFieldUpdater" class="headerlink" title="AtomicReference、AtomicIntegerFieldUpdater"></a>AtomicReference、AtomicIntegerFieldUpdater</h2><ul><li>AtomicReference对对象进行原子操作</li><li>AtomicIntegerFieldUpdater可以对指定类的指定 volatile int 字段进行原子更新</li></ul><p><em>AtomicReference测试原子性 </em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当为0的时候赋值2...以此类推</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count.get() ); <span class="comment">// 输出4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>AtomicIntegerFieldUpdater测试原子性</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T: 要更新的类字节码。fieleName: 类中的字段名称(volatile修饰且非static)</span></span><br><span class="line">    <span class="comment">// 原子性更新某个类的指定字段的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;ConcurrentExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(ConcurrentExample5.class, <span class="string">"count"</span>);</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentExample5 example5 = <span class="keyword">new</span> ConcurrentExample5();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果该类的字段为100那么将其更新为120</span></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"更新成功【第一次】 &#123;&#125;"</span>, example5.getCount()); <span class="comment">// info</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"更新成功【第二次】 &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"更新失败【第二次】&#123;&#125;"</span>, example5.getCount() ); <span class="comment">// info</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappend = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"执行了:&#123;&#125;"</span>, isHappend.get() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前值为false，设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (isHappend.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"方法执行了:&#123;&#125;"</span>, isHappend.get() ); <span class="comment">// 执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，让test执行5000次，因为条件成立。因为条件成立了，其他线程将不会执行</p><blockquote><p>使用场景：该如何让某一段代码只执行一次，绝对不会重复</p></blockquote><h1 id="原子性—锁"><a href="#原子性—锁" class="headerlink" title="原子性—锁"></a>原子性—锁</h1><p>原子性提供了互斥访问，同一时刻只能有一个线程进行操作。能保证同一时刻只有一个线程对其操作</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>依赖特殊的CPU指令，实现代表类有：ReentrantLock</p><h2 id="synchronization"><a href="#synchronization" class="headerlink" title="synchronization"></a>synchronization</h2><p>它是Java的关键字，依赖于JVM来实现锁。因此这个关键字<strong>作用对象的作用范围内</strong>，都是同一时刻只能有一个线程</p><ul><li><p>修饰代码块：范围【大括号括起来的代码】，作用的对象【调用这个代码块的对象】</p></li><li><p>修饰方法：范围【整个方法】，作用的对象【调用这个方法的对象】</p></li><li><p>修饰静态方法：范围【整个静态方法】，作用的对象【这个类的所有对象】</p></li><li><p>修饰类：范围【括号括起来的部分】，作用的对象【这个类的所有对象】</p></li></ul><h2 id="作用于同一个对象"><a href="#作用于同一个对象" class="headerlink" title="作用于同一个对象"></a>作用于同一个对象</h2><p>验证使用synchronization修饰方法和代码块，作用于同一个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰代码块：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample1 example1 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// 线程池：保证</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个线程输出0-9，第二个线程输出0-9…</p></blockquote><h2 id="作用于不同的对象"><a href="#作用于不同的对象" class="headerlink" title="作用于不同的对象"></a>作用于不同的对象</h2><p>验证使用不同的对象会乱序输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰代码块：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample1 example1 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// TODO 再声明一个对象</span></span><br><span class="line">        SyncExample1 example2 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">        executorService.execute(() -&gt; example2.test2()); <span class="comment">// TODO 不同的对象进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>此时输出结果为：</p></blockquote><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/16.jpg" alt></p><h2 id="作用于这个类的所有对象"><a href="#作用于这个类的所有对象" class="headerlink" title="作用于这个类的所有对象"></a>作用于这个类的所有对象</h2><p>验证使用synchronization修饰静态方法和类，作用于该类的所有对象都是线程安全的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncExample2.class)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法：作用于这个类的所有对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample2 example1 = <span class="keyword">new</span> SyncExample2();</span><br><span class="line">        <span class="comment">// TODO 再声明一个对象</span></span><br><span class="line">        SyncExample2 example2 = <span class="keyword">new</span> SyncExample2();</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test1());</span><br><span class="line">        executorService.execute(() -&gt; example2.test1()); <span class="comment">// TODO 不同的对象进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: synchronization修饰方法和代码块不同，上述代码正确顺序执行</p></blockquote><h1 id="原子性对比"><a href="#原子性对比" class="headerlink" title="原子性对比"></a>原子性对比</h1><ul><li>synchronization：不可中断的锁，适合线程竞争不激烈的情况，可读性好</li><li>Lock：可中断的锁，多样同步，竞争激烈时能维持常态</li><li>Atmoic：竞争激烈时能维持常态，比Lock性能好。但是只能同步一个值</li></ul><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>一个线程对主内存的修改可即使的被其他线程观察到<br><br>导致共享变量在线程间不可见的原因</p><ul><li>线程交叉线执行</li><li>重排序结合线程交叉线执行</li><li>共享变量更新后的值没有在工作内存与主存之间即使更新(<em>Java内存模型</em>)</li></ul><p>对于可见性JVM提供了synchronization和volatile</p><h2 id="JVM对于synchronization的两条规定"><a href="#JVM对于synchronization的两条规定" class="headerlink" title="JVM对于synchronization的两条规定"></a>JVM对于synchronization的两条规定</h2><ul><li>线程解锁前，必须把共享变量最新的值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁与解锁是同一把锁）</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。注意volatile不具备原子性</p><p>通过加入<em>内存屏障</em>和<em>静止重排序</em>优化来实现</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul><p><strong>使用场景</strong><br>首先必须具备以下条件</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p><em>1. 标记变量的值</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>2.double check</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性<br></p><p>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序</p><ul><li>通过volatile、synchronization、lock</li><li>volatile静止指令重排，保证了有序性</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>原子性：原子性主要提供了互斥访问，同一时刻只能有一个线程进行操作。JDK提供了Atomic包、CAS算法、synchronization、Lock</p></li><li><p>可见性：可见性是指一个线程对主内存的修改可以即使的被其他线程观察到。JDK提供了synchronization、volatile</p></li><li><p>有序性：happens-before原则。volatile静止指令重排，保证了有序性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程安全性概述&quot;&gt;&lt;a href=&quot;#线程安全性概述&quot; class=&quot;headerlink&quot; title=&quot;线程安全性概述&quot;&gt;&lt;/a&gt;线程安全性概述&lt;/h1&gt;&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用&lt;em&gt;何种调度方式&lt;/em&gt;，或者这些进程将如何交替执行
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>查询性能优化</title>
    <link href="http://yoursite.com/2019/04/21/mysql/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/21/mysql/查询性能优化/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T08:55:21.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第六章 查询性能优化</em><br>查询优化、索引优化、库表结构优化需要齐头并进，一个不落，本章节理解MySQL如何真正的指向查询，并明白高效的低效的原因何在</p><h1 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h1><p>如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。因此我们要优化查询实际上就是优化子任务。</p><ul><li>查询生命周期：从客户，到服务器，然后再服务器上进行解析，生成指向计划，执行，后返回结果给客户端</li><li>在每一个消耗大量实际的查询案例中，都可能看到一些不必要的额外操作、重复、某些操作执行太慢等</li></ul><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>查询性能低下最基本的原因是访问数据太多</p><ul><li>确认程序是否在检索大量不需要的数据</li><li>确认MySQL服务器层是否存在分析大量不需要的数据</li></ul><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销等</p><p><strong>查询不需要的记录</strong><br>我们通常会认为MySQL只会返回需要的数据，实际MySQL是先返回全部结果集后进行计算</p><p><strong>多表关联时返回全部列</strong><br>千万不要写select * 这样会导致查询所有关联表的字段数据。应该只取需要的列</p><p><strong>总是取出所有列</strong><br>当编写select *时，会让优化器无法完成索引覆盖扫描这类优化。但也并不是坏事，如果你的程序中使用了缓存机制，可能有其好处</p><p><strong>重复查询相同的数据</strong><br>如果不断的重复执行相同的查询，每次返回完全相同的数据。比较好的解决方案是，当初次查询的时候将这个数据缓存起来。例如用户每次评论都需要查询用户头像的URL</p><h2 id="MySQL是否存在扫描额外的记录"><a href="#MySQL是否存在扫描额外的记录" class="headerlink" title="MySQL是否存在扫描额外的记录"></a>MySQL是否存在扫描额外的记录</h2><p>衡量查询开销的三个指标</p><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul><p>它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中</p><p><strong>响应时间</strong></p><ul><li>响应时间 = 服务时间 + 排队时间<br><em>服务时间</em>：数据库处理查询真正花了多少时间，<em>排队时间</em>是指服务器因为等待某些资源而没有真正执行查询的时间——可能是I/O、锁等待…</li></ul><p><strong>扫描的行数和返回的行数</strong><br>理想情况下扫描的行数和返回的行数应该是相同的。实际情况下这种完美的事并不多</p><p><strong>扫描的行数和访问类型</strong><br>在explain语句中的type列反应了访问类型，访问类型有多种，如全表扫描(ALL)、索引扫描、范围扫描等等。这些类型速度慢到快，扫描行数多到少</p><ul><li>索引让MySQL以最高效、扫描行数最少的方式找到需要的记录</li></ul><h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>设计查询时需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在以前总是认为网络通信，查询解析是一件代价很高的事情</p><ul><li>第一种情况不必考虑，现代网络比以前快很多</li><li>第二种情况其实在MySQL设计中连接和断开连接的处理非常高效，每秒内部能扫描百万行数据</li></ul><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对一个大的查询我们可将切分小查询，例如删除旧的数据，将一个大的delete语句切分成多个较小的查询</p><ul><li>每次删除数据后，都暂停一会再做下一次删除，这样可以将服务器上原本一次性的压力分散到一个时间很长的时间段中</li></ul><h2 id="分散关联查询"><a href="#分散关联查询" class="headerlink" title="分散关联查询"></a>分散关联查询</h2><p>例如做多表关联查询，有如下语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag</span><br><span class="line"><span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag.id=tag.id</span><br><span class="line"><span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">where</span> tag.tag=<span class="string">'mysql'</span></span><br></pre></td></tr></table></figure></p><p>可以分解为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag=<span class="string">'mysql'</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span>(?)</span><br></pre></td></tr></table></figure></p><p><em>分解关联查询有如下优势：</em></p><ul><li>让缓存效率更高，方便其他程序从缓存中查询单表对象</li><li>执行单个查询减少锁的竞争</li><li>对数据拆分，做到高性能和可扩展等</li></ul><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>MySQL执行一个查询的流程：<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/mysql-phone/mysql-001.jpg" alt></p><ul><li>客户端发送一条查询语句给服务器</li><li>服务器检查查询缓存，如果缓存中有数据，直接返回。否则进入下一个阶段</li><li>服务器进行SQL解析，预处理再由优化器生成对应的执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>最后将结果返回客户端</li></ul><p>我们对其上述的流程进一步的解析</p><h2 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>在任何一个时刻，要么由服务器向客户端发送数据，要么客户端向服务器发送数据，这两个动作不能同时发生。</p><ul><li>客户端用一个单独的数据包将查询传给服务器，一旦客户端发送了请求，它能做的事就只能等待</li><li>相反，服务器响应给客户端的数据通常很多，由多个数据包组成。当开始响应时，客户端必须完整接收整个返回结果，并不能简单的取出前面几条结果（<em>类似拉取数据的过程</em>）</li><li>获取结果集看上去是从MySQL服务器获取，实际从函数库(<em>连接MySQL的库函数</em>)的缓存中获取数据</li></ul><p><strong>查询状态</strong><br>对于一个MySQL连接，或者说一个线程，任何时刻都由一个连接状态，该状态表示了MySQL当前在做什么。使用<em>SHOW FULL PROCESSLIST</em>命令查询，command列表示当前的状态。有如下状态：</p><ul><li>sleep：线程正在等待客户端发送新的请求</li><li>query：线程正在执行查询或正在将结果发送给客户端</li><li>locked：在MySQL服务层，该线程等待表锁</li><li>analyzeing and statisticas：线程正在收集存储引擎的统计信息，并生成查询的执行计划</li><li>copying to table [on disk]：线程正在执行查询，并将结果集复制到一个临时表中，这种状态通常在做group by union等 </li><li>sorting result：线程正在对结果集进行排序</li><li>sending data：多种情况，线程可能在多个状态之间传送数据，或者在生成结果集等</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>这里指的是query cache</p></blockquote><p>在解析一个查询语句之前，如果缓存开启，MySQL会优先检查这个查询是否在缓存，是直接返回，否则下一个阶段</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>此阶段进入查询优化，目标是将一个SQL转换成一个执行计划。MySQL会根据执行计划和存储引擎机械进行交互。这包含了多个子阶段：解析SQL、预处理、优化SQL执行计划，如果该过程有任何错误都可能和终止查询</p><p><strong>语法解析器和预处理</strong><br>MySQL会将SQL语句解析为对应的<em>解析树</em>，检查数据表和数据列是否存在、正确等</p><p><strong>查询优化器</strong><br>优化器是将SQL转换成执行计划，一条查询可以有多种执行方式，最后都返回相同的值。查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>MySQL根据执行计划给出的指令逐步执行，在该过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口称为’handler  API’</p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>最后一个阶段是将结果返回客户端，如果查询可以被缓存，那么MySQL在这个阶段会将结果存放到查询缓存中</p><h1 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h1><p>如果对优化器选择的执行计划不满意，可使用优化器提供的几个提示(hint)来控制最终的执行计划</p><p><em>sql_small_result和sql_big_result</em><br>sql_smqll_result告诉优化器结果集很少，可以将结果集放在内存中的索引临时表，以避免排序操作。sql_big_result则告诉优化器结果集可能非常大，建议使用磁盘临时表做排序操作</p><blockquote><p>p233介绍了更多了的hint</p></blockquote><h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><blockquote><p>本节介绍的多数优化技巧都是和特定的版本有关的，对于其他版本未必适用</p></blockquote><h2 id="优化count"><a href="#优化count" class="headerlink" title="优化count()"></a>优化count()</h2><p>count聚合函数：可统计某个列值的数量，也可统计行数</p><ul><li>使用count(*)时，并不会像我们猜想的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数</li><li>如果希望知道的是结果集的行数，最好使用count(*)，这样写意义清晰，性能也会更好</li></ul><h2 id="优化group-by和distinct"><a href="#优化group-by和distinct" class="headerlink" title="优化group by和distinct"></a>优化group by和distinct</h2><p>使用sql_big_result和sql_small_result来让优化器按照你希望的方式运行</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优化数据访问：访问的数据量过大，是否查询了不必要的数据</li><li>重构查询方式：将大的查询切分成小的查询，例如将多表查询分成单表查询</li><li>理解查询是如何被执行的，以及时间都消耗在那些地方</li><li>优化通常需要三管齐下，不做(查询缓存)，少做，快速的做</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第六章 查询性能优化&lt;/em&gt;&lt;br&gt;查询优化、索引优化、库表结构优
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>并发基础</title>
    <link href="http://yoursite.com/2019/04/21/concurrence/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/21/concurrence/并发基础/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-21T17:33:31.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><em>并发</em>：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可同时运行<br></p><p><em>高并发(high concurrent)</em>：是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够<em>同时并行处理</em>很多请求</p><ul><li>并发：多个线程操作相同的资源，保证线程安全，合理使用资源</li><li>高并发：服务能同时处理很多请求，提高程序性能</li></ul><h1 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h1><p>随着现代半导体工艺的发展，CPU的频率越来远快，相对内存快了一个数量级，对于访存的操作CPU就需要等待主存，这样会导致资源的白白浪费。所以cache的出现是为了解决CPU与内存速度不匹配的问题<br></p><p>cache 的工作原理是基于“局部性”原理，它包含以下两个方面：</p><ul><li>时间局部性：如果某个数据被访问，那么不久将来它很可能再次被访问</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据也可能被访问</li></ul><p>cache中保存着cpu刚用过的数据或者是循环使用的数据，这时，从cache中读取数据就会很快，减少了cpu等待的时间，提高了系统的性能</p><h2 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h2><p>cache 给系统带来性能上飞跃的同时，也引入了新的问题“缓存一致性问题”。设想如下场景（cpu一共有两个核，core1和core2）：<br>以i++为例，i的初始值是0.那么在开始每个核都存储了i的值0，当第core1块做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后core2缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2</p><h1 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h1><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。我们介绍其中最经典的MESI协议</p><p>在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：</p><ul><li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</li><li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中</li><li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中</li><li>I(Invalid): 这行数据无效</li></ul><p><strong>CPU多级缓存-乱序执行优化</strong><br>处理器为提高运算速度而做出违背代码原有顺序的优化</p><p><strong>乱序执行优化出现问题的原因</strong><br>在单核时代处理器做出的优化可以保证执行结果不会远离预期目标，但是，在多核时代却并非如此。在多核时代，同时会有多个核同时执行指令，每一个核的指令都可能被乱序。另外,处理器还引入了L1，L2,…,Ln等多级缓存机制，每个核心都有自己的缓存机制，这样就导致了逻辑次序上后写入内存的数据未必真的最后写入。最后就带来一个问题，如果不做任何防护措施，处理器最终得出的结果和逻辑得出结果会大不相同。比如，在一个核上执行写入操作，并在最后写一个标记用来表示操作完毕，之后从另外一个核上通过判断这个标记来判定所需要的数据是否已经就绪，这种做法就存在一定风险：标记位先被写入但之前的操作却并未完成(可能是未计算完成，也可能是数据没有从处理器缓存刷新到主存中，最终导致另外的核使用了错误的数据)</p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/01.jpg" alt></p><p>JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。</p><p>Java采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序</p><h2 id="Java内存模型—同步八种操作"><a href="#Java内存模型—同步八种操作" class="headerlink" title="Java内存模型—同步八种操作"></a>Java内存模型—同步八种操作</h2><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/17.jpg" alt></p><ul><li><p>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</p></li><li><p>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p></li><li><p>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p></li><li><p>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</p></li><li><p>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</p></li><li><p>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</p></li><li><p>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</p></li><li><p>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p></li></ul><h2 id="同步规则分析"><a href="#同步规则分析" class="headerlink" title="同步规则分析"></a>同步规则分析</h2><ul><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</p></li><li><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p></li></ul><p>-对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p><h1 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h1><p><em>优势</em>:</p><ul><li>速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程（或线程）同时进行</li><li>设计：程序设计在某些情况下更简单，也可以有更多的选择</li><li>资源利用：CPU能够等待IO的时候能够做一些其他的事情</li></ul><p><em>风险</em>:</p><ul><li>安全性：多个线程共享数据时可能会产生于期望不相符的结果</li><li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如：死锁、饥饿等问题。</li><li>性能：线程过多时会使得：CPU频繁切换，调度时间增多；同步机制；消耗过多内存</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CPU多级缓存：缓存一致性、乱序执行优化</li><li>Java内存模型： JMM规定、抽象结构、同步八种操作以及规则</li><li>Java并发的优势与风险</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;em&gt;并发&lt;/em&gt;：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发压力测试</title>
    <link href="http://yoursite.com/2019/04/21/concurrence/%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/04/21/concurrence/并发压力测试/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-21T17:34:14.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h1><p>Postman 是一个很强大的 API调试、Http请求的工具</p><ul><li>我们将测试如下接口, 环境：springboot<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>@Slf4j采用了lombok简化了代码，它可直接使用log.info()使用日志对象</p></blockquote><p><strong>使用之前我们先配置全局参数，方便日后的使用</strong></p><ul><li><p>设置全局变量<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/02.jpg" alt></p></li><li><p>定义全局变量参数<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/03.jpg" alt></p></li><li><p>测试接口<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/04.jpg" alt></p></li></ul><h2 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h2><p>创建一个分类目录，将上述的测试接口添加到该目录中，点击run<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/05.jpg" alt></p><ul><li>此时会出现新的窗口，进行并发测试<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/06.jpg" alt></li></ul><h1 id="apache-benche"><a href="#apache-benche" class="headerlink" title="apache benche"></a>apache benche</h1><p>ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控</p><blockquote><p>download: <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></p></blockquote><ul><li><p>ab命令进行并发测试<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/07.jpg" alt></p></li><li><p>测试参数如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/08.jpg" alt></p></li></ul><h1 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h1><p> Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测 试但后来扩展到其他测试领域。 它可以用于测试静态和动态资源例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、 数据库， FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来在不同压力类别下测试它们的 强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果</p><blockquote><p>download:<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/</a></p></blockquote><p><em>解压完毕在bin目录下执行jmeter.bat会启动如下界面</em><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/09.jpg" alt></p><blockquote><p>新建一个线程组</p></blockquote><ul><li><p>线程组配置<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/10.jpg" alt></p></li><li><p>创建测试请求和查询结果<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/11.jpg" alt></p></li></ul><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/12.jpg" alt></p><h1 id="代码并发模拟"><a href="#代码并发模拟" class="headerlink" title="代码并发模拟"></a>代码并发模拟</h1><ul><li>CountDownLatch<br>计数器不断的向下减<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/13.jpg" alt></li></ul><blockquote><p>该类可阻塞线程，并保证线程在满足特定的情况下继续执行</p></blockquote><ul><li>Semaphore<br>字面意思为”信号量”<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/14.jpg" alt></li></ul><blockquote><p>该类可阻塞进程，并且控制同一时间的请求并发量</p></blockquote><p>如果我们想模拟并发测试的时，并在所有线程执行完输出执行结果，应该结合上诉两个类来完成。</p><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>不做同步的情况下，该结果是不一致的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;postman&quot;&gt;&lt;a href=&quot;#postman&quot; class=&quot;headerlink&quot; title=&quot;postman&quot;&gt;&lt;/a&gt;postman&lt;/h1&gt;&lt;p&gt;Postman 是一个很强大的 API调试、Http请求的工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将测试
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能的索引</title>
    <link href="http://yoursite.com/2019/04/20/mysql/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/04/20/mysql/创建高性能的索引/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-21T08:07:49.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第五章 创建高性能的索引</em><br>索引在MySQL中也称为key，它是存储引擎用于快速找到记录的一种数据结构。索引能够轻易将查询性能提高几个数量级</p><h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>存储引擎是如何使用索引的？ 首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。也就是说，如果某个列建立了索引，那么会先在索引中查找。</p><ul><li>可创建多个索引，如果多个列，那么顺序非常重要</li></ul><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><p>索引在存储引擎层，因此不同的存储引擎对索引的工作方式也不一样，并不是所有的存储引擎都支持所有类型的索引</p><p><strong>B-Tree索引</strong></p><blockquote><p>术语B-Tree是因为MySQL在create table和其他语句中也使用该关键字<br></p></blockquote><p>内部算法实际使用B+Tree实现，InnoDB使用B+Tree，NDB集群使用T-Tree来存储索引</p><ul><li>B-Tree与二叉树的形式存储索引，意味着所有的值都是顺序的，能够快速访问数据不需要进行全表扫描</li><li>B-Tree对索引是顺序组织存储，所以适合查找范围数据</li></ul><p><strong>哈希索引</strong><br>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效, 哈希索引会将所有的哈希码存储在索引中，同时在哈希表中存储每个数据行的指针</p><ul><li>在MySQL中，只有memory引擎支持哈希索引</li><li>如果要查询很多关联的表，哈希索引非常使用用于查询</li><li>InnoDB有一种特殊的功能 <em>自适应哈希索引</em> 如果它注意到某些索引使用频繁，内部会基于B-Tree之上创建哈希索引</li></ul><p><strong>创建自定义索引</strong><br>我们可模拟InnoDB一样创建函数, 虽然还是使用B-Tree进行查找，但是使用哈希值来查询<br><br><em>我们有如下表</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hash_test(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">url</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  url_crc <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>例如url存储”<a href="http://www.mysql.com&quot;" target="_blank" rel="noopener">http://www.mysql.com&quot;</a>, 我们进行如下查询效率是非常低的，使用的是全表扫描<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span>;</span><br></pre></td></tr></table></figure></p><p>因此我们在上述表中添加了url_crc它用于存储URL的哈希值，通过哈希值来进行查询，效率是极高的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将值存储到url_crr列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">crc32</span>(<span class="string">'http://www.mysql.com'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span> <span class="keyword">AND</span> url_crc = <span class="keyword">crc32</span>(<span class="string">"http://www.mysql.com"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>上述过程的缺陷是需要手动设置哈希值，当然可使用触发器来完成。注意：哈希冲突问题，或可使用FNV64()哈希函数，冲突比CRC32()少</p></blockquote><p><strong>全文索引</strong><br>它查找的是文本中的关键词，而不是直接比较索引中的值。类似于搜索引擎做的事情</p><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><ul><li>大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序和临时表</li><li>可将随机I/O变为顺序IO</li></ul><p><em>索引是最好的解决方案吗?</em><br>只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是最有效的</p><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><p>正确的创建和使用索引是实现高性能查询的基础</p><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p><em>不当的使用索引</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>如果查询总的列不是独立的，则MySQL不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>如果需要索引很长的字符串，这会导致索引变的大且慢。我们可采用<em>索引开始部分的字符</em>来提高索引效率。但是也会降低索引的选择性。指定是如果你使用部分字符，那么出现重复的值越高</p><ul><li>对于blob、text或很长的varcher类型的列必须采用前缀索引</li></ul><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>在多个列上建立独立的单列索引大部分情况下并不能提高性能，在MySQL5.0版本引入了”索引合并”的策略，一定程度上表上的多个单列索引来定位指定的行</p><ul><li>OR、AND、UNION以集合的方式会根据索引查询并不会进行全表扫描</li></ul><h2 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h2><p>在B-Tree索引中，意味着安装最左列进行排序，其次第二列</p><ul><li>将选择性最高的列放到索引最前列</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行，它的优点有</p><ul><li>把相关数据保存在一起，例如实现电子邮箱时，可根据用户ID聚集数据获取全部邮件</li><li>数据访问更快，聚簇索引将索引和数据存储在一个B-Tree中</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>MySQL可直接获取列的数据，这样就不再需要读取数据行, 如果一个索引包含所有需要查询的字段的值，称为覆盖索引</p><ul><li>覆盖索引必须要存储索引的值，并不是所有的存储引擎都支持覆盖索引</li></ul><h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><ul><li>MySQL有两种方式生成有序的结果，排序、按索引顺序扫描 <em>可使用explain select table 查看tyep值 如果为index则使用了索引扫描来做排序</em></li></ul><h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中</p><ul><li>可以在create table语句中指定pack_keys参数来控制压缩索引的方式</li></ul><h2 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h2><p>如果在相同列上创建多个索引, 那么MySQL需要单独维护重复的索引，这会影响性能</p><ul><li>未使用的索引考虑删除</li></ul><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行</p><ul><li>InnoDB行锁效率高，只有在访问行的时候才会对其加锁</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>如果列中建立了索引，存储引擎会根据索引快速查询到记录。</li><li>InnoDB使用B-Tree索引，所有中都是顺序的，避免了全表扫描。哈希索引只有memory</li><li>可以使用CRC32(‘url’)获取哈希值，可通过哈希值来查询较长的字符串如URL地址，不要使用SHA1()和MD5()作为哈希函数</li><li>编写查询语句时尽可能选择合适的索引以避免单行查找，尽可能使用数据原生顺序从而避免而外的排序操作，尽可能使用索引覆盖查询</li><li>不要因”应该为where子句中出现的所有列创建索引”所谓的经验法来创建索引，而是要应该根找出消耗最长时间的查询来创建合适的索引</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第五章 创建高性能的索引&lt;/em&gt;&lt;br&gt;索引在MySQL中也称为k
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Schema与数据类型优化</title>
    <link href="http://yoursite.com/2019/04/19/mysql/Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/19/mysql/Schema与数据类型优化/</id>
    <published>2019-04-19T08:39:23.000Z</published>
    <updated>2019-04-19T10:29:36.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第四章 Schema与数据类型优化</em> <br></p><blockquote><p>选择正确的数据类型对于获得高性能至关重要</p></blockquote><ul><li>更小的通常更好，尽量使用存储数据的最小数据类型</li><li>简单就好，例如整形比字符操作更快，而不是使用字符存储时间</li><li>尽量避免NULL，通常情况下最好将列指定为NOT NULL</li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>存储整数可使用：tinyint、smallint、mediumint、int、bigint<br>。分别使用8、16、24、32、64位存储空间</p><ul><li>整数类型有可选的unsigend属性，表示不允许负值</li><li>整数计算通常使用bigint</li></ul><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数是带有小数部分的数字</p><ul><li>float（4字节）和double（8字节）支持浮点运算</li><li>decimal用于存储精确的小数, 因为decimal只是一种存储格式，在计算中会转换为double</li><li>只在对小数进行精确计算时才使用decimal，例如财务数据</li></ul><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>不同的存储引擎存储字符的方式可能不同</p><ul><li>varchar存储可边长字符串，仅使用必要的空间</li><li>char类型是定长的，适合存储更短的字符串。当存储char值时，MySQL会删除所有的末尾空格</li><li>binary和varbinary用于存储二进制字符串，存储的是字节码而不是字符</li><li>blob和text：存储大数据而设计的字符串类型。前者为二进制，后者为字符串。它们与其他类型不同，存储引擎会做特殊处理，如果值太大，InnoDB会使用专门的”外部”存储区域进行存储</li><li>使用枚举类型存储字符串，与数字-字符串映射关系查找表</li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL能存储的最小时间颗粒度为秒，MariaDB支持微妙级别的时间类型，<em>可使用bigint存储微秒级别的时间戳</em></p><ul><li>datetime: 可保存大范围的值，1001年-9999年，精度为秒。8字节存储</li><li>timestamp: 保存了从1970-1-1午夜（格林尼治标准时间）以来的秒数, 使用4字节存储。</li></ul><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型</p><ul><li>bit：bit(1)定义一个包含单个位的字段, 存储一个或多个true/false</li><li>set: 存储很多个true/false，以集合的形式来表示</li></ul><h2 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h2><p>整数通常是标识列最好的选择，enum和set只适合标记固定的值，如人的性别、产品类型等，尽量避免字符串类型作为标识列，因为消耗空间<br><br>随机字符如UUID存储会导致insert、select语句变慢。插入会随机写到索引不同位置，查询逻辑上相邻的行为分布在磁盘和内存分布在不同的位置。</p><ul><li>如果存储UUID，移出’-‘，使用unhex()函数转换位16字节数字，存储在binary(16)。检索使用hex()函数格式化位十六进制的格式</li></ul><h1 id="schema设计中的陷阱"><a href="#schema设计中的陷阱" class="headerlink" title="schema设计中的陷阱"></a>schema设计中的陷阱</h1><ul><li>太多的列</li><li>太多的表关联，MySQL限制每个关联操作最多61张表。如果希望查询效率更高，单个查询最好在12个表以内做关联</li><li>防止过度的使用enum</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择优化的数据类型&quot;&gt;&lt;a href=&quot;#选择优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择优化的数据类型&quot;&gt;&lt;/a&gt;选择优化的数据类型&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第四章 Sc
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper分布式锁原理</title>
    <link href="http://yoursite.com/2019/04/19/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/19/zookeeper/zookeeper分布式锁原理/</id>
    <published>2019-04-18T16:06:16.000Z</published>
    <updated>2019-04-25T07:52:04.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁-活锁概念"><a href="#死锁-活锁概念" class="headerlink" title="死锁 | 活锁概念"></a>死锁 | 活锁概念</h1><p><strong>死锁</strong></p><ul><li>如果有两个服务订单服务和商品服务，订单服务需要读取库存操作, 商品服务也需要读取库存操作(图1)</li><li>此时订单服务读取完库存之后并没有释放(没有提交)。当商品服务再次读取时，库存数据可能会不一致（脏读）。通常这种情况采用<em>死锁</em></li><li>解决：在订单服务访问库存的时候，无论crud操作都加一把锁(未释放)。那么商品服务就不能访问库存了(图2)</li></ul><p><em>图1</em></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/05.jpg" alt></p><p><em>图2</em></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/06.jpg" alt></p><p><em>活锁</em><br>无论多少个服务，只对库存进行<strong>读取的操作</strong> 那么其他服务都可以去读取，否则都要进行加锁。这种情况成为<em>活锁</em></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在分布式环境下，当不同的服务访问某一个共享资源数据(数据库)的时候，可能会发生数据不一致的情况</p><p><em>下订单流程</em><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/07.jpg" alt><br>如果在创建订单和扣除库存的操作没有完成（sleep），此时有其他请求进入时，那么库存的数量就可能会造成不一致(之前的值，因为sleep了)</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/09.jpg" alt></p><ul><li>在获取锁的时候，要根据锁是否被占用才可获取。如果没有占用创建锁 <em>zk临时节点</em>。临时节点会根据客户端会话的断开而断开（释放锁）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>什么是死锁：当A服务进行CRUD库存的时候，其他服务不可访问库存</li><li>什么是活锁：如果A服务只是进行读库存的操作，那么其他服务可访问库存</li><li>利用Zookeeper不能重复创建一个节点的特性来实现一个分布式锁，与redis很类似</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;死锁-活锁概念&quot;&gt;&lt;a href=&quot;#死锁-活锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁 | 活锁概念&quot;&gt;&lt;/a&gt;死锁 | 活锁概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有两个服务订单服务和商
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="活锁" scheme="http://yoursite.com/tags/%E6%B4%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper集群</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper集群/</id>
    <published>2019-04-18T06:08:54.000Z</published>
    <updated>2019-04-25T07:48:31.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper集群概述"><a href="#zookeeper集群概述" class="headerlink" title="zookeeper集群概述"></a>zookeeper集群概述</h1><p>zookeeper集群包含主从节点，心跳机制（选举模式），架构如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/04.jpg" alt></p><p><em>选举模式</em>: 如果上述图中的master宕机了, slave1和slave进行选举，只有其中一个为master。如果原来的master恢复了，那么会加入到集群中成为slave。集群个数建议为奇数因为需要选举的过程</p><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><ul><li>配置数据文件 myid 1/2/3 对应 server.1/2/3</li><li>通过 ./zkCli.sh -server [ip]:[port] 检测集群是否配置成功</li></ul><p><em>拷贝3份zookeeper文件, 在第一份文件中的zoo.cfg配置如下信息</em><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个文件都需要加入该配置</span></span><br><span class="line"><span class="comment"># master节点ip | 数据同步的端口 | 选举端口</span></span><br><span class="line"><span class="string">server.1=192.168.211.136:2888:3888</span></span><br><span class="line"><span class="string">server.2=192.168.211.136:2889:3889</span></span><br><span class="line"><span class="string">server.3=192.168.211.136:2890:3890</span></span><br></pre></td></tr></table></figure></p><p><em>在dataDir数据源目录创建 myid 添加数字 1</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang dataDir]# vim myid</span><br><span class="line">[root@zhongjinlang dataDir]# ll</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 2 4月  18 00:42 myid</span><br><span class="line">drwxr-xr-x. 2 root root 6 4月  18 00:32 version-2</span><br><span class="line">-rw-r--r--. 1 root root 4 4月  18 00:32 zookeeper_server.pid</span><br></pre></td></tr></table></figure></p><blockquote><p>其他文件修改端口 2182、2183和创建myid即可</p></blockquote><p><em>分别启动 ./zkServer.sh start 并在2181中set一个节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /data 123 </span><br><span class="line">Created /data</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper, data]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出当前连接，连接2182</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] [root@zhongjinlang bin]# ./zkCli.sh -server </span><br><span class="line">localhost:2182</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时发现从节点2182有了master的数据（2183也有）</span></span><br><span class="line">[zk: localhost:2182(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper, data]</span><br></pre></td></tr></table></figure></p><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower # 从节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Mode: leader # 主节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: follower # 从节点</span><br></pre></td></tr></table></figure><h2 id="选举模式实验"><a href="#选举模式实验" class="headerlink" title="选举模式实验"></a>选举模式实验</h2><p>上述可看出2182为主节点，我们将2182进程kill，观察谁会成为主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时已经连接不了2182</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Ncat: Connection refused.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别连接其他节点</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower</span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: leader # 2183成为了主节点</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper集群包含主从节点、心跳机制。当主节点挂了，经过选举会将某一个从节点成为主节点，来保证整体服务的高可用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper集群概述&quot;&gt;&lt;a href=&quot;#zookeeper集群概述&quot; class=&quot;headerlink&quot; title=&quot;zookeeper集群概述&quot;&gt;&lt;/a&gt;zookeeper集群概述&lt;/h1&gt;&lt;p&gt;zookeeper集群包含主从节点，心跳机制（选举模
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeperACL权限控制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeperACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeperACL权限控制/</id>
    <published>2019-04-17T17:12:12.000Z</published>
    <updated>2019-04-18T17:12:54.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为ACL-access-control-lists"><a href="#何为ACL-access-control-lists" class="headerlink" title="何为ACL(access control lists)?"></a>何为ACL(access control lists)?</h1><p>可以对节点设置读写等权限，来保障数据的安全性，权限permission可以指定不同的范围以及角色<br></p><h1 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h1><ul><li>getAcl：获取某个节点的权限信息</li><li>setAcl：设置某个节点的权限</li><li>addauth： 输入认证授权信息，注册用户将用户根据指定的权限才可登入</li></ul><h2 id="ACL的构成一"><a href="#ACL的构成一" class="headerlink" title="ACL的构成一"></a>ACL的构成一</h2><ul><li><p>zookeeper的ACL通过[scheme:id:permission]来构成权限列表</p><blockquote><p>scheme: 代表采用的某种全新机制</p></blockquote><blockquote><p>id: 代表允许访问的用户</p></blockquote><blockquote><p>permission: 权限组合字符串</p></blockquote></li></ul><h2 id="ACL的构成二-scheme"><a href="#ACL的构成二-scheme" class="headerlink" title="ACL的构成二 - scheme"></a>ACL的构成二 - scheme</h2><ul><li><p>world：只有一个用户, 语法: world:anyone:[permission] 默认情况下它表示任何人都可访问这一节点</p></li><li><p>auth：认证登入，需要注册用户且有权限。语法：auth:user:password:[permission]</p></li><li><p>digest：需要对密码进行加密才可访问，语法：digest：username:BASE64(SHA1(password)):[permission]</p></li><li><p>ip: 可限制某个ip的访问，语法：ip:192.168.1.1:[permission]</p></li><li><p>super: 代表超级管理员，拥有所有权限</p></li></ul><h2 id="ACL的构成三-permission"><a href="#ACL的构成三-permission" class="headerlink" title="ACL的构成三 - permission"></a>ACL的构成三 - permission</h2><p>权限字符串使用缩写 crdwa，分别表示：</p><ul><li>c: create创建子节点。表示设置了改权限才可进行创建子节点</li><li>r: read获取节点/子节点列表的权限 </li><li>d: delete删除子节点权限</li><li>w: write写节点数据权限</li><li>a: admin权限才可分配permission</li></ul><h1 id="ACL实战"><a href="#ACL实战" class="headerlink" title="ACL实战"></a>ACL实战</h1><h2 id="world"><a href="#world" class="headerlink" title="world"></a>world</h2><p><em>创建一个节点并查看默认的权限</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /imooc/abc data </span><br><span class="line">Created /imooc/abc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] getAcl /imooc/abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拥有所有权限</span></span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure></p><p><em>设置权限：禁止删除</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] setAcl /imooc/abc world:anyone:crwa</span><br></pre></td></tr></table></figure></p><p><em>此时节点的权限、后新创建一个节点再进行删除测试（因为当前节点拥有之前的权限）</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /imooc/abc</span><br><span class="line">'world,'anyone</span><br><span class="line">: crwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] create /imooc/abc/xyz new-data-isnotdelete </span><br><span class="line">Created /imooc/abc/xyz</span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] delete /imooc/abc/xyz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示权限不足</span></span><br><span class="line">Authentication is not valid : /imooc/abc/xyz</span><br></pre></td></tr></table></figure></p><h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>明文登入<br><em>注册账号并登入</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 39] create /name/zhangsan zs </span><br><span class="line">Created /name/zhangsan</span><br><span class="line">[zk: localhost:2181(CONNECTED) 40] getAcl /name/zhangsan</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登入提示没有这个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] setAcl /name/zhangsan auth:zhangsan:123:cdrwa     </span><br><span class="line">Acl is not valid : /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注册一个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 42] addauth digest zhangsan:zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次登入</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] setAcl /name/zhangsan auth:zhangsan:123:cdrwa</span><br></pre></td></tr></table></figure></p><p><em>此时权限信息</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 44] getAcl /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码存在数据库中是一个密文</span></span><br><span class="line">'digest,'zhangsan:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdrwa</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># digest</span></span></span><br><span class="line">使用密文方式登入</span><br><span class="line"></span><br><span class="line">*创建新的节点 并设置登入账号以及密码*</span><br><span class="line">```shell</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /name/lisi</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码（密文）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] setAcl /name/lisi digest:lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=:cdra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /name/lisi</span><br><span class="line">'digest,'lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdra</span><br></pre></td></tr></table></figure></p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>控制某个网段是否有权限来访问目录节点，通常用于控制客户端</p><p><em>创建一个新的节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] create /name/ip ip</span><br><span class="line">Created /name/ip</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /name/ip</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] setAcl /name/ip ip:192.168.117.1:cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] getAcl /name/ip</span><br><span class="line">'ip,'192.168.117.1</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时虚拟机不可访问</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] get /name/ip</span><br><span class="line">Authentication is not valid : /name/ip</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper的ACL可对节点进行权限控制来保障数据安全性</li><li>world：默认所有用户登入</li><li>auth：注册用户登入，注册密码时为明文</li><li>digest：注册用户登入，注册密码时为密文</li><li>ip: 可限制网段访问</li><li>super: 可访问所有权限</li><li>ACL使用场景一：开发/测试环境分离，开发者无权操作测试库的节点，只能看</li><li>ACL使用场景二：生产环境上控制指定IP的服务可以访问相关节点，防止混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为ACL-access-control-lists&quot;&gt;&lt;a href=&quot;#何为ACL-access-control-lists&quot; class=&quot;headerlink&quot; title=&quot;何为ACL(access control lists)?&quot;&gt;&lt;/a&gt;何为ACL(
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper的watch机制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E7%9A%84watch%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper的watch机制/</id>
    <published>2019-04-17T16:11:33.000Z</published>
    <updated>2019-04-18T17:12:36.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为watch"><a href="#何为watch" class="headerlink" title="何为watch?"></a>何为watch?</h1><p>针对每个节点的操作，都会有一个监督者<strong>watch</strong>。当节点发现变化时，如create、set、delete都会触发一个watch事件。<br><br>zookeeper中的watch是一次性的，<em>触发后立即销毁</em>。注意是在zookeeper中</p><ul><li><p>父节点，子节点增删改都会触发watch</p></li><li><p>针对不同类型的操作，触发的watch事件不同：如节点创建事件、节点删除事件、节点数据变化事件</p></li></ul><h1 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h1><h2 id="父节点watch事件"><a href="#父节点watch事件" class="headerlink" title="父节点watch事件"></a>父节点watch事件</h2><ul><li>创建父节点触发: NodeCreated</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先设置一个事件（<span class="built_in">set</span> get都可以 使用<span class="built_in">help</span>查看）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] stat /imooc watch  </span><br><span class="line">Node does not exist: /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发了事件</span></span><br><span class="line">watch::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/imooc</span><br><span class="line">Created /imooc</span><br></pre></td></tr></table></figure><ul><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li></ul><h2 id="子节点watch事件"><a href="#子节点watch事件" class="headerlink" title="子节点watch事件"></a>子节点watch事件</h2><p>ls为父节点设置watch</p><ul><li>创建子节点触发：NodeChildrenChanged<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /imooc</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /imooc watch </span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /imooc/abc 88 </span><br><span class="line">Created /imooc/abc</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/imooc</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>触发了NodeChildrenChanged</p></blockquote><ul><li>删除子节点也是触发：NodeChildrenChanged</li><li><p>修改子节点不会触发事件</p></li><li><p>TODO：增加和删除触发的事件为什么一样：因为它们为子节点，子节点和父节点需要进行区分，父节点有不同的事件，对于父节点来说不需要关注子节点的事件。因为父节点只需要告诉客户端 哦我的子节点改变了NodeChildrenChanged事件</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>watcher使用场景：在集群环境下，如果某个节点发生了变化，例如配置文件的变化，我们可通过watcher监听获取到数据，并将其同步到其他分布式的节点中，达到数据的一致性</li><li>zookeeper节点（子父）发生变化时，会触发watch事件，并且出发后立即销毁（在zookeeper中)不同的类型操作watch事件也不同（增、删、改）</li><li>在修改节点数据之前可设置watch，如果下次获取该节点时会触发不同的watch类似</li><li>父节点触发watch事件有： NodeCreated（增）、NodeDeleted（删）、NodeDataChanged（改）</li><li>子节点触发watch事件有:  NodeChildrenChanged（增删）、修改不会触发事件因为对于父节点来说并不关心</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为watch&quot;&gt;&lt;a href=&quot;#何为watch&quot; class=&quot;headerlink&quot; title=&quot;何为watch?&quot;&gt;&lt;/a&gt;何为watch?&lt;/h1&gt;&lt;p&gt;针对每个节点的操作，都会有一个监督者&lt;strong&gt;watch&lt;/strong&gt;。当节点发现变化
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper命令使用</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper命令使用/</id>
    <published>2019-04-17T16:10:33.000Z</published>
    <updated>2019-04-18T17:12:48.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>通过 ./zkCli.sh打开客户端进行命令行后台操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# zkCli.sh</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="ls-ls2"><a href="#ls-ls2" class="headerlink" title="ls | ls2"></a>ls | ls2</h2><p><strong>查看zookeeper路径</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p><strong>查看状态信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建了之后，zk为这个节点所分配的ID</span></span><br><span class="line">cZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> create-time</span></span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后zk的ID</span></span><br><span class="line">mZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后节点的时间</span></span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点ID</span></span><br><span class="line">pZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点发生变化后的version值</span></span><br><span class="line">cversion = -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点数据的version，修改后累加1</span></span><br><span class="line">dataVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 权限</span></span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点个数（ls /）</span></span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p><h2 id="get-stat"><a href="#get-stat" class="headerlink" title="get | stat"></a>get | stat</h2><ul><li><p>stat命令：ls2 = ls + stat</p></li><li><p>get：取出当前节点数据，如果没有数据，与上述内容一至</p></li></ul><h1 id="节点操作命令"><a href="#节点操作命令" class="headerlink" title="节点操作命令"></a>节点操作命令</h1><p>讲述该节内容前，我们先阐述session的基本原理：</p><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都可设置一个超时时间（30分钟不操作session失效）：心跳结束，则session过期</li><li>session过期，临时节点znode会被抛弃</li><li>心跳机制： 客户端向服务端的ping包请求</li></ul><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><ul><li><p>创建默认节点节点（持久化节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc immoc-data </span><br><span class="line">Created /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] get /immoc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点的持久化数据</span></span><br><span class="line">immoc-data</span><br><span class="line">..</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 10</span><br></pre></td></tr></table></figure></li><li><p>创建节点后目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /     </span><br><span class="line">[zookeeper, imooc]</span><br></pre></td></tr></table></figure></li><li><p>创建临时节点: create -e /imooc/tmp immoc-data</p></li><li><p>创建顺序节点: 每个节点后缀都会增加数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s /imooc/sec seq </span><br><span class="line">Created /imooc/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s /imooc/sec seq</span><br><span class="line">Created /imooc/sec0000000002</span><br></pre></td></tr></table></figure></li></ul><h2 id="set-delete"><a href="#set-delete" class="headerlink" title="set | delete"></a>set | delete</h2><ul><li><p>set path data [version]：修改节点如果默认不设置版本号，直接删除。加上版本号可实现乐观锁(只能修改最新的数据)</p></li><li><p>delete path [version]: 直接删除节点, 加上版本号只能删除最新数据</p></li></ul><h1 id="四字命令-four-letter-words"><a href="#四字命令-four-letter-words" class="headerlink" title="四字命令 four letter words"></a>四字命令 four letter words</h1><p>zookeeper可通过它自身提供的简写命令来和服务器进行交互, 可查看服务器的一些状态信息。使用运维来进行监控</p><ul><li>需要使用nc命令，安装yum install nc</li><li>语法： echo [commod] | nc [ip] [port]</li></ul><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>它可查看zookeeper的状态信息，以及是否mode（集群还是单机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo stat | nc 192.168.211.136 2181</span><br><span class="line">Zookeeper version: 3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /192.168.211.136:34346[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/27</span><br><span class="line">Received: 2696</span><br><span class="line">Sent: 2701</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x45</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 8</span><br></pre></td></tr></table></figure><h2 id="ruok"><a href="#ruok" class="headerlink" title="ruok"></a>ruok</h2><p>查看当前zk服务是否启动，启动返回imok</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo ruok | nc localhost 2181</span><br><span class="line">imok[root@zhongjinlang /]#</span><br></pre></td></tr></table></figure><h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><p>列出未经处理的会话和临时节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo dump | nc localhost 2181</span><br><span class="line">SessionTracker dump:</span><br><span class="line">Session Sets (0):</span><br><span class="line">ephemeral nodes dump:</span><br><span class="line">Sessions with Ephemerals (0):</span><br></pre></td></tr></table></figure><h2 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h2><p>查看服务器配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo conf | nc localhost 2181</span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataDir/version-2</span><br><span class="line">dataLogDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataLogDir/version-2</span><br><span class="line">tickTime=2000</span><br><span class="line">maxClientCnxns=60</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=40000</span><br><span class="line">serverId=0</span><br></pre></td></tr></table></figure><h2 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h2><p>展示连接到服务器的客户端信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo cons | nc localhost 2181</span><br><span class="line"> /0:0:0:0:0:0:0:1:47224[0](queued=0,recved=1,sent=0)</span><br></pre></td></tr></table></figure><h2 id="mntr"><a href="#mntr" class="headerlink" title="mntr"></a>mntr</h2><p>监控zookeeper的健康信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo mntr | nc localhost 2181</span><br><span class="line">zk_version3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">zk_avg_latency0</span><br><span class="line">zk_max_latency27</span><br><span class="line">zk_min_latency0</span><br><span class="line">zk_packets_received2703</span><br><span class="line">zk_packets_sent2708</span><br><span class="line">zk_num_alive_connections1</span><br><span class="line">zk_outstanding_requests0</span><br><span class="line">zk_server_statestandalone</span><br><span class="line">zk_znode_count8</span><br><span class="line">zk_watch_count0</span><br><span class="line">zk_ephemerals_count0</span><br><span class="line">zk_approximate_data_size85</span><br><span class="line">zk_open_file_descriptor_count30</span><br><span class="line">zk_max_file_descriptor_count4096</span><br></pre></td></tr></table></figure><h2 id="wchs"><a href="#wchs" class="headerlink" title="wchs"></a>wchs</h2><p>展示watch信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo wchs | nc localhost 2181</span><br><span class="line">0 connections watching 0 paths</span><br><span class="line">Total watches:0</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ls / 查看zk目录</li><li>ls2 / 查看节点信息</li><li>get / 取出当前节点信息</li><li>zookeeper存储了节点的各种状态，如数据的大小、修改时间等</li><li>ephemeralOwner = 0x0属性如果为0x0那么为临时节点，否则为持久节点（后面是一串数据）。临时节点在断开连接后消失（10秒左右延迟 - 心跳机制）</li><li>create path data创建持久化节点</li><li>set path data [version]修改节点</li><li>delete path data [version]删除节点</li><li>使用set和delete时候，建议根据version删除，可达到<em>乐观锁的</em>效果，不会删除到之前旧的数据</li><li>zookeeper提供四字命令可查看服务器的一些状态信息，语法：echo [命令] | nc [ip] [port]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;通过 ./zkCli.sh打开客户端进行命令行后台操作&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="乐观锁" scheme="http://yoursite.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper基本数据模型</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper/zookeeper%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper/zookeeper基本数据模型/</id>
    <published>2019-04-17T01:29:33.000Z</published>
    <updated>2019-04-25T07:46:58.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper模型介绍"><a href="#zookeeper模型介绍" class="headerlink" title="zookeeper模型介绍"></a>zookeeper模型介绍</h1><ul><li><p>数据为树形结构，可理解为Linux的目录结构 /usr/local/..</p></li><li><p>每一个节点成为znode，它可有子节点，也可以有数据</p></li><li><p>每个节点分为临时节点和永久节点，临时节点在客户端断开连接后消失。永久节点是一个持久化的节点</p></li><li><p>每个zk节点都有各自的版本号，可通过命令显示节点信息</p></li><li><p>每当节点数据发生变化时，那么该节点的版本号就会累加（乐观锁）</p></li><li><p>删除/修改过时的节点，版本号不匹配则会报错</p></li><li><p>每一个zk节点存储的数据不易过大，几k即可</p></li><li><p>节点可设置权限ACL，可通过权限来限制用户访问</p></li></ul><h1 id="数据模型基本操作"><a href="#数据模型基本操作" class="headerlink" title="数据模型基本操作"></a>数据模型基本操作</h1><ul><li>客户端连接 - 查看znode结构 - 关闭客户端连接</li></ul><p><strong>连接客户端</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkCli.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示一推信息...</span></span><br><span class="line">WATCHER::</span><br><span class="line">WatchedEvent state:SyncConnected type:None path:null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里需要回车</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></p><p><strong>zookeeper命令</strong><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/02.jpg" alt></p><p><strong>查看znode</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zookeeper/quota</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p><h1 id="zookeeper的作用"><a href="#zookeeper的作用" class="headerlink" title="zookeeper的作用"></a>zookeeper的作用</h1><ul><li><p>master节点选举，当主节点挂了，从节点就会接手工作，从而保证集群是高可用的</p></li><li><p>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，例如在一个集群的生产环境下，修改了一个redis的配置那么其他服务都需要进行修改，这样就很麻烦</p></li><li><p>发布订阅模式，类似消息队列MQ, dubbo发布者把数据数据存储到znode节点上，订阅者会读取这个数据</p></li><li><p>提供<em>分布式锁</em>，分布式环境中不同<strong>进程</strong>之间争夺资源，类似于多线程中的锁<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/003.jpg" alt></p><blockquote><p>当A处理完B、C、D</p></blockquote></li><li><p>集群管理，集群中保证数据的强一致性</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>zookeeper的结构为树形结构，节点分为临时节点和永久节点。前者会在客户端断开后消失，后者是一个持久化的节点</p></li><li><p>zookeeper可保证集群高可用、提供了分布式锁保证数据一致性、可以统一管理集群中的配置文件进行同步</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper模型介绍&quot;&gt;&lt;a href=&quot;#zookeeper模型介绍&quot; class=&quot;headerlink&quot; title=&quot;zookeeper模型介绍&quot;&gt;&lt;/a&gt;zookeeper模型介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据为树形结构，可理解为Linux
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper概述</title>
    <link href="http://yoursite.com/2019/04/17/zookeeper/zookeeper%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/17/zookeeper/zookeeper概述/</id>
    <published>2019-04-17T00:29:33.000Z</published>
    <updated>2019-04-25T07:45:39.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户</p><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/01.jpg" alt></p><ul><li>很多台计算机组成一个整体，一个整体一致对外并处理同一个请求</li><li>内部的每台计算机都可相互通信（rest/rpc）</li><li>客户端到服务端的一次请求到响应结束会历经多台计算机</li></ul><h1 id="zookeeper特性"><a href="#zookeeper特性" class="headerlink" title="zookeeper特性"></a>zookeeper特性</h1><ul><li>一致性：数据一致性，将数据按照顺序分批入库</li><li>原子性： 事务要么成功要么失败，不会局部化</li><li>单一视图： 客户端连接集群中的任一zookeeper节点，数据都是一致的</li><li>可靠性： 每次对zookeeper的操作状态都会保存在服务端</li><li>实时性: 客户端可以读取到zookeeper服务端的最新数据</li></ul><h1 id="zookeeper的安装"><a href="#zookeeper的安装" class="headerlink" title="zookeeper的安装"></a>zookeeper的安装</h1><h2 id="JDK依赖"><a href="#JDK依赖" class="headerlink" title="JDK依赖"></a>JDK依赖</h2><ul><li>安装解压好后配置环境变量，java-version查看是否安装成功</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set java</span></span><br><span class="line"><span class="comment"># java安装路径</span></span><br><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span></span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure><h2 id="zookeeper配置"><a href="#zookeeper配置" class="headerlink" title="zookeeper配置"></a>zookeeper配置</h2><ul><li><p>下载地址：<a href="https://archive.apache.org/dist/zookeeper/" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/</a></p></li><li><p>安装解压后配置环境变量</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">export</span> <span class="string">JAVA_HOME=/usr/local/server/java/jdk1.8</span></span><br><span class="line"><span class="string">export</span> <span class="string">ZOOKEEPER_HOME=/usr/local/server/zookeeper/zookeeper-3.4.11</span></span><br><span class="line"><span class="string">export</span> <span class="string">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span>    </span><br><span class="line"><span class="string">export</span> <span class="string">PATH=$PATH:$ZOOKEEPER_HOME/bin:JAVA_HOME/bin</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>核心配置文件</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用于计算时间的单元, 比如session超时（N * tickTime）</span></span><br><span class="line"><span class="attr">tickTime:</span> </span><br><span class="line"><span class="comment">#用于集群，允许从节点连接并同步到master节点的初始化连接时间，以tickTime的倍数来表示</span></span><br><span class="line"><span class="attr">initLimit:</span> </span><br><span class="line"><span class="comment">#用于集群，master主节点与从节点之间的消息通信，请求和答应的时间（心跳机制）</span></span><br><span class="line"><span class="attr">syncLimit:</span></span><br><span class="line"><span class="comment">#必须要配置的。用来zookeeper存储的数据(手动创建) </span></span><br><span class="line"><span class="attr">dataDir:</span> </span><br><span class="line"><span class="comment">#日志目录，如果不配置会和data目录公用（手动创建）</span></span><br><span class="line"><span class="attr">dataLogDir:</span> </span><br><span class="line"><span class="comment">#连接服务器的端口，默认2181</span></span><br><span class="line"><span class="attr">clientPort:</span></span><br></pre></td></tr></table></figure></p><p><strong>启动</strong></p><ul><li>./zkServer.sh 命令帮助</li><li>./zkServer.sh start 启动<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure></li></ul><p><strong>查看启动状态</strong></p><ul><li>./zkServer.sh status<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /usr/local/server/zookeeper/zookeeper-3.4.11/bin/../conf/zoo.cfg</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示单机状态</span></span><br><span class="line">Mode: standalone</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper用于提供协调服务，作用与分布式，发挥其优势，可为大数据服务</li><li>一次请求历经了多台服务器，这是分布式系统的最简单</li><li>zookeeper协调服务可理解为交通堵塞时交警的作用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存使用与优化</title>
    <link href="http://yoursite.com/2019/04/16/redis/redis%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/16/redis/redis缓存使用与优化/</id>
    <published>2019-04-15T17:21:17.000Z</published>
    <updated>2019-04-25T08:51:48.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h1><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul><li><p>加速读写：CPU L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器读写、Ehcache缓存数据库结果</p></li><li><p>降低后端负载：降低MySQL的负载等</p></li></ul><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><p>数据不一致：缓存层和数据层有时间窗口不一致，和<em>更新策略</em>有关。也就是说，需要将数据库中的数据存入redis进行缓存，如果数据库更新了，那么缓存如何更新呢? </p></li><li><p>代码维护成本高： 多了一层缓存逻辑</p></li><li><p>运维成本：例如redis-cluster，或者使用云服务</p></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>降低后端负载：对高消耗的SQL, 如join结果集 / 分组结果集</p></li><li><p>加速请求响应：优化IO响应时间</p></li><li><p>大量写合并为批量写： 计数器先在redis累加，再批量写入DB</p></li></ul><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><p>当数据库数据更新时，那么缓存将如何进行更新维护呢？<br></p><ol><li><p>先进先出算法剔除：例如<em>maxmemory-policy</em>(最大内存限制)，当超过指定值之后，删除过期的key。不需担心每一个key是如何删除的。适用场景：控制内存</p></li><li><p>超时剔除：设置过期时间<em>expire</em>。适用场景：存储不是很重要的数据</p></li><li><p>主动更新：开发控制生命周期，由自己来控制每一个key的更新周期</p></li></ol><blockquote><p>开发建议： 超时剔除 + 主动更新</p></blockquote><h1 id="缓存颗粒控制"><a href="#缓存颗粒控制" class="headerlink" title="缓存颗粒控制"></a>缓存颗粒控制</h1><p>通常我们都是这样设计一个缓存系统的：先从redis查询数据，如果有直接返回。如果没有则从数据库中查询然后再加入缓存中。<br><br><em>伪代码如下</em>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set userid <span class="string">'select * from user where id=1'</span></span><br><span class="line"></span><br><span class="line">set userid <span class="string">'select column.. from user where id=1'</span></span><br></pre></td></tr></table></figure></p><ul><li>那么到底要缓存select * 还是部分字段的数据？该问题为缓存粒度问题</li></ul><h2 id="缓存粒度控制-三个角度"><a href="#缓存粒度控制-三个角度" class="headerlink" title="缓存粒度控制 - 三个角度"></a>缓存粒度控制 - 三个角度</h2><ul><li>通用性：全部属性更好</li><li>占用空间：部分数据更好</li><li>代码维护：表面上全部属性更好</li></ul><blockquote><p>生产环境通常采用部分属性，缓存需要考虑到性能问题、序列化问题</p></blockquote><h1 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h1><p>通常情况下缓存设计是这样的：第一次访问redis没有数据就去从数据库中查询，然后将数据加入缓存中，当下此访问redis时就直接从缓存中获取了。这是通常的情况下，如果第二个步骤访问数据库没有数据会怎样？如下如图结构：<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/redis/44.jpg" alt></p><p>此时就失去了缓存的意义，因为缓存就是用来保存持久层。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li><p>业务代码问题： 本身你编写的接口就拿不到持久层数据或是调用别的接口拿不到持久层数据</p></li><li><p>恶意攻击、爬虫等等: 根据URI一定的规则访问到接口</p></li></ul><h2 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h2><ul><li>业务的相应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ul><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>缓存空对象</strong><br><br>如果从数据库中查询的值不存在，进行一个判断直接将null就作为’数据’存入缓存中</p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/redis/45.jpg" alt></p><p>但是这种解决方案还是有问题，<em>持久层和缓存层数据”短期”不一致</em>。比如业务上的接口问题调用时可能出现网络原因拿不到结果，此时你将它作为null缓存了。如果恢复了，此时缓存是一个null的状态</p><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(cacheValue) )&#123;</span><br><span class="line">        <span class="comment">// 为空从持久层获取数据</span></span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 加入缓存</span></span><br><span class="line">        jedis.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 防止缓存穿透, 如果数据库值真为空，设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(storageValue) )&#123;</span><br><span class="line">            jedis.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>布隆过滤器拦截</strong><br><br>通过很少的内存对数据的过滤, 例如在一个电话本中判断一个电话是否在电话本中，通常不会将电话本存储到内存中，占用内存可能会很大。布隆过滤器就是解决这种类似的问题，它通过一些算法，将电话本存入过滤器，当要判断电话是否在电话本中时，通过很少的算法来进行解决</p><blockquote><p>布隆过滤器用于检索一个元素是否在一个集合中</p></blockquote><h1 id="缓存无底洞问题"><a href="#缓存无底洞问题" class="headerlink" title="缓存无底洞问题"></a>缓存无底洞问题</h1><ul><li>2010年，Facebook有3000个memcache节点</li><li>发现问题： 加机器性能没有提升反而下降</li></ul><p><strong>问题关键点</strong></p><ul><li>更多的j机器 != 更高的性能</li><li>批量接口需求（mget、mset等）</li><li>数据增长与水平扩展需求</li></ul><h1 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h1><p>当缓存服务承载大量请求，如果缓存服务异常/宕机，流量直接压向后端DB，造成级联故障</p><p><strong>优化方案</strong><br></p><ul><li>保证缓存高可用：个别节点、个别机器、甚至是机房</li><li>依赖隔离组件为后端限流</li><li>提前演练：压力测试</li><li>cache服务高可用：redis-sentinel、redis-cluster、redis-VIP</li></ul><h1 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h1><p>缓存重建过程：我们知道使用缓存首先从缓存中获取,如果获取不到从数据库中获取，如果获取到了将数据写入缓存，该过程为缓存的重建的过程。该过程可能会出现的问题<br><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/redis/46.jpg" alt></p><p>热点key（访问量大） + 较长的重建时间： 大量的线程作查询数据源和缓存重建的工作。解决方案：</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>第一个获取缓存的线程需要做重建的时候，将重建过程加锁。完成了重建工作再将锁解开。在这期间其他线程的发现重建过程处于等待状态，直到最后一个发现锁解开就可直接获取缓存进行输出<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/redis/47.jpg" alt></p><blockquote><p>该解决方案没有大量的重建过程，但有等待的问题</p></blockquote><p><strong>伪代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从redis中取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueByRedis</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key;</span><br><span class="line">    <span class="keyword">if</span>(cacheValue == <span class="keyword">null</span>)&#123; <span class="comment">// 重建工作</span></span><br><span class="line">        <span class="comment">// 设置互斥锁key</span></span><br><span class="line">        String mutexKey = <span class="string">"mutexKey:"</span> + key;</span><br><span class="line">        <span class="comment">//setnx命令：key不存在才进行设置</span></span><br><span class="line">        <span class="keyword">if</span>(redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>) )&#123; </span><br><span class="line">            <span class="comment">// 开始重建</span></span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value);</span><br><span class="line">            <span class="comment">// 删除锁        </span></span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 存在该key，让其他线程休眠</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">// 再次尝试获取key</span></span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h2><ul><li>缓存层面： 没有设置过期时间</li><li>功能层面： 为每一个value添加<em>逻辑过期时间</em>，发现过期了，使用单独线程去完成缓存的重建工作</li><li>该方案相比互斥锁没有等待的过程</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>缓存的收益: 加速读写、降低后端存储负载</li><li>缓存成本: 缓存和存储数据不一致性、代码维护成本、运维成本</li><li>缓存更新策略：超时删除 + 主动更新</li><li>缓存穿透问题：使用缓存空对象和布隆过滤器解决，注意他们各自使用场景</li><li>缓存雪崩问题： 缓存层的高可用、客户端降级、提前压力测试</li><li>热点key重建问题： 互斥锁、”永不过期” 来解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;缓存的收益与成本&quot;&gt;&lt;a href=&quot;#缓存的收益与成本&quot; class=&quot;headerlink&quot; title=&quot;缓存的收益与成本&quot;&gt;&lt;/a&gt;缓存的收益与成本&lt;/h1&gt;&lt;h2 id=&quot;收益&quot;&gt;&lt;a href=&quot;#收益&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL架构与存储引擎</title>
    <link href="http://yoursite.com/2019/04/15/mysql/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/04/15/mysql/MySQL存储引擎概述/</id>
    <published>2019-04-15T12:48:06.000Z</published>
    <updated>2019-04-21T06:08:21.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第一章 MySQL架构与历史</em></p><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><ul><li><p>最上层服务是多数基于网络的客户端/服务器都有类似的架构</p></li><li><p>第二层是MySQL核心服务功能，查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等</p></li><li><p>第三层包含存储存储引擎，它负责MySQL中数据的存储和提取，存储引擎API包含几十个底层函数，例如执行<em>开始一个事务</em>等操作。注意：存储引擎并不会提取SQL</p></li></ul><h1 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB是mysql的默认<em>事务型引擎</em>, 使用最为广泛的的存储引擎。它的作用是处理大量的短期事务，短期事务大部分情况是正常提交的，很少会被回滚。</p><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>在MySQL5.1及之前的版本，默认使用MyISAM存储引擎。它提供了全文索引、压缩、空间函数等特性，它不支持事务和行级锁。不要默认开启此引擎，应当使用InnoDB。</p><p><br></p><h1 id="MySQL内建的其他存储引擎"><a href="#MySQL内建的其他存储引擎" class="headerlink" title="MySQL内建的其他存储引擎"></a>MySQL内建的其他存储引擎</h1><h2 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h2><p>它只支持insert、select操作，archive引擎会缓存所有的写并利用zlib对插入的行进行压缩，比MyISAM更少的IO</p><h2 id="Blackhole"><a href="#Blackhole" class="headerlink" title="Blackhole"></a>Blackhole</h2><p>它没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。可用于复制数据库进行备份，可在复制架构和日志审核时发挥作用。但是并不推荐</p><h2 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h2><p>它可将普通的CSV文件（逗号分隔的文件）作为MySQL的表来处理，但这种表不支持索引。可将excel中的数据存储为CSV文件然后复制到MySQL数据目录。它可作为一种数据交换的机制</p><h2 id="Federated"><a href="#Federated" class="headerlink" title="Federated"></a>Federated</h2><p>该引擎是访问其他MySQL服务器的一个代理，默认是禁用的，它有一个后续的版本为FederatedX</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>如果需要快速访问数据，且这些数据不会被修改，它把数据保存在内存, 重启之后表结构还存在但是数据会丢失。使用场景：</p><ul><li>查询或映射表</li><li>缓存周期性聚合数据的结果</li><li>保存数据分析中产生的中间数据</li></ul><blockquote><p>memory支持hash索引，因此查询很快</p></blockquote><h2 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h2><p>MyISAM的变种引擎，由多个表合并出来的虚拟表，该引擎已被放弃</p><h2 id="NDB"><a href="#NDB" class="headerlink" title="NDB"></a>NDB</h2><p>当时的MySQL AB公司从索尼爱立信公司收购了NDB数据库，开发了自己的NDB集群存储引擎</p><h1 id="第三方引擎"><a href="#第三方引擎" class="headerlink" title="第三方引擎"></a>第三方引擎</h1><p>MySQL从2007年提供了插件式的存储引擎API，因此由大多数的第三方产品或开源项目</p><h2 id="OLTP类引擎"><a href="#OLTP类引擎" class="headerlink" title="OLTP类引擎"></a>OLTP类引擎</h2><p>InnoDB是该类型的引擎，还有其他比如支持事务和MVCC的其中一个由PBXT</p><h2 id="面向列的存储引擎"><a href="#面向列的存储引擎" class="headerlink" title="面向列的存储引擎"></a>面向列的存储引擎</h2><p>MySQL默认是面向行的，没一行的数据是一起存储的，查询也是以行为单位处理。而在大数据量处理时，面向队列方式可能效率更高<br><br><strong>infobright</strong> 是一种面向列的存储引擎，在非常大的数据量（数十TB）时，该引擎工作良好。<br>它为数据分析和数据仓库而设计。该引擎不支持索引，不过在这么大的数据量，索引也很难发挥作用</p><h2 id="社区存储引擎"><a href="#社区存储引擎" class="headerlink" title="社区存储引擎"></a>社区存储引擎</h2><p>社区所提供的存储引擎很多，这里只介绍常见的</p><ul><li>Groonga： 全文索引引擎，号称可以提供准确高效的全文索引</li><li>OQGraph: 支持图操作，比如最短路径问题，用SQL很难实现该问题</li><li>Q4M：该引擎在MySQL内部实现了队列操作，用SQL很难实现该问题</li><li>SphinxSE: 该引擎为Sphinx全文索引搜索服务器提供了SQL接口</li><li>Spider: 该引擎可将数据切分为不同的分区，高效透明的实现了分片，并可分片执行并行查询</li><li>VPForMySQL: 该引擎支持垂直分区，指的是将表分成不同列的组合，进行单独存储。但是对于查询来说，看到的还是一张表</li></ul><h1 id="选择合适的引擎"><a href="#选择合适的引擎" class="headerlink" title="选择合适的引擎"></a>选择合适的引擎</h1><p>多数情况下，innoDB都是正确的选择, Oracle在MySQL5.5将innoDB作为默认引擎。如何选择归纳一句话 <strong>除非要用到innoDB不具备的特性，并且没有其他办法可替代</strong> ,</p><ul><li>如果需要事务，InnoDB是目前最稳定的选择</li><li>如果不需要要事务，并主要是SELECT和INSERT那么使用MyISAM</li></ul><h1 id="转换表的引擎"><a href="#转换表的引擎" class="headerlink" title="转换表的引擎"></a>转换表的引擎</h1><p>每种方法都有优缺点，以下只讲述三种方法：</p><ul><li>alter table<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure></li></ul><p>上诉语法可适用任何存储引擎，但有一个问题：需要执行很长时间，MySQL会按行将数据从原表复制一张新的表中，在复制期间可能会消耗系统所有的IO资源，同时原来的表会加上读锁</p><ul><li><p>导出于导入</p></li><li><p>创建于查询（create、select）</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>MySQL拥有分层架构，上层是服务器层的服务、和查询执行引擎。下层存储引擎</p></li><li><p>mysql的引擎和区别：InnoDB、MyISAM, 5.1之前的版本采用MyIsAM。InnoDB支持事务而MyISAM不支持事务，如果需要大量的插入数据操作使用MyISAM，其他情况优先使用InnoDB</p></li><li><p>如果要处理大数据量使用第三方引擎 infobright</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL逻辑架构&quot;&gt;&lt;a href=&quot;#MySQL逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;MySQL逻辑架构&quot;&gt;&lt;/a&gt;MySQL逻辑架构&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第一章 My
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis集群总结</title>
    <link href="http://yoursite.com/2019/04/15/redis/redis%E9%9B%86%E7%BE%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/redis/redis集群总结/</id>
    <published>2019-04-15T08:47:57.000Z</published>
    <updated>2019-04-19T08:22:07.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群总结"><a href="#集群总结" class="headerlink" title="集群总结"></a>集群总结</h1><p>redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写服务<br></p><ul><li><p>那么从节点的数据怎么和主节点的数据达到一致性呢？首先从节点拿到数据的原理是通过<em>RDB传输(主从复制原理)</em> 的方式来获取数据，而主从数据的一致性通过<em>偏移量</em>来判断数据的一致性。</p></li><li><p>数据一致性问题解决了，而故障转移redis是如何做到的？ 官方的两种方案： <strong>redis-sentinel</strong> 和 <strong>redis-cluster</strong>，redis-sentinel（哨兵）是一个独立的程序，它的作用是监控多个主从节点，如果发现主节点挂了会进行内部选举的模式让一个从节点成为主节点。而redis-cluster专门用于搭建集群模式的情况下使用，因此它本身就具备了高可用的特性。</p></li></ul><h1 id="rediscluster总结"><a href="#rediscluster总结" class="headerlink" title="rediscluster总结"></a>rediscluster总结</h1><ol><li><p>rediscluster数据分区规则使用虚拟槽（16384），每个节点负责一部分槽和相关数据，实现数据的和请求的均衡负载</p></li><li><p>搭建集群步骤：准备节点、节点握手、分配槽、复制。redis.trib.rb工具用于快速搭建集群</p></li><li><p>集群伸缩实现是通过节点之间移动槽和相关数据的实现</p></li></ol><ul><li>加入：把槽从原来的节点迁移到新节点</li><li>退出：如果要退出集群的节点中槽有数据，那么将它迁移到其他节点，在通过cluster forget命令广播集群让所有节点忘记</li></ul><ol start="4"><li>集群故障转移过程为故障发现和节点恢复。节点的下线分为主观下线和客观下线，当半数主节点认为你是故障了标记为客观下线。从节点负责故障恢复的过程，保证集群可用性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集群总结&quot;&gt;&lt;a href=&quot;#集群总结&quot; class=&quot;headerlink&quot; title=&quot;集群总结&quot;&gt;&lt;/a&gt;集群总结&lt;/h1&gt;&lt;p&gt;redis集群高可用实现方式：首先我们知道如果A节点如果发送故障，那么期望它的从节点来接管主节点的任务，也就是说可以进行读写
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>rediscluster常见运维问题</title>
    <link href="http://yoursite.com/2019/04/15/redis/rediscluster%E5%B8%B8%E8%A7%81%E8%BF%90%E7%BB%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/15/redis/rediscluster常见运维问题/</id>
    <published>2019-04-15T07:54:03.000Z</published>
    <updated>2019-04-17T18:19:24.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助</p><h1 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h1><p>也就是我们在rediscluster篇章中配置的 <em>cluster-require-full-coverage </em> 默认true<br><br>它表示是否需要集群中的所有节点都是一个在线的状态，所有的0-16384槽都在一个服务的状态，才认为整个集群是完整的，才会对外提供服务<br></p><ul><li><p>但是对于大多数的业务都无法容忍，如果我们有1000主从节点，当其中一节点进行故障转移的期间（clusterdown the cluster is down）那么此时整个集群就不可用了</p></li><li><p>在实际生产过程中设置为 <em>no</em></p></li><li><p>为何默认为yes？ 集群中16384个槽全部不可用，这也设计就是为了保证集群完整性</p></li></ul><h1 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h1><p>我们知道集群节点之间使用信息的交换(gossip)，所以一定有带宽的开销。官方建议：最多1000个节点当节点规模较大时候，会有不容忽视的带宽消耗</p><ul><li><p>消息发送的频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</p></li><li><p>消息数据量：消息会槽信息，槽数组(2kb)，集群的1/10状态数据(10个节点1kb)</p></li><li><p>集群规模越高带宽越高</p></li><li><p>优化： cluster-node-timeout带宽和故障转移的速度的均衡</p></li></ul><h1 id="发布-订阅广播"><a href="#发布-订阅广播" class="headerlink" title="发布/订阅广播"></a>发布/订阅广播</h1><p>类似于mq的生产消息于订阅消息。当某个节点要通知集群中其他节点的时候，例如故障恢复。其他节点就会收到该消息，这样会产生一个问题，节点的带宽开销会很大。</p><ul><li><p>publish在集群每个节点广播，会加重带宽</p></li><li><p>解决: 如果只需要做到高可用，单独使用redissentinel</p></li></ul><h1 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h1><p>如果将原来节点的数据分布到多个节点上，可能会产生数据的倾斜，有如下原因</p><ul><li><p>节点和槽分配不均匀</p></li><li><p>不同槽对应键值数量差距大</p></li><li><p>包含bigkey</p></li><li><p>内存相关配置不一致</p></li></ul><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><ul><li><p>只读连接：集群模式的从节点不接受任何读写请求，会跳转到数据对应槽的主节点上，如果需要读（每次客户端执行readonly）</p></li><li><p>读写分离跟为复杂不建议在集群模式下实现，需要考虑复制延迟、读取过期数据、从节点故障。如果真要实现需要维护slave（思路类似redis-sentinel）</p></li></ul><h1 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h1><p>如果我们需要将原来的单机节点迁移到rediscluster，这种模式如何实现？</p><ul><li><p>redis-trib.rb import可将单节点数据迁移到集群。不支持在线迁移，b不支持断点续传，单线程迁移</p></li><li><p>在线迁移：唯品会&gt;redis-migrate-tool、豌豆荚&gt;redis-port</p></li></ul><h1 id="集群VS单机"><a href="#集群VS单机" class="headerlink" title="集群VS单机"></a>集群VS单机</h1><ul><li><p>集群批量操作有限：如mget、mset必须在一个槽</p></li><li><p>集群事务和lua无法跨节点使用</p></li><li><p>集群模式只有一个db0，没有16个数据库</p></li><li><p>集群模式复制只支持一层，不支持树形复制结构</p></li></ul><p>rediscluster满足容量和新能的扩展性，但很多业务达不到一定的QPS，很多场景下redis-sentinel已经足够好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本章讲述搭建rediscluster后常见的问题，理解这些问题，使我们对redis分布式集群的架构有一定的帮助&lt;/p&gt;
&lt;h1 id=&quot;集群
      
    
    </summary>
    
      <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
</feed>
