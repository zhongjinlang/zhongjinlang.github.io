<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胖虎的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-01T18:35:23.197Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖虎</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云发送短信实战</title>
    <link href="http://yoursite.com/2019/05/02/mq/%E9%98%BF%E9%87%8C%E4%BA%91%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/05/02/mq/阿里云发送短信实战/</id>
    <published>2019-05-01T18:31:10.000Z</published>
    <updated>2019-05-01T18:35:23.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><blockquote><p><a href="https://github.com/zhongjinlang/sendmessage" target="_blank" rel="noopener">https://github.com/zhongjinlang/sendmessage</a></p></blockquote><p>注册账户并且校验手机验证码，校验成功才可进行注册。实现思路如下:<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/001.jpg" alt></p><p><strong>表结构如下</strong><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/jiegou.jpg" alt><br>因为需要判断手机号是否注册，通常在每个user表中(这里省去了其他的字段)，都需要有一个mobile字段，这样更为合理</p><h1 id="搭建发送验证码"><a href="#搭建发送验证码" class="headerlink" title="搭建发送验证码"></a>搭建发送验证码</h1><h2 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">mysqladmin</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.211</span><span class="number">.139</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  jpa:</span></span><br><span class="line"><span class="attr">    show-sql:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.181</span><span class="number">.128</span></span><br></pre></td></tr></table></figure><h2 id="UserService-interface"><a href="#UserService-interface" class="headerlink" title="UserService-interface"></a>UserService-interface</h2><p>我们需要完成用户注册之前验证码的校验，因此我们定义两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mobile 手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResultVo <span class="title">sendCode</span><span class="params">(String mobile)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResultVo <span class="title">register</span><span class="params">(User user, String code)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h2><p>其实发送验证码就是随机生成6位数字, 具体实现如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">sendCode</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(mobile))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">1</span>, <span class="string">"手机号错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该手机号是否注册</span></span><br><span class="line">        User result = userDao.findByMobile(mobile);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">1</span>, <span class="string">"手机号已被注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成随机数</span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> code = random.nextInt(max);</span><br><span class="line">        <span class="keyword">if</span> (code &lt; min) &#123;</span><br><span class="line">            code = code + min;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"【生成的验证码为】=&#123;&#125;, 【手机号为】=&#123;&#125;"</span>, code, mobile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存入redis</span></span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">"msgcode_"</span> + mobile).set(code + <span class="string">""</span>, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 讲验证码和手机号发送到消息队列</span></span><br><span class="line">        Map&lt;String, String&gt; parameter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        parameter.put(<span class="string">"mobile"</span>, mobile);</span><br><span class="line">        parameter.put(<span class="string">"code"</span>, code + <span class="string">""</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"msg"</span>, parameter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">0</span>, <span class="string">"验证码发送成功"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>我们将上述代码进行测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mobile = <span class="string">"1101"</span>;</span><br><span class="line">        ResultVo resultVo = userService.sendCode(mobile);</span><br><span class="line">        System.out.println(resultVo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>观察日志、redis、mq浏览器页面<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/002.jpg" alt><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/003.jpg" alt><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/004.jpg" alt></p><h2 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h2><p>根据流程图思考，注册是有条件的，也就是输入的验证码正确之后才可进行注册，具体实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultVo <span class="title">register</span><span class="params">(User user, String code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(code))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">1</span>, <span class="string">"验证码不能为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String msgCode = (String) redisTemplate.boundValueOps(<span class="string">"msgcode_"</span> + user.getMobile()).get();</span><br><span class="line">    log.info(<span class="string">"【用户注册】redis中验证码为 = &#123;&#125;"</span>, msgCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msgCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"验证码不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!msgCode.equals(code)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">1</span>, <span class="string">"验证码不正确"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    User result = userDao.save(user);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">0</span>, <span class="string">"注册成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultVo(<span class="number">1</span>, <span class="string">"注册失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将上述代码进行测试: 先发送验证码，记录验证码用于注册用户的方法参数2上<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"zhangsan"</span>);</span><br><span class="line">    user.setMobile(<span class="string">"123"</span>); <span class="comment">// 生成验证码的手机号</span></span><br><span class="line">    user.setPassword(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">    ResultVo register = userService.register(user, <span class="string">"377144"</span>); <span class="comment">// 验证码</span></span><br><span class="line">    System.out.println(register);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="搭建阿里云发送短信服务"><a href="#搭建阿里云发送短信服务" class="headerlink" title="搭建阿里云发送短信服务"></a>搭建阿里云发送短信服务</h1><p>我们通过阿里云的短信服务来进行短信的发送, 首先需要为短信添加签名和模板等。我们采用新版的发送短信API，具体文档与测试接口:<br><a href="https://api.aliyun.com/new#/?product=Dysmsapi" target="_blank" rel="noopener">https://api.aliyun.com/new#/?product=Dysmsapi</a></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.181</span><span class="number">.128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从阿里短信服务中查找</span></span><br><span class="line"><span class="attr">aliyun:</span></span><br><span class="line"><span class="attr">  accessKeyId:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  accessSecret:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  SignName:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">  TemplateCode:</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure><h2 id="发送短信核心类"><a href="#发送短信核心类" class="headerlink" title="发送短信核心类"></a>发送短信核心类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"aliyun"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonRpc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line">    <span class="keyword">private</span> String accessSecret;</span><br><span class="line">    <span class="keyword">private</span> String signName; <span class="comment">// 短信签名名称</span></span><br><span class="line">    <span class="keyword">private</span> String templateCode; <span class="comment">// 短信模板code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phoneNumbers 手机号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> templateParam 验证码【json格式】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">( String phoneNumbers, String templateParam)</span></span>&#123;</span><br><span class="line">        DefaultProfile profile = DefaultProfile.getProfile(<span class="string">"cn-hangzhou"</span>, accessKeyId, accessSecret);</span><br><span class="line">        IAcsClient client = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line">        CommonRequest request = <span class="keyword">new</span> CommonRequest();</span><br><span class="line">        request.setMethod(MethodType.POST);</span><br><span class="line">        request.setDomain(<span class="string">"dysmsapi.aliyuncs.com"</span>);</span><br><span class="line">        request.setVersion(<span class="string">"2017-05-25"</span>);</span><br><span class="line">        request.setAction(<span class="string">"SendSms"</span>);</span><br><span class="line">        request.putQueryParameter(<span class="string">"RegionId"</span>, <span class="string">"cn-hangzhou"</span>);</span><br><span class="line">        request.putQueryParameter(<span class="string">"TemplateParam"</span>, templateParam);</span><br><span class="line">        request.putQueryParameter(<span class="string">"PhoneNumbers"</span>, phoneNumbers);</span><br><span class="line">        request.putQueryParameter(<span class="string">"SignName"</span>, signName);</span><br><span class="line">        request.putQueryParameter(<span class="string">"TemplateCode"</span>, templateCode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CommonResponse response = client.getCommonResponse(request);</span><br><span class="line">            System.out.println(response.getData());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; code = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        code.put(<span class="string">"code"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        commonRpc.send(<span class="string">"17239837261"</span>, JSON.toJSONString(code));        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"Message"</span>:<span class="string">"OK"</span>,<span class="attr">"RequestId"</span>:<span class="string">"15510BA0-B641-472F-8A3D-D85406A0F15D"</span>,<span class="attr">"BizId"</span>:<span class="string">"520100556727328952^0"</span>,<span class="attr">"Code"</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure><p>阿里短信服务接口返回OK，证明发送短信成功，接下来我们要从消息队列中获取两个参数</p><ol><li>code 生成的随机数</li><li>phone 手机号</li></ol><h2 id="监听MQ消息"><a href="#监听MQ消息" class="headerlink" title="监听MQ消息"></a>监听MQ消息</h2><p>注意监听的队列为msg，如果在项目中，通常将其定义为enum类中，容易维护<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"msg"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CommonRpc commonRpc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"监听消息...."</span>);</span><br><span class="line"></span><br><span class="line">        String mobile = map.get(<span class="string">"mobile"</span>);</span><br><span class="line">        String code = map.get(<span class="string">"code"</span>);</span><br><span class="line">        Map&lt;String, String&gt; param = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        param.put(<span class="string">"code"</span>, code);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"【监听消息】手机号=&#123;&#125;, 验证码=&#123;&#125;"</span>, mobile, code);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            commonRpc.send(mobile, JSON.toJSONString(param));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动项目，会自动监听msg队列中的消息</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注册模块和发送短信模块分离，如果有其他模块使用短信服务，那么通过MQ做到了项目的解耦</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zhongjinlang/sendmess
      
    
    </summary>
    
      <category term="mq" scheme="http://yoursite.com/categories/mq/"/>
    
    
      <category term="rabbitMQ" scheme="http://yoursite.com/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>认证机制</title>
    <link href="http://yoursite.com/2019/05/01/%E9%9A%8F%E7%AC%94/%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/01/随笔/认证机制/</id>
    <published>2019-05-01T15:30:21.000Z</published>
    <updated>2019-05-01T18:32:18.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>所谓的认证，其实就是登入。而登入我们会想到使用session来存储用户登入信息等。对于session和token，为什么需要使用tonken这种认证方式，在web认证的方式也众多，因此我们需要对认证这方面的知识进行分析</p><h1 id="HTTP-Basic-Auth"><a href="#HTTP-Basic-Auth" class="headerlink" title="HTTP Basic Auth"></a>HTTP Basic Auth</h1><p>HTTP Basic Auth简单点说明就是每次请求API时都提供用户的username和password，简言之，Basic Auth是配合RESTful API 使用的最简单的认证方式，只需提供用户名密码即可，但由于有把用户名密码暴露给第三方客户端的风险，在生产环境下被使用的越来越少。因此，在开发对外开放的RESTful API时，尽量避免采用HTTP Basic Auth</p><h1 id="Cookie-Auth"><a href="#Cookie-Auth" class="headerlink" title="Cookie Auth"></a>Cookie Auth</h1><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效</p><h1 id="OAuth"><a href="#OAuth" class="headerlink" title="OAuth"></a>OAuth</h1><p>OAuth（开放授权）是一个开放的授权标准，允许用户让第三方应用访问该用户在某一web服务上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。</p><p>OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的第三方系统（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容</p><p>这种基于OAuth的认证机制适用于个人消费者类的互联网产品，如社交类APP等应用，但是不太适合拥有自有认证权限管理的企业应用<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/suibi/01.jpg" alt></p><h1 id="Token-Auth"><a href="#Token-Auth" class="headerlink" title="Token Auth"></a>Token Auth</h1><p>Token机制相对于Cookie机制又有什么好处呢?</p><ul><li><p><strong>支持跨域访问</strong>: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</p></li><li><p><strong>无状态</strong>(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息</p></li><li><p><strong>更适用CDN</strong>: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</p></li><li><p><strong>去耦</strong>: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</p></li><li><p><strong>更适用于移动应用</strong>: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</p></li><li><p><strong>CSRF</strong>:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。</p></li><li><p><strong>性能</strong>: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</p></li><li><p><strong>不需要为登录页面做特殊处理:</strong> 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</p></li><li><p><strong>基于标准化</strong>:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）</p></li></ul><h1 id="基于JWT的Token认证机制实现"><a href="#基于JWT的Token认证机制实现" class="headerlink" title="基于JWT的Token认证机制实现"></a>基于JWT的Token认证机制实现</h1><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息</p><h2 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h2><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名</p><p><strong>头部(Header)</strong><br>头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BASE64编码之后的字符串如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure></p><p><strong>载荷(Payload)</strong><br>Payload里面是Token的具体内容，也就是Token的数据声明（Claim），这些内容里面有一些是<strong>标准字段</strong>，也可以添加其他需要添加的内容，如userId,email等</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"iss"</span>: <span class="string">"Online JWT Builder"</span>, </span><br><span class="line">  <span class="attr">"iat"</span>: <span class="number">1416797419</span>, </span><br><span class="line">  <span class="attr">"exp"</span>: <span class="number">1448333419</span>, </span><br><span class="line">  <span class="attr">"aud"</span>: <span class="string">"www.example.com"</span>, </span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"jrocket@example.com"</span>, </span><br><span class="line">  <span class="attr">"GivenName"</span>: <span class="string">"Johnny"</span>, </span><br><span class="line">  <span class="attr">"Surname"</span>: <span class="string">"Rocket"</span>, </span><br><span class="line">  <span class="attr">"Email"</span>: <span class="string">"jrocket@example.com"</span>, </span><br><span class="line">  <span class="attr">"Role"</span>: [ <span class="string">"Manager"</span>, <span class="string">"Project Administrator"</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中标准字段各含义如下:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">iss:</span> <span class="string">jwt签发者</span></span><br><span class="line"><span class="attr">sub:</span> <span class="string">jwt所面向的用户</span></span><br><span class="line"><span class="attr">aud:</span> <span class="string">接收jwt的一方</span></span><br><span class="line"><span class="attr">exp:</span> <span class="string">jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line"><span class="attr">nbf:</span> <span class="string">定义在什么时间之前，该jwt都是不可用的.</span></span><br><span class="line"><span class="attr">iat:</span> <span class="string">jwt的签发时间</span></span><br><span class="line"><span class="attr">jti:</span> <span class="string">jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</span></span><br></pre></td></tr></table></figure></p><p><strong>签名</strong><br>上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0</span><br></pre></td></tr></table></figure></p><p>将上面拼接完的字符串用HS256算法进行加密。在加密的时候，还需要提供一个密钥（secret）。如果我们用mystar作为密钥的话，那么就可以得到我们加密后的内容:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></p><p>此时完整的JWT：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></p><p>在请求URL中也会携带这串JWT字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://your.awesome-app.com/make-friend/?jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></p><h2 id="JWT认证-鉴权流程"><a href="#JWT认证-鉴权流程" class="headerlink" title="JWT认证|鉴权流程"></a>JWT认证|鉴权流程</h2><p>基于Token的认证机制会在每一次请求中都带上完成签名的Token信息，这个Token信息可能在COOKIE<br>中，也可能在HTTP的Authorization头中</p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/suibi/02.jpg" alt></p><p><strong>认证</strong></p><ol><li>用户在页面输入用户名和密码，发送请求到服务端</li><li>服务端会验证账号密码是否正确</li><li>服务端生成tonken字符串</li><li>返回客户端，将tonken保存在cookie中</li></ol><p><strong>鉴权</strong></p><ol><li>从cookie中获取tonken信息，通过请求头发送给服务端</li><li>服务端通过tonken信息判断当前用户的权限</li><li>如果没有权限，返回没有权限的提示</li><li>有权限，继续操作</li></ol><h1 id="JWT的JAVA实现"><a href="#JWT的JAVA实现" class="headerlink" title="JWT的JAVA实现"></a>JWT的JAVA实现</h1><p>Java中对JWT的支持可以考虑使用JJWT开源库；JJWT实现了JWT, JWS, JWE 和 JWA RFC规范；下面将简单举例说明其使用</p><blockquote><p>环境：spring boot + jjwt<br><strong>jjwt依赖</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="创建tonken与解析"><a href="#创建tonken与解析" class="headerlink" title="创建tonken与解析"></a>创建tonken与解析</h2><p><strong>创建tonken测试代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JjwtApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建tonken</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTonken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timeMillis = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> newTime = timeMillis + <span class="number">60</span> * <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">        JwtBuilder builder = Jwts.builder()</span><br><span class="line">                .setId(<span class="string">"userid"</span>) <span class="comment">// jti</span></span><br><span class="line">                .setSubject(<span class="string">"username"</span>) <span class="comment">// sub</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> Date()) <span class="comment">// iat 创建tonken的时间</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> Date(newTime)) <span class="comment">// 过期时间</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,<span class="string">"ROOT"</span>)<span class="comment">// 加密方式+密钥</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 可存储其定义信息【角色信息】</span></span><br><span class="line">                .claim(<span class="string">"roles"</span>, <span class="string">"user"</span>)</span><br><span class="line">                ;</span><br><span class="line">        log.info(<span class="string">"【生成的tonken】=&#123;&#125; "</span>, builder.compact());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>密钥与过期时间通常写在配置文件中</p><p>生成的tonken字符串：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJ1c2VyaWQiLCJzdWIiOiJ1c2VybmFtZSIsImlhdCI6MTU1NjcxNzM4MCwiZXhwIjoxNTU2NzE3NTAwLCJyb2xlcyI6InVzZXIifQ.O6Tpx2xMnD-3SrUhbQGxTgvvONEHAslRmh6ClIcbxGI</span></span><br></pre></td></tr></table></figure></p><p><strong>解析tonken测试代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseTonken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String token = <span class="string">"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJ1c2VyaWQiLCJzdWIiOiJ1c2VybmFtZSIsImlhdCI6MTU1NjcxNzM4MCwiZXhwIjoxNTU2NzE3NTAwLCJyb2xlcyI6InVzZXIifQ.O6Tpx2xMnD-3SrUhbQGxTgvvONEHAslRmh6ClIcbxGI"</span>;</span><br><span class="line">        Claims claims = Jwts.parser()</span><br><span class="line">                .setSigningKey(<span class="string">"ROOT"</span>) <span class="comment">// 密钥</span></span><br><span class="line">                .parseClaimsJws(token) <span class="comment">// tonken</span></span><br><span class="line">                .getBody(); <span class="comment">// 载荷</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"用户id"</span> + claims.getId() );</span><br><span class="line">        System.out.println(<span class="string">"用户名"</span> + claims.getSubject() );</span><br><span class="line">        System.out.println(<span class="string">"签发时间"</span> + claims.getIssuedAt() );</span><br><span class="line">        System.out.println(<span class="string">"当前时间:"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"过期时间:"</span> + claims.getExpiration());</span><br><span class="line">        System.out.println(<span class="string">"自定义载荷信息:"</span> + claims.get(<span class="string">"roles"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>输出的日志信息为:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">用户iduserid</span></span><br><span class="line"><span class="string">用户名username</span></span><br><span class="line"><span class="string">签发时间Wed</span> <span class="string">May</span> <span class="number">01</span> <span class="number">21</span><span class="string">:29:40</span> <span class="string">CST</span> <span class="number">2019</span></span><br><span class="line"><span class="string">当前时间:Wed</span> <span class="string">May</span> <span class="number">01</span> <span class="number">21</span><span class="string">:31:01</span> <span class="string">CST</span> <span class="number">2019</span></span><br><span class="line"><span class="string">过期时间:Wed</span> <span class="string">May</span> <span class="number">01</span> <span class="number">21</span><span class="string">:31:40</span> <span class="string">CST</span> <span class="number">2019</span></span><br><span class="line"><span class="string">自定义载荷信息:user</span></span><br></pre></td></tr></table></figure></p><h2 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"tonken"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TonkenUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key; <span class="comment">// 密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expiration; <span class="comment">// 过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成tonken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 登入用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> tonken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createTonken</span><span class="params">(String id, String subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">        JwtBuilder builder = Jwts.builder()</span><br><span class="line">                .setId(id)</span><br><span class="line">                .setSubject(subject)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expiration &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            builder.setExpiration(<span class="keyword">new</span> Date(nowMillis + expiration) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成含有自定义信息的tonken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 登入用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claim 自定义信息【如 user、admin角色】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> tonken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createTonken</span><span class="params">(String id, String subject, String claim)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">        JwtBuilder builder = Jwts.builder()</span><br><span class="line">                .setId(id)</span><br><span class="line">                .setSubject(subject)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, key)</span><br><span class="line">                .claim(<span class="string">"roles"</span>, claim);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expiration &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            builder.setExpiration(<span class="keyword">new</span> Date(nowMillis + expiration) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析tonken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">parseTonken</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(key)</span><br><span class="line">                .parseClaimsJws(key) <span class="comment">// 被解析的tonken字符串从客户端获取</span></span><br><span class="line">                .getBody(); <span class="comment">// 载荷信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml</strong><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tonken:</span></span><br><span class="line"><span class="attr">  key:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  expiration:</span> <span class="number">360000</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>jwt有三部分组成：头部(加密方式)、载荷(有效信息)、签名(密钥)</li><li>tonken是无状态的，有服务端生成，不需要存储session信息，因为它包含了用户的信息</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;所谓的认证，其实就是登入。而登入我们会想到使用session来存储用户登入信息等。对于session和token，为什么需要使用tonken
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="HTTP Basic Auth" scheme="http://yoursite.com/tags/HTTP-Basic-Auth/"/>
    
      <category term="Cookie Auth" scheme="http://yoursite.com/tags/Cookie-Auth/"/>
    
      <category term="OAuth" scheme="http://yoursite.com/tags/OAuth/"/>
    
      <category term="Token Auth" scheme="http://yoursite.com/tags/Token-Auth/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="http://yoursite.com/2019/04/28/mq/RabbitMQ/"/>
    <id>http://yoursite.com/2019/04/28/mq/RabbitMQ/</id>
    <published>2019-04-27T18:29:12.000Z</published>
    <updated>2019-05-01T18:32:05.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h1><blockquote><p>代码：<a href="https://github.com/zhongjinlang/rabbitmq" target="_blank" rel="noopener">https://github.com/zhongjinlang/rabbitmq</a></p></blockquote><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>通常消息队列都有三个概念：生产消息、队列、消费消息。RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和队列之间, 加入了<strong>交换器 (Exchange)</strong> 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息发送给交换器, 交换器根据<strong>调度策略</strong>再把消息再给队列<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/06.jpg" alt></p><p><strong>Exchange</strong><br>生产者将消息发送到Exchange(交换器)中，它并不存储任何数据，它只主要是接收消息并且转发到绑定的队列。交换器有四种类型:</p><ol><li>Direct</li><li>topic</li><li>Headers</li><li>Fanout</li></ol><p><strong>RoutingKey</strong><br>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则<br><br>RabbitMQ为routing key设定的长度限制为255 bytes</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>download: <a href="https://www.rabbitmq.com/releases/rabbitmq-server/" target="_blank" rel="noopener">https://www.rabbitmq.com/releases/rabbitmq-server/</a></p></blockquote><ul><li>账号密码guest进入主界面:<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/07.jpg" alt></li></ul><h1 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h1><p>该模式将消息发送到<strong>指定的队列中</strong>，它不需要绑定交换器</p><blockquote><p>环境：springboot</p></blockquote><ol><li><p><strong>核心依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  rabbitmq:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.181</span><span class="number">.128</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">guest</span></span><br><span class="line"><span class="attr">    password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">"direct_name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定队列名称和是否持久化</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">directQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUE_NAME, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意其Queue所在的包: org.springframework.amqp.core.Queue</p><ol start="4"><li><strong>消息生产者</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">senMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 指定要发送的队列和数据</span></span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.QUEUE_NAME, <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"lisi"</span>, <span class="string">"1234"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>发送消息之后在页面客户端显示如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/08.jpg" alt></p><ol start="5"><li><strong>消息消费者</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = RabbitMQConfig.QUEUE_NAME) <span class="comment">// 监听的队列是哪个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span> <span class="comment">// 处理业务代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerMsg</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"消费的信息为: &#123;&#125;"</span>, user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>启动application后，自动会获取到消息，以及界面此时队列的信息total为0<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/09.jpg" alt><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/10.jpg" alt></p><h1 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h1><p>该模式与rocketMQ的广播模式一样，也就是说消息可被多个服务所读取</p><ul><li>rabbitMQ会将消息发送给交换器，而交换器会转发到与它绑定的队列中</li><li>发送消息时，需要指定交换器名称，不需要指定队列名称(“”表示)</li></ul><h2 id="创建两个队列并绑定到一个交换器中"><a href="#创建两个队列并绑定到一个交换器中" class="headerlink" title="创建两个队列并绑定到一个交换器中"></a>创建两个队列并绑定到一个交换器中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定交换器名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME = <span class="string">"exchange_name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUQ_ONE_NAME = <span class="string">"queue_one"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUQ_TWO_NAME = <span class="string">"queue_two"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUQ_ONE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUQ_TWO_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定第一个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingA</span><span class="params">(Queue queueOne, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueOne).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定第二个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingB</span><span class="params">(Queue queueTwo, FanoutExchange fanoutExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueTwo).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">senMsgToMany</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 发送消息到交换器即可，它会负责转发到指定的队列</span></span><br><span class="line">        rabbitTemplate.convertAndSend(FanoutRabbitConfig.EXCHANGE_NAME, <span class="string">""</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时客户端界面有如下信息<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/11.jpg" alt></p><h2 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h2><ul><li><p>队列一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = FanoutRabbitConfig.QUEUQ_ONE_NAME) <span class="comment">// 指定消费的队列</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumerOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"One队列监听到消息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = FanoutRabbitConfig.QUEUQ_TWO_NAME)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConsumerTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"Two队列监听到消息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>启动服务有日志如下信息<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/12.jpg" alt></p><h1 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h1><p>topic 是RabbitMQ中最灵活的一种方式，可以根据routing_key自由的绑定不同的队列</p><h2 id="创建两个队列绑定到主题"><a href="#创建两个队列绑定到主题" class="headerlink" title="创建两个队列绑定到主题"></a>创建两个队列绑定到主题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRabbitConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定交换器名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOP_EXCHANGE = <span class="string">"top_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUQ_ONE_NAME = <span class="string">"topic.message"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUQ_TWO_NAME = <span class="string">"topic.messages"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUQ_ONE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(QUEUQ_TWO_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个主题交换器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(TOP_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定队列</span></span><br><span class="line">    <span class="comment">// .with("topic.message") 表示 one这个队列只匹配topic.message</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingA</span><span class="params">(Queue one, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(one).to(exchange).with(<span class="string">"topic.message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with("topic.#") 表示 two这个队列同时匹配两个队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingB</span><span class="params">(Queue two, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(two).to(exchange).with(<span class="string">"topic.#"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>one队列只匹配一个topic.message, 而two队列匹配上述队列中的所有队列（因为topic.开头）</p><h2 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列一</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic_Message</span><span class="params">()</span></span>&#123;      </span><br><span class="line">        rabbitTemplate.convertAndSend(TopicRabbitConfig.TOP_EXCHANGE,  <span class="string">"topic.12313"</span>,<span class="string">"i am message one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTopic_Messages</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(TopicRabbitConfig.TOP_EXCHANGE, <span class="string">"topic.message"</span>, <span class="string">"i am message two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>topic.12313它会匹配到队列中的topic.# 也就是队列two:</li><li>topic.message它会匹配到队列中的topic.message和topic.#</li><li>输出结果观察启动类日志如下</li></ul><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/13.jpg" alt><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/14.jpg" alt></p><h2 id="消费消息-1"><a href="#消费消息-1" class="headerlink" title="消费消息"></a>消费消息</h2><ul><li><p>队列一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = TopicRabbitConfig.QUEUQ_ONE_NAME)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumerOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"One-message队列信息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>队列二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = TopicRabbitConfig.QUEUQ_TWO_NAME)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicConsumerTwo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"Two-messages队列信息: &#123;&#125;"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol start="4"><li>直接模式Direct：将消息发送到指定的队列中，只有一个消费者消费。发送消息要指定队列名称</li><li>广播模式Fanout Exchange：将消息发送到多个队列中，广播模式，可被多个消费者所消费。发送消息要指定交换器名称即可，队列名称不需要</li><li>主题模式(Topic)：根据不同的主题(字符串匹配)会发送到不同的队列中</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RabbitMQ简介&quot;&gt;&lt;a href=&quot;#RabbitMQ简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ简介&quot;&gt;&lt;/a&gt;RabbitMQ简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;代码：&lt;a href=&quot;https://githu
      
    
    </summary>
    
      <category term="mq" scheme="http://yoursite.com/categories/mq/"/>
    
    
      <category term="rabbitMQ" scheme="http://yoursite.com/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件</title>
    <link href="http://yoursite.com/2019/04/28/mq/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/04/28/mq/消息中间件/</id>
    <published>2019-04-27T17:25:34.000Z</published>
    <updated>2019-04-27T18:43:12.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息中间件简介"><a href="#消息中间件简介" class="headerlink" title="消息中间件简介"></a>消息中间件简介</h1><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构],使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。如下是MQ的一些使用场景介绍</p><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>场景说明：用户注册后，需要发注册邮件和注册短信</p><ul><li><p>通常我们的做法是：讲注册信息存储到数据库，之后发送邮件、发送短信<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/01.jpg" alt><br>传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈</p></li><li><p>引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/02.jpg" alt></p></li></ul><h2 id="应用耦合"><a href="#应用耦合" class="headerlink" title="应用耦合"></a>应用耦合</h2><p>场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口，如下图<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/03.jpg" alt></p><ul><li><p>缺点:<br><strong>如果库存服务无法访问，则订单服务减库存失败，导致订单系统也失败，明细耦合度太高</strong>。</p></li><li><p>引入消息队列结构如下图：<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/04.jpg" alt></p></li></ul><ol><li>订单系统：用户下单将消息写入消息队列</li><li>库存系统：订阅下单消息，进行库存的操作</li><li>下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</li></ol><h2 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h2><p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列</p><ul><li>可以控制活动的人数</li><li>可以缓解短时间内高流量压垮应用<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/rabbitMQ/05.jpg" alt></li></ul><ol><li>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</li><li>秒杀业务根据消息队列中的请求信息，再做后续处理</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>消息队列使用场景</li></ul><ol><li>应用解耦：A服务访问B服务，如果B服务挂了，那么会导致A服务调用错误。我们可以将A服务发送消息到MQ中，然后不再关系其他后续操作。由B服务订阅这个消息来处理业务</li><li>异步处理：用户注册之后发送邮箱激活和短信激活，传统的做法是三个任务一起完成之后返回（响应150ms）。我们可以在用户注册之后发送广播消息，此时另外两个服务订阅处理（响应50ms）</li><li>流量削锋：例如在秒杀场景，一般流量会很大，可能会导致服务挂了。我们可在用户请求之后，先加入到队列中。如果队列超过了一定的值，进行处理</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息中间件简介&quot;&gt;&lt;a href=&quot;#消息中间件简介&quot; class=&quot;headerlink&quot; title=&quot;消息中间件简介&quot;&gt;&lt;/a&gt;消息中间件简介&lt;/h1&gt;&lt;p&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用
      
    
    </summary>
    
      <category term="mq" scheme="http://yoursite.com/categories/mq/"/>
    
    
      <category term="消息中间件" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>高并发解决方案</title>
    <link href="http://yoursite.com/2019/04/26/concurrence/%E9%AB%98%E5%B9%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2019/04/26/concurrence/高并解决方案/</id>
    <published>2019-04-25T17:58:54.000Z</published>
    <updated>2019-04-27T18:25:21.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><blockquote><p>所有代码: <a href="https://github.com/zhongjinlang/concurrent" target="_blank" rel="noopener">https://github.com/zhongjinlang/concurrent</a></p></blockquote><p>简单点的升级内存,复杂点的,增加服务器,分担压力</p><ul><li>垂直扩容：提高系统部件能力</li><li>水平扩容：增加更多系统成员来实现</li></ul><p><strong>扩容数据库</strong></p><ul><li>读操作扩展：redis、CDN等缓存</li><li>写操作扩展：Cassandra、Hbase等</li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>应用需要支撑大量并发量，但数据库的性能有限，所以使用缓存来减少数据库压力与提高访问性能</p><p><strong>缓存特性</strong></p><ul><li>命中率 = 命中数 / （命中数 + 没有命中数）</li><li>最大元素(空间)</li><li>清空策略：FIFO/LFU/LRU/过期时间/随机</li></ul><p><strong>影响缓存命中率的因素</strong></p><ol><li>业务场景和业务需求<br>缓存通常适合读多写少的业务场景，反之的使用意义并不多，命中率会很低</li><li>缓存的设计（策略和粒度)<br>通常情况下缓存的粒度越小，命中率越高</li><li>缓存的容量和基础设施<br>缓存的容量有限就会容易引起缓存的失效和被淘汰</li></ol><p><strong>缓存分类和应用场景</strong></p><ul><li>本地缓存：变成实现(成员变量、局部变量、静态变量)、guava cache</li><li>分布式缓存: memcache、redis</li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一</p><p><strong>发送短信使用场景</strong><br>比如用户下单成功时给用户发短信，如果没有这个消息队列，我们会选择同步调用发短信的接口，并等待短息发送成功，这时候假设短信接口实现出现问题了，或者短信调用端超时了，又或者短信发送达到上限了，我们是选择重试几次还是放弃，还是选择把这个放到数据库过一段时间再看看呢，不管怎样，实现都很复杂<br><br>我们可以将发短信这个请求放在消息队列里，消息队列按照一定的顺序挨个处理队列里的消息，当处理到发送短信的任务时，通知短信服务发送消息，如果出现之前出现的问题，那么把这个消息重新放到消息队列中</p><p><strong>消息队列的好处</strong></p><ol><li>成功完成了一个<strong>异步解耦</strong>的过程</li><li>保证了<strong>最终一致性</strong>，通过在队列中存放任务保证它最终一定会执行</li><li><strong>广播</strong>, 如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量</li><li>提速, 有了消息队列就<strong>不需要同步等待</strong>，我们可以直接并行处理</li><li><strong>削峰和流控</strong>,不对于不需要实时处理的请求来说，当并发量特别大的时候，可以先在消息队列中作缓存，然后陆续发送给对应的服务去处理</li></ol><h1 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h1><p>单个服务器再优化，它的处理能力都是有上限的。随着项目需求完成越来越多，应用自然也会越来越大，架构师将一个应用整体拆分成多个应用</p><p><strong>拆分的原则</strong></p><ol><li>业务优先，确定业务边界</li><li>循序渐进，边拆分边测试</li><li>兼顾技术：重构、分层</li><li>可靠测试</li></ol><p><em>拆分的思考</em></p><ol><li>应用之间的通信：RPC（dubbo等）、消息队列</li><li>应用之间的数据库设计：每个应用都有独立的数据库</li><li>避免事务操作跨应用，分布式事务是一个非常消耗资源的问题。这样应用和应用的耦合度降低</li></ol><p><em>应用拆分</em></p><ul><li>服务化——Dubbo</li><li>微服务——SpringCloud</li></ul><h1 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h1><p>限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等<br></p><blockquote><p>限流本质上是控制某段代码在一定时间内执行的次数</p></blockquote><p><strong>限流算法</strong></p><ol><li>计数器</li><li>漏桶算法</li><li>令牌桶算法</li></ol><h1 id="服务降级与服务熔断"><a href="#服务降级与服务熔断" class="headerlink" title="服务降级与服务熔断"></a>服务降级与服务熔断</h1><p><strong>服务降级</strong><br>服务压力剧增的时候根据当前的业务情况及流量对一些服务和页面有策略的降级，以此缓解服务器的压力，以保证核心任务的进行。<br>同时保证部分甚至大部分任务客户能得到正确的相应。也就是当前的请求处理不了了或者出错了，给一个默认的返回</p><p><strong>服务熔断</strong><br>在股票市场，熔断这个词大家都不陌生，是指当股指波幅达到某个点后，交易所为控制风险采取的暂停交易措施。相应的，服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>限流：控制一段代码在一定时间内执行的次数</li><li>服务降级：服务器压力很大的时间，但又要给客户端响应正确的数据，可以设计好一个默认的返回信息</li><li>服务熔断：为了防止服务器系统故障，采取的一种保护措施</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;扩容&quot;&gt;&lt;a href=&quot;#扩容&quot; class=&quot;headerlink&quot; title=&quot;扩容&quot;&gt;&lt;/a&gt;扩容&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;所有代码: &lt;a href=&quot;https://github.com/zhongjinlang/concurrent
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="限流" scheme="http://yoursite.com/tags/%E9%99%90%E6%B5%81/"/>
    
      <category term="降级" scheme="http://yoursite.com/tags/%E9%99%8D%E7%BA%A7/"/>
    
      <category term="熔断" scheme="http://yoursite.com/tags/%E7%86%94%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://yoursite.com/2019/04/26/concurrence/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/04/26/concurrence/线程池/</id>
    <published>2019-04-25T17:57:42.000Z</published>
    <updated>2019-04-25T17:57:44.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样<br>的效果</p><p><strong>new Thread的弊端</strong></p><ul><li>每次new Thread新建对象，性能差</li><li>线程缺乏统一管理，可能无限制的新建线程，互相竞争，有可能占用过多系统资源</li><li>缺少更多的功能，如更多的执行、定期执行、线程中断</li></ul><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类</p><p>所有的线程池</p><p><strong>构造核心参数</strong></p><ul><li>corePoolSize：核心线程数量</li><li>maximumPoolSize：线程最大线程数</li><li>workQueue: 阻塞队列，存储等待执行的任务，很重要，会对线程池允许过程产生重要影响</li><li>keepAliveTime: 表示线程没有任务执行时最多保持多久时间会终止</li><li>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性</li><li>threadFactory: 线程工厂，用来创建下线程</li><li>rejectHandler: 当拒绝处理任务时的策略</li></ul><p><strong>核心方法</strong></p><ul><li>execute()：提交任务，交给线程池执行</li><li>submit(): 提交任务，能够返回执行结果 execute + future</li><li>shutdown(): 关闭线程池，等待任务都执行完</li><li>shutdownNow(): 关闭线程之，不等待任务执行完，暂停</li></ul><p><strong>线程监控方法</strong></p><ul><li>getTaskCount(): 线程池已执行和未执行的任务总数</li><li>getCompletedTaskCount: 已完成的任务数量</li><li>getPoolSize(): 线程池当前的线程数量</li><li>getActiveCount(): 当前线程池中正在执行任务的线程数量</li></ul><p><strong>线程池类图</strong><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/25.jpg" alt></p><h2 id="四种线程池"><a href="#四种线程池" class="headerlink" title="四种线程池"></a>四种线程池</h2><p>Executors：提供了一系列静态工厂方法用于创建各种线程池<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/26.jpg" alt></p><ul><li>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</li><li>newFixedThreadPool: 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</li><li>newScheduledThreadPool: 创建一个定长线程池，支持定时及周期性任务执行</li><li>newSingleThreadExecutor: 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li></ul><p><strong>缓存线程池</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    log.info(<span class="string">"task:&#123;&#125; "</span>, index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C之AQS</title>
    <link href="http://yoursite.com/2019/04/25/concurrence/J.U.C%E4%B9%8BAQS/"/>
    <id>http://yoursite.com/2019/04/25/concurrence/J.U.C之AQS/</id>
    <published>2019-04-25T09:08:35.000Z</published>
    <updated>2019-04-25T14:39:44.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer-AQS-概述"><a href="#AbstractQueuedSynchronizer-AQS-概述" class="headerlink" title="AbstractQueuedSynchronizer(AQS)概述"></a>AbstractQueuedSynchronizer(AQS)概述</h1><p>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock、Semaphore、CountDownLatch。它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p><ul><li>使用Node实现FIFO队列，可以同于构建锁或其他同步装置的基础框架</li><li>利用了一个int类型表示状态</li><li>子类通过继承并通过实现它的方法管理其状态acquire和release的方法操纵状态</li><li>可以同时实现<em>排它锁</em>和<em>共享锁</em>模式（独占、共享）</li></ul><p><strong>JDK提供了许多AQS的子类，如下是常用的同步组件:</strong></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/13.jpg" alt><br>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行<br><br>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务<br><strong>使用场景</strong></p><ul><li>实现最大的并行性</li><li>开始执行前等待n个线程完成各自任务</li><li>死锁检测</li></ul><p><strong>使用演示</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给定测试的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            <span class="comment">// 从线程池中开启线程</span></span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用方法</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 计数器-1</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 线程等待</span></span><br><span class="line">        countDownLatch.await();      </span><br><span class="line">        log.info(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        exec.shutdown();        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/22.jpg" alt><br>使用了await，从输出结果可看出”完成”这句话是在所有线程执行完之后才执行的。因此await可保证之前的线程执行完<br>例如我们写了很多个线程去完成一个任务，希望这个任务在指定的时间内完成可使用如下代码</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>它可控制同一时间并发线程的数目</p><ul><li>通常用于限制可以访问某些资源（物理或逻辑的）线程数目</li></ul><p><strong>面试题思考</strong><br>在很多情况下，可能有多个线程需要访问数目很少的资源。假想在服务器上运行着若干个回答客户端请求的线程。这些线程需要连接到同一数据库，但任一时刻只能获得一定数目的数据库连接。你要怎样才能够有效地将这些固定数目的数据库连接分配给大量的线程？ </p><ol><li>给方法加同步锁，保证同一时刻只能有一个人去调用此方法，其他所有线程排队等待，但是此种情况下即使你的数据库链接有10个，也始终只有一个处于使用状态。这样将会大大的浪费系统资源，而且系统的运行效率非常的低下</li><li>另外一种方法当然是使用信号量，通过信号量许可与数据库可用连接数相同的数目，将大大的提高效率和性能</li></ol><p><em>演示控制并发数量</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定测试的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 给定允许的并发数</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            <span class="comment">// 从线程池中开启线程</span></span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用方法</span></span><br><span class="line">                    <span class="comment">// 对并发控制的代码前后要包裹semaphore相关函数</span></span><br><span class="line">                    semaphore.acquire(); <span class="comment">// 获得许可</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"完成"</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/23.jpg" alt><br>输出结果可看出每一秒只有3个线程。证明了Semaphore对并发的控制</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier</p><ul><li>CountDownLatch和CyclicBarrier区别</li></ul><ol><li>CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待</li><li>CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier</li></ol><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>在Java中通常实现锁有两种方式，一种是synchronized关键字，另一种是Lock。二者其实并没有什么必然联系，但是各有各的特点，在使用中可以进行取舍的使用。首先我们先对比下两者</p><ul><li>Lock接口的实现之一：ReentrantLock(可重入性)</li><li>锁的实现：synchronization基于JVM</li><li>性能的区别</li><li>功能区别</li></ul><p>ReentrantLock独有的功能(CAS算法)</p><ul><li>可指定公平锁(先等待的线程先获取锁)还是非公平锁</li><li>提供了一个Condition类，可分组唤醒需要唤醒的线程</li><li>提供了中断等待锁线程的机制，lock.lockInterruptibly()</li></ul><p><em>演示使用ReentrantLock</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是哟个JUC的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p>ReentrantReadWriteLock是Lock的另一种实现方式，我们已经知道了ReentrantLock是一个排他锁，同一时间只允许一个线程访问，而ReentrantReadWriteLock允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量</p><p><strong>使用演示</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义读锁和写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供线程安全的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getAllKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readLock.lock(); <span class="comment">// 读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock(); <span class="comment">// 写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable-Runnable"><a href="#Callable-Runnable" class="headerlink" title="Callable | Runnable"></a>Callable | Runnable</h1><p>我们知道创建线程有两种方式：继承Thread、实现Runnable接口。这两种方式都有一个缺陷：在执行完任务之后无法获取执行结果<br><br>从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果</p><p><strong>Callable与Runnable对比</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只声明了run()方法，返回值为void，所以在执行完任务之后无法返回任何结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它是一个泛型接口，call返回类型就是传递进行来的V类型。通常与ExecutorService配合使用</p><h1 id="Future-FutureTask"><a href="#Future-FutureTask" class="headerlink" title="Future | FutureTask"></a>Future | FutureTask</h1><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果等<br><br>必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果</p><p><strong>FutureTask接口定义</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</p><p><strong>Future简单使用</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程结果</span></span><br><span class="line">        ExecutorService exec= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 提交任务 获取结果</span></span><br><span class="line">        Future&lt;String&gt; future = exec.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        String result = future.get();</span><br><span class="line">        log.info(<span class="string">"result: &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/24.jpg" alt></p><p><strong>FutureTask</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(<span class="string">"result: &#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与Future对比简单了许多，直接在构造函数中创建callable接口对象</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>synchronization锁由JVM会自动加锁和解锁。Lock类的锁需要手动加锁和必须释放锁(放在finally保证安全)</li><li>当只有少量线程时推荐使用synchronization。当线程由趋势增长或可预算可使用ReentrantLock</li><li>Semaphore它可控制并发的数量</li><li>ReentrantReadWriteLock提供了读写锁</li><li>开启线程有继承Thread、实现Runnable接口，它们共同的缺陷就是在执行完任务之后无法获取执行结果。而callable接口的call方法有返回值</li><li>Future可以获取别人的线程任务方法的返回值，例如callable的 call()方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AbstractQueuedSynchronizer-AQS-概述&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer-AQS-概述&quot; class=&quot;headerlink&quot; title=&quot;AbstractQueuedSynchronizer
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>线程安全策略</title>
    <link href="http://yoursite.com/2019/04/24/concurrence/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/04/24/concurrence/线程安全策略/</id>
    <published>2019-04-23T17:18:43.000Z</published>
    <updated>2019-04-25T14:42:40.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><blockquote><p>不可变对象需要满足的条件</p></blockquote><ol><li>对象创建后状态不能修改</li><li>对象所有的域都是final</li><li>对象是正确创建的（在对象创建期间，this引用没有逸出）</li></ol><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>使用final来定义不可变对象</p></blockquote><p>final关键字：类、方法、变量</p><ol><li>修饰类：不能被继承</li><li>修饰方法：锁定方法不被继承类修改</li><li>修饰变量：基本数据类型变量（数值被初始化后不能被修改）、引用类型的变量（对象被初始后不能改变引用）</li></ol><p><em>使用final修饰变量和引用</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 基础数据类型不可修改</span></span><br><span class="line">        <span class="comment">//a = 2;</span></span><br><span class="line">        <span class="comment">//b = "3";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不可改变引用</span></span><br><span class="line">        <span class="comment">//map = Maps.newLinkedHashMap();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有安全发布可使用，它是线程不安全的</span></span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>final修饰引用数据类型不可改变引用。<strong>但是可修改值</strong>，所以Map是线程不安全的类</p><h2 id="collections-unmodifiable"><a href="#collections-unmodifiable" class="headerlink" title="collections.unmodifiable"></a>collections.unmodifiable</h2><p>除了final，JDK还提供了utils.collections.unmodifiable前缀的方法来定义不可变的对象</p><p><em>使用unmodifiableMap</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 处理后的map不可被修改</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>)); <span class="comment">// 不可操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用unmodifiableMap使得map对象的值不可修改，因此上述代码达到了线程安全</p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/18.jpg" alt></p><h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><p>通过不可变对象在多个线程之间保证对象是线程安全的。归根到底我们是躲避了并发的问题。避免并发除了设计不可变对象，还有一个方法<em>线程封闭</em>：就是把对象封装到一个线程中，只有一个线程能看到该对象</p><p><strong>Ad-hoc</strong><br>完全使用逻辑代码来控制实现，最糟糕的方法</p><p><strong>堆栈封闭</strong><br>局部变量，多个线程访问一个方法的时候，方法中的局部变量都会被<em>拷贝</em>到一份到线程的栈中（我们经常在方法中声明的变量 ）</p><p><strong>ThreadLoad线程封闭</strong><br>特别好的封闭方法，内部实现通过一个mao，key是线程的名称，value为要封闭的对象。每一个线程中的对象都对应着它的map中的值</p><h1 id="线程不安全类与写法"><a href="#线程不安全类与写法" class="headerlink" title="线程不安全类与写法"></a>线程不安全类与写法</h1><p><em>线程不安全</em>：如果一个类的对象同时可以被多个线程访问，如果没有做同步或并发处理。那么可能就会表现出线程不安全的现象<br><br>本节介绍JDK自带的一些常用的类，这些类都不是线程安全的。</p><h2 id="StringBuilder-StringBuffer"><a href="#StringBuilder-StringBuffer" class="headerlink" title="StringBuilder | StringBuffer"></a>StringBuilder | StringBuffer</h2><ul><li>StringBuilder是线程不安全的，性能高</li><li>StringBuffer是线程安全的，性能低</li></ul><p><em>测试StringBuilder是否是线程安全</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExampele1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 输出累加字符串个数</span></span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的个数不稳定，因此StringBuilder不是线程安全的。而采用StringBuffer是线程安全的<br><em>分析StringBuffer源码分析</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">     toStringCache = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">super</span>.append(str);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p><em>SimpleDateFormat的错误写法</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormateExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 并不是局部变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            simpleDateFormat.parse(<span class="string">"2019422"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码运行会有异常。这是常犯的错误，如果我们将对象声明为局部变量（堆栈封闭）就不会有这种情况了</p><p><em>正确的写法</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串累加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">    simpleDateFormat.parse(<span class="string">"2019422"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次声明一个对象来使用这样就不会出现线程不安全带来的异常</p><h2 id="ArrayList-HashSet-HashMap"><a href="#ArrayList-HashSet-HashMap" class="headerlink" title="ArrayList | HashSet | HashMap"></a>ArrayList | HashSet | HashMap</h2><p>集合类是我们最为常用的类，通常我们都将其定义在方法中（局部变量）。因此很少出现线程不安全的情况。但是一但当定义为static时且有多个线程修改时，就容易出现线程不安全的问题</p><p><strong>ArrayList</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果不是我们期望的值，说明arraylist在做add时有可能线程不安全。当然HashSet和HashMap同理</p><h1 id="写法需要多考虑"><a href="#写法需要多考虑" class="headerlink" title="写法需要多考虑"></a>写法需要多考虑</h1><p>线程不安全的写法通常是这样的：<strong>先检查再执行</strong>，例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断某个值)&#123;</span><br><span class="line">  <span class="comment">// 处理某个值...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们思考一下这种写法，当判断的时候它可能满足条件，如果两个线程都进入了判断，那么都会分别进行处理，这个时就会产生线程不安全。<br><br>出现不安全的点在于，分成了两个操作之后j即使之前的过程(判断)是线程安全的，后面(处理)也是线程安全的，但它们”间隙的过程中”并不是<em>原子性的</em><br><br>实际开发中，当我们在判断一个对象是否满足某个条件再执行某些处理的时候，需要考虑到这个对象是否是多线程共享的，如果是，那么就需要将对象加锁。或保证它们的操作具有原子性的</p><h1 id="线同步容器"><a href="#线同步容器" class="headerlink" title="线同步容器"></a>线同步容器</h1><p>针对上述线程不安全的类ArrayList、HashSet、HashMap。JDK提供了对应的线程安全的类来使用</p><h2 id="ArrayList-gt-Vectory-Stack"><a href="#ArrayList-gt-Vectory-Stack" class="headerlink" title="ArrayList &gt; Vectory | Stack"></a>ArrayList &gt; Vectory | Stack</h2><p>Vectory和stack类结构:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, ...</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;<span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用vector测试线程安全</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察其add的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>同步器也有不安全的情况</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步容器也有线程不安全的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectoryExample2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 向集合中存10个值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * vector虽然能保证同一时刻只有一个线程能访问他，但是不排除如下情况</span></span><br><span class="line"><span class="comment">             * 1. 当t2线程执行到i &lt; list.size()时，t1线程也可能执行了i &lt; list.size()，它正好将当前i元素移出掉了</span></span><br><span class="line"><span class="comment">             * 2. 这个时候get方法就获取不了所删除的元素了，因此抛出数组越界异常</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 开启两个线程</span></span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">                    list.remove(i); <span class="comment">// 删除(synchronization)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">                    list.get(i); <span class="comment">// 获取(synchronization)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动两个线程</span></span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HashMap-gt-HashTable"><a href="#HashMap-gt-HashTable" class="headerlink" title="HashMap &gt; HashTable"></a>HashMap &gt; HashTable</h2><p>HashTable与HashMap不同，前者key和value不能为null。后者可以<br>HashTable类结构<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, ...</span></span><br></pre></td></tr></table></figure></p><p><strong>HashTable演示线程安全</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTableExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        map.put(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察其put的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure the value is not null</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure></p><h2 id="Collections-synchronization"><a href="#Collections-synchronization" class="headerlink" title="Collections.synchronization.."></a>Collections.synchronization..</h2><p>使用集合工具类来创建同步容器类</p><p><strong>将List构建为同步容器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将List构建为同步的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList() );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 线程执行完输出</span></span><br><span class="line">        log.info(<span class="string">"size: &#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是线程安全的</p><h2 id="List-remove注意事项"><a href="#List-remove注意事项" class="headerlink" title="List.remove注意事项"></a>List.remove注意事项</h2><p>演示遍历集合并删除集合中指定元素的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectoryExample3</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三个方法：遍历集合对指定元素删除</span></span><br><span class="line">    <span class="comment">// ConcurrentModificationException</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer data : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Integer data = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (data.equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(Vector&lt;Integer&gt; v1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.get(i).equals(<span class="number">3</span>))&#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        vector.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        test1(vector);</span><br><span class="line">        <span class="comment">//test2(vector);</span></span><br><span class="line">        <span class="comment">//test3(vector);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行会出现如下异常信息<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/19.jpg" alt><br>我们进入checkForComodification观察源代码<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/20.jpg" alt><br>我们可以发现，对于一个集合遍历的同时，如果对集合进行修改的操作导致了modCount和expectedModCount不一致，从而抛出该异常</p><p><strong>结论</strong></p><ul><li>如果使用了foreach和iterator循环集合时，尽量不要在操作过程中做remove等相关的更新操作</li><li>如果需要删除，使用iterator.remove()方法，或for循环获取id再进行删除</li></ul><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>JDK提供了线程安全的集合和Map，在utils.concurrent包</p><ul><li>ArrayList-&gt; CopyOnWriteArrayList</li><li>HashSet-&gt; CopyOnWriteArraySet</li><li>TreeSet-&gt; ConcurrentSkipListSet</li></ul><p><strong>CopyOnWriteArrayList</strong><br>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而<strong>不需要加锁</strong>，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。使用场景：读多写少</p><ul><li>观察其add方法实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">// 采用lock锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 拷贝数组</span></span><br><span class="line">           newElements[len] = e; <span class="comment">// 创建一个数组后指向新的数组</span></span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>JDK提供的线程安全类<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/21.jpg" alt></p></li><li><p>根据实际分析变量，是否可以变为不可变对象，如果可以尽量将一个对象变为不可变对象。这样在多线程环境下就不会出现线程安全问题</p></li><li>线程封闭: 把对象封装到一个线程中，只有一个线程可以看到这个对象(ThreadLoad)</li><li>List删除指定元素要注意可能会抛出ConcurrentModificationException。解iterator.remove()方法或for循环或id再进行删除。如果在多线程环境下采用synchronization或并发容器代替vector(同步容器)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;不可变对象&quot;&gt;&lt;a href=&quot;#不可变对象&quot; class=&quot;headerlink&quot; title=&quot;不可变对象&quot;&gt;&lt;/a&gt;不可变对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;不可变对象需要满足的条件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对象创建后
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>安全发布对象</title>
    <link href="http://yoursite.com/2019/04/22/concurrence/%E5%AE%89%E5%85%A8%E5%8F%91%E5%B8%83%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/04/22/concurrence/安全发布对象/</id>
    <published>2019-04-22T09:34:20.000Z</published>
    <updated>2019-04-25T14:42:58.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是发布对象"><a href="#什么是发布对象" class="headerlink" title="什么是发布对象?"></a>什么是发布对象?</h1><p>发布对象：使一个对象能够被当前范围之外的外码所使用<br>对象逸出：一种错误的发布，当一个对象还没有构造完成时，就被其他线程所见了</p><p><em>不安全的发布对象案例</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafePublish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] status = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getStatus() &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UnsafePublish unsafePublish = <span class="keyword">new</span> UnsafePublish();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStatus())); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">        unsafePublish.getStatus()[<span class="number">0</span>] = <span class="string">"z"</span>;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, Arrays.toString(unsafePublish.getStatus())); <span class="comment">// zbc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>可能产生对象逸出</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="meta">@NotRecommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Escape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> thisCanBeEscape = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> innerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">innerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对象没有被正确构造之前就发布对象，可能会不安全</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">innerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;"</span>, Escape.<span class="keyword">this</span>.thisCanBeEscape); <span class="comment">// 启动了另一个对象引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Escape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h1><p>安全发布对象的四种方法：</p><ul><li>在静态初始化函数中初始化一个对象引用</li><li>将对象的引用保存到volatile类型域或者AtomicReference对象中</li><li>将对象的引用保存到某个正确的构造对象的final类型域中</li><li>将对象的引用保存到一个由锁保护的域中</li></ul><p>此时我们会想到采用单例模式来构建一个对象</p><h2 id="单例-懒汉模式"><a href="#单例-懒汉模式" class="headerlink" title="单例-懒汉模式"></a>单例-懒汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式：单例实例在第一次使用时创建</span></span><br><span class="line"><span class="comment"> * 单线程环境下安全，但是多线程环境不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample1 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123; <span class="comment">// 不安全，如果有其他线程进入该判断</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingleExample1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>懒汉模式线程不安全，当然可以使用synchronization修饰方法这样就线程安全了。但是不推荐，会导致性能下降</p></blockquote><h2 id="单例-饿汉模式"><a href="#单例-饿汉模式" class="headerlink" title="单例-饿汉模式"></a>单例-饿汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汗模式：单例实例在类加载时就进行创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleExample2 instance = <span class="keyword">new</span> SingleExample2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>饿汉模式是线程安全的</p></blockquote><h2 id="优化懒汉模式"><a href="#优化懒汉模式" class="headerlink" title="优化懒汉模式"></a>优化懒汉模式</h2><p><em>使用双重检测机制</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> SingleExample4 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 双从检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingleExample4.class)&#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingleExample4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：必须加上volatile否则还是线程不安全的。因为可能会导致指令重排问题。而volatile有个使用场景其中的双重检测机制</p></blockquote><h2 id="枚举发布安全对象"><a href="#枚举发布安全对象" class="headerlink" title="枚举发布安全对象"></a>枚举发布安全对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="meta">@Recommend</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleExample5</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回枚举声明的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SingleExample5 single;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给私有变量创建对象</span></span><br><span class="line">        <span class="comment">// JVM保证这个方法只会被调用一次</span></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            single = <span class="keyword">new</span> SingleExample5();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回私有变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingleExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> single;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举发布安全对象是对比单例模式更为推荐的。因为它会在实际调用的时候才会初始化，不会造成资源的浪费</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>发布对象：使一个对象能够被当前范围之外的外码所使用</li><li>对象逸出：一种错误的发布，当一个对象还没有构造完成时，就被其他线程所见了</li><li>单例-懒汉模式：对象在第一次使用时进行创建，它是线程不安全的。可使用volatile的双重检测机制来实现</li><li>单例-饿汉模式：类装载的时候就进行创建，它是线程安全的</li><li>volatile可禁止指令重排，具有有序性</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是发布对象&quot;&gt;&lt;a href=&quot;#什么是发布对象&quot; class=&quot;headerlink&quot; title=&quot;什么是发布对象?&quot;&gt;&lt;/a&gt;什么是发布对象?&lt;/h1&gt;&lt;p&gt;发布对象：使一个对象能够被当前范围之外的外码所使用&lt;br&gt;对象逸出：一种错误的发布，当一个对象还
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="单例" scheme="http://yoursite.com/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程安全性</title>
    <link href="http://yoursite.com/2019/04/22/concurrence/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/22/concurrence/线程安全性/</id>
    <published>2019-04-21T17:26:10.000Z</published>
    <updated>2019-04-25T14:43:31.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程安全性概述"><a href="#线程安全性概述" class="headerlink" title="线程安全性概述"></a>线程安全性概述</h1><p>当多个线程访问某个类时，不管运行时环境采用<em>何种调度方式</em>，或者这些进程将如何交替执行，并且在主调代码中<em>不需要任何额外的同步或协同</em>，这个类能表现出<em>正确的行为</em>，那么就称这个类是线程安全的<br><br>线程安全在主要三个方面体现：</p><ul><li><p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）</p></li><li><p>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）</p></li><li><p>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序</p></li></ul><p>我们分别对上述概念进行一一描述</p><h1 id="原子性—Atomic"><a href="#原子性—Atomic" class="headerlink" title="原子性—Atomic"></a>原子性—Atomic</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/15.jpg" alt></p><h2 id="AtomicInteger、AtomicLong、LongAdder"><a href="#AtomicInteger、AtomicLong、LongAdder" class="headerlink" title="AtomicInteger、AtomicLong、LongAdder"></a>AtomicInteger、AtomicLong、LongAdder</h2><p>将上一篇的代码修改如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Atomic</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Atomic</span></span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>此时测试数字为5000，保证了数据的一致性，我们来分析atomic源码</p></blockquote><blockquote><p>也可使用AtomicLong、LongAdder替代AtomicInteger</p></blockquote><p><strong>incrementAndGet()源码分析</strong><br><em>第一部分</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><em>第二部分</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在一个死循环内不断的尝试修改值，直到修改成功。实现原理采用CAS：</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p><blockquote><p>执行函数：CAS(V,E,N)</p><ul><li>V表示要更新的变量</li><li>E表示预期值<br>-N表示新值</li></ul></blockquote><p>CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。简单介绍一下这个指令的操作过程：首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。这一系列的操作是原子的。它们虽然看似复杂，但却是 Java 5 并发机制优于原有锁机制的根本。简单来说，CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”</p><h2 id="AtomicReference、AtomicIntegerFieldUpdater"><a href="#AtomicReference、AtomicIntegerFieldUpdater" class="headerlink" title="AtomicReference、AtomicIntegerFieldUpdater"></a>AtomicReference、AtomicIntegerFieldUpdater</h2><ul><li>AtomicReference对对象进行原子操作</li><li>AtomicIntegerFieldUpdater可以对指定类的指定 volatile int 字段进行原子更新</li></ul><p><em>AtomicReference测试原子性 </em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当为0的时候赋值2...以此类推</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count.get() ); <span class="comment">// 输出4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>AtomicIntegerFieldUpdater测试原子性</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// T: 要更新的类字节码。fieleName: 类中的字段名称(volatile修饰且非static)</span></span><br><span class="line">    <span class="comment">// 原子性更新某个类的指定字段的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;ConcurrentExample5&gt; updater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(ConcurrentExample5.class, <span class="string">"count"</span>);</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentExample5 example5 = <span class="keyword">new</span> ConcurrentExample5();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果该类的字段为100那么将其更新为120</span></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"更新成功【第一次】 &#123;&#125;"</span>, example5.getCount()); <span class="comment">// info</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"更新成功【第二次】 &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"更新失败【第二次】&#123;&#125;"</span>, example5.getCount() ); <span class="comment">// info</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExample6</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean isHappend = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"执行了:&#123;&#125;"</span>, isHappend.get() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前值为false，设置为true</span></span><br><span class="line">        <span class="keyword">if</span> (isHappend.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>))&#123;</span><br><span class="line">            log.info(<span class="string">"方法执行了:&#123;&#125;"</span>, isHappend.get() ); <span class="comment">// 执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，让test执行5000次，因为条件成立。因为条件成立了，其他线程将不会执行</p><blockquote><p>使用场景：该如何让某一段代码只执行一次，绝对不会重复</p></blockquote><h1 id="原子性—锁"><a href="#原子性—锁" class="headerlink" title="原子性—锁"></a>原子性—锁</h1><p>原子性提供了互斥访问，同一时刻只能有一个线程进行操作。能保证同一时刻只有一个线程对其操作</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>依赖特殊的CPU指令，实现代表类有：ReentrantLock</p><h2 id="synchronization"><a href="#synchronization" class="headerlink" title="synchronization"></a>synchronization</h2><p>它是Java的关键字，依赖于JVM来实现锁。因此这个关键字<strong>作用对象的作用范围内</strong>，都是同一时刻只能有一个线程</p><ul><li><p>修饰代码块：范围【大括号括起来的代码】，作用的对象【调用这个代码块的对象】</p></li><li><p>修饰方法：范围【整个方法】，作用的对象【调用这个方法的对象】</p></li><li><p>修饰静态方法：范围【整个静态方法】，作用的对象【这个类的所有对象】</p></li><li><p>修饰类：范围【括号括起来的部分】，作用的对象【这个类的所有对象】</p></li></ul><h2 id="作用于同一个对象"><a href="#作用于同一个对象" class="headerlink" title="作用于同一个对象"></a>作用于同一个对象</h2><p>验证使用synchronization修饰方法和代码块，作用于同一个对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰代码块：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample1 example1 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// 线程池：保证</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个线程输出0-9，第二个线程输出0-9…</p></blockquote><h2 id="作用于不同的对象"><a href="#作用于不同的对象" class="headerlink" title="作用于不同的对象"></a>作用于不同的对象</h2><p>验证使用不同的对象会乱序输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰代码块：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法：作用于一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample1 example1 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// TODO 再声明一个对象</span></span><br><span class="line">        SyncExample1 example2 = <span class="keyword">new</span> SyncExample1();</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test2());</span><br><span class="line">        executorService.execute(() -&gt; example2.test2()); <span class="comment">// TODO 不同的对象进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>此时输出结果为：</p></blockquote><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/16.jpg" alt></p><h2 id="作用于这个类的所有对象"><a href="#作用于这个类的所有对象" class="headerlink" title="作用于这个类的所有对象"></a>作用于这个类的所有对象</h2><p>验证使用synchronization修饰静态方法和类，作用于该类的所有对象都是线程安全的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncExample2.class)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                log.info(<span class="string">"test1 - &#123;&#125;"</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法：作用于这个类的所有对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            log.info(<span class="string">"test2 - &#123;&#125;"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncExample2 example1 = <span class="keyword">new</span> SyncExample2();</span><br><span class="line">        <span class="comment">// TODO 再声明一个对象</span></span><br><span class="line">        SyncExample2 example2 = <span class="keyword">new</span> SyncExample2();</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 开启两个线程执行方法【一个对象:example1】</span></span><br><span class="line">        executorService.execute(() -&gt; example1.test1());</span><br><span class="line">        executorService.execute(() -&gt; example2.test1()); <span class="comment">// TODO 不同的对象进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意: synchronization修饰方法和代码块不同，上述代码正确顺序执行</p></blockquote><h1 id="原子性对比"><a href="#原子性对比" class="headerlink" title="原子性对比"></a>原子性对比</h1><ul><li>synchronization：不可中断的锁，适合线程竞争不激烈的情况，可读性好</li><li>Lock：可中断的锁，多样同步，竞争激烈时能维持常态</li><li>Atmoic：竞争激烈时能维持常态，比Lock性能好。但是只能同步一个值</li></ul><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>一个线程对主内存的修改可即使的被其他线程观察到<br><br>导致共享变量在线程间不可见的原因</p><ul><li>线程交叉线执行</li><li>重排序结合线程交叉线执行</li><li>共享变量更新后的值没有在工作内存与主存之间即使更新(<em>Java内存模型</em>)</li></ul><p>对于可见性JVM提供了synchronization和volatile</p><h2 id="JVM对于synchronization的两条规定"><a href="#JVM对于synchronization的两条规定" class="headerlink" title="JVM对于synchronization的两条规定"></a>JVM对于synchronization的两条规定</h2><ul><li>线程解锁前，必须把共享变量最新的值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（加锁与解锁是同一把锁）</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。注意volatile不具备原子性</p><p>通过加入<em>内存屏障</em>和<em>静止重排序</em>优化来实现</p><ul><li>对volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存</li><li>对volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量</li></ul><p><strong>使用场景</strong><br>首先必须具备以下条件</p><ul><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ul><p><em>1. 标记变量的值</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>2.double check</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性<br></p><p>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序</p><ul><li>通过volatile、synchronization、lock</li><li>volatile静止指令重排，保证了有序性</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>原子性：原子性主要提供了互斥访问，同一时刻只能有一个线程进行操作。JDK提供了Atomic包、CAS算法、synchronization、Lock</p></li><li><p>可见性：可见性是指一个线程对主内存的修改可以即使的被其他线程观察到。JDK提供了synchronization、volatile</p></li><li><p>有序性：happens-before原则。volatile静止指令重排，保证了有序性</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程安全性概述&quot;&gt;&lt;a href=&quot;#线程安全性概述&quot; class=&quot;headerlink&quot; title=&quot;线程安全性概述&quot;&gt;&lt;/a&gt;线程安全性概述&lt;/h1&gt;&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用&lt;em&gt;何种调度方式&lt;/em&gt;，或者这些进程将如何交替执行
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="原子性" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>查询性能优化</title>
    <link href="http://yoursite.com/2019/04/21/mysql/%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/21/mysql/查询性能优化/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T08:55:21.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第六章 查询性能优化</em><br>查询优化、索引优化、库表结构优化需要齐头并进，一个不落，本章节理解MySQL如何真正的指向查询，并明白高效的低效的原因何在</p><h1 id="为什么查询速度会慢"><a href="#为什么查询速度会慢" class="headerlink" title="为什么查询速度会慢"></a>为什么查询速度会慢</h1><p>如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗一定的时间。因此我们要优化查询实际上就是优化子任务。</p><ul><li>查询生命周期：从客户，到服务器，然后再服务器上进行解析，生成指向计划，执行，后返回结果给客户端</li><li>在每一个消耗大量实际的查询案例中，都可能看到一些不必要的额外操作、重复、某些操作执行太慢等</li></ul><h1 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h1><p>查询性能低下最基本的原因是访问数据太多</p><ul><li>确认程序是否在检索大量不需要的数据</li><li>确认MySQL服务器层是否存在分析大量不需要的数据</li></ul><h2 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h2><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给MySQL服务器带来额外的负担，并增加网络开销等</p><p><strong>查询不需要的记录</strong><br>我们通常会认为MySQL只会返回需要的数据，实际MySQL是先返回全部结果集后进行计算</p><p><strong>多表关联时返回全部列</strong><br>千万不要写select * 这样会导致查询所有关联表的字段数据。应该只取需要的列</p><p><strong>总是取出所有列</strong><br>当编写select *时，会让优化器无法完成索引覆盖扫描这类优化。但也并不是坏事，如果你的程序中使用了缓存机制，可能有其好处</p><p><strong>重复查询相同的数据</strong><br>如果不断的重复执行相同的查询，每次返回完全相同的数据。比较好的解决方案是，当初次查询的时候将这个数据缓存起来。例如用户每次评论都需要查询用户头像的URL</p><h2 id="MySQL是否存在扫描额外的记录"><a href="#MySQL是否存在扫描额外的记录" class="headerlink" title="MySQL是否存在扫描额外的记录"></a>MySQL是否存在扫描额外的记录</h2><p>衡量查询开销的三个指标</p><ul><li>响应时间</li><li>扫描的行数</li><li>返回的行数</li></ul><p>它们大致反映了MySQL在内部执行查询时需要访问多少数据，并可大概推算出查询运行的时间。这三个指标都会记录到MySQL的慢日志中</p><p><strong>响应时间</strong></p><ul><li>响应时间 = 服务时间 + 排队时间<br><em>服务时间</em>：数据库处理查询真正花了多少时间，<em>排队时间</em>是指服务器因为等待某些资源而没有真正执行查询的时间——可能是I/O、锁等待…</li></ul><p><strong>扫描的行数和返回的行数</strong><br>理想情况下扫描的行数和返回的行数应该是相同的。实际情况下这种完美的事并不多</p><p><strong>扫描的行数和访问类型</strong><br>在explain语句中的type列反应了访问类型，访问类型有多种，如全表扫描(ALL)、索引扫描、范围扫描等等。这些类型速度慢到快，扫描行数多到少</p><ul><li>索引让MySQL以最高效、扫描行数最少的方式找到需要的记录</li></ul><h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><h2 id="一个复杂查询还是多个简单查询"><a href="#一个复杂查询还是多个简单查询" class="headerlink" title="一个复杂查询还是多个简单查询"></a>一个复杂查询还是多个简单查询</h2><p>设计查询时需要考虑的重要问题是，是否需要将一个复杂的查询分成多个简单的查询。在以前总是认为网络通信，查询解析是一件代价很高的事情</p><ul><li>第一种情况不必考虑，现代网络比以前快很多</li><li>第二种情况其实在MySQL设计中连接和断开连接的处理非常高效，每秒内部能扫描百万行数据</li></ul><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>有时候对一个大的查询我们可将切分小查询，例如删除旧的数据，将一个大的delete语句切分成多个较小的查询</p><ul><li>每次删除数据后，都暂停一会再做下一次删除，这样可以将服务器上原本一次性的压力分散到一个时间很长的时间段中</li></ul><h2 id="分散关联查询"><a href="#分散关联查询" class="headerlink" title="分散关联查询"></a>分散关联查询</h2><p>例如做多表关联查询，有如下语句<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag</span><br><span class="line"><span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag.id=tag.id</span><br><span class="line"><span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">where</span> tag.tag=<span class="string">'mysql'</span></span><br></pre></td></tr></table></figure></p><p>可以分解为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag=<span class="string">'mysql'</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=?</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span>(?)</span><br></pre></td></tr></table></figure></p><p><em>分解关联查询有如下优势：</em></p><ul><li>让缓存效率更高，方便其他程序从缓存中查询单表对象</li><li>执行单个查询减少锁的竞争</li><li>对数据拆分，做到高性能和可扩展等</li></ul><h1 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h1><p>MySQL执行一个查询的流程：<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/mysql-phone/mysql-001.jpg" alt></p><ul><li>客户端发送一条查询语句给服务器</li><li>服务器检查查询缓存，如果缓存中有数据，直接返回。否则进入下一个阶段</li><li>服务器进行SQL解析，预处理再由优化器生成对应的执行计划</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</li><li>最后将结果返回客户端</li></ul><p>我们对其上述的流程进一步的解析</p><h2 id="MySQL客户端-服务器通信协议"><a href="#MySQL客户端-服务器通信协议" class="headerlink" title="MySQL客户端/服务器通信协议"></a>MySQL客户端/服务器通信协议</h2><p>在任何一个时刻，要么由服务器向客户端发送数据，要么客户端向服务器发送数据，这两个动作不能同时发生。</p><ul><li>客户端用一个单独的数据包将查询传给服务器，一旦客户端发送了请求，它能做的事就只能等待</li><li>相反，服务器响应给客户端的数据通常很多，由多个数据包组成。当开始响应时，客户端必须完整接收整个返回结果，并不能简单的取出前面几条结果（<em>类似拉取数据的过程</em>）</li><li>获取结果集看上去是从MySQL服务器获取，实际从函数库(<em>连接MySQL的库函数</em>)的缓存中获取数据</li></ul><p><strong>查询状态</strong><br>对于一个MySQL连接，或者说一个线程，任何时刻都由一个连接状态，该状态表示了MySQL当前在做什么。使用<em>SHOW FULL PROCESSLIST</em>命令查询，command列表示当前的状态。有如下状态：</p><ul><li>sleep：线程正在等待客户端发送新的请求</li><li>query：线程正在执行查询或正在将结果发送给客户端</li><li>locked：在MySQL服务层，该线程等待表锁</li><li>analyzeing and statisticas：线程正在收集存储引擎的统计信息，并生成查询的执行计划</li><li>copying to table [on disk]：线程正在执行查询，并将结果集复制到一个临时表中，这种状态通常在做group by union等 </li><li>sorting result：线程正在对结果集进行排序</li><li>sending data：多种情况，线程可能在多个状态之间传送数据，或者在生成结果集等</li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>这里指的是query cache</p></blockquote><p>在解析一个查询语句之前，如果缓存开启，MySQL会优先检查这个查询是否在缓存，是直接返回，否则下一个阶段</p><h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>此阶段进入查询优化，目标是将一个SQL转换成一个执行计划。MySQL会根据执行计划和存储引擎机械进行交互。这包含了多个子阶段：解析SQL、预处理、优化SQL执行计划，如果该过程有任何错误都可能和终止查询</p><p><strong>语法解析器和预处理</strong><br>MySQL会将SQL语句解析为对应的<em>解析树</em>，检查数据表和数据列是否存在、正确等</p><p><strong>查询优化器</strong><br>优化器是将SQL转换成执行计划，一条查询可以有多种执行方式，最后都返回相同的值。查询优化器是一个非常复杂的部件，它使用了很多优化策略来生成一个最优的执行计划</p><h2 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h2><p>MySQL根据执行计划给出的指令逐步执行，在该过程中，有大量的操作需要通过调用存储引擎实现的接口来完成，这些接口称为’handler  API’</p><h2 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h2><p>最后一个阶段是将结果返回客户端，如果查询可以被缓存，那么MySQL在这个阶段会将结果存放到查询缓存中</p><h1 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h1><p>如果对优化器选择的执行计划不满意，可使用优化器提供的几个提示(hint)来控制最终的执行计划</p><p><em>sql_small_result和sql_big_result</em><br>sql_smqll_result告诉优化器结果集很少，可以将结果集放在内存中的索引临时表，以避免排序操作。sql_big_result则告诉优化器结果集可能非常大，建议使用磁盘临时表做排序操作</p><blockquote><p>p233介绍了更多了的hint</p></blockquote><h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><blockquote><p>本节介绍的多数优化技巧都是和特定的版本有关的，对于其他版本未必适用</p></blockquote><h2 id="优化count"><a href="#优化count" class="headerlink" title="优化count()"></a>优化count()</h2><p>count聚合函数：可统计某个列值的数量，也可统计行数</p><ul><li>使用count(*)时，并不会像我们猜想的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计所有的行数</li><li>如果希望知道的是结果集的行数，最好使用count(*)，这样写意义清晰，性能也会更好</li></ul><h2 id="优化group-by和distinct"><a href="#优化group-by和distinct" class="headerlink" title="优化group by和distinct"></a>优化group by和distinct</h2><p>使用sql_big_result和sql_small_result来让优化器按照你希望的方式运行</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>优化数据访问：访问的数据量过大，是否查询了不必要的数据</li><li>重构查询方式：将大的查询切分成小的查询，例如将多表查询分成单表查询</li><li>理解查询是如何被执行的，以及时间都消耗在那些地方</li><li>优化通常需要三管齐下，不做(查询缓存)，少做，快速的做</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第六章 查询性能优化&lt;/em&gt;&lt;br&gt;查询优化、索引优化、库表结构优
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>并发基础</title>
    <link href="http://yoursite.com/2019/04/21/concurrence/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/21/concurrence/并发基础/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-21T17:33:31.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><em>并发</em>：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运行在多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可同时运行<br></p><p><em>高并发(high concurrent)</em>：是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够<em>同时并行处理</em>很多请求</p><ul><li>并发：多个线程操作相同的资源，保证线程安全，合理使用资源</li><li>高并发：服务能同时处理很多请求，提高程序性能</li></ul><h1 id="CPU多级缓存"><a href="#CPU多级缓存" class="headerlink" title="CPU多级缓存"></a>CPU多级缓存</h1><p>随着现代半导体工艺的发展，CPU的频率越来远快，相对内存快了一个数量级，对于访存的操作CPU就需要等待主存，这样会导致资源的白白浪费。所以cache的出现是为了解决CPU与内存速度不匹配的问题<br></p><p>cache 的工作原理是基于“局部性”原理，它包含以下两个方面：</p><ul><li>时间局部性：如果某个数据被访问，那么不久将来它很可能再次被访问</li><li>空间局部性：如果某个数据被访问，那么与它相邻的数据也可能被访问</li></ul><p>cache中保存着cpu刚用过的数据或者是循环使用的数据，这时，从cache中读取数据就会很快，减少了cpu等待的时间，提高了系统的性能</p><h2 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h2><p>cache 给系统带来性能上飞跃的同时，也引入了新的问题“缓存一致性问题”。设想如下场景（cpu一共有两个核，core1和core2）：<br>以i++为例，i的初始值是0.那么在开始每个核都存储了i的值0，当第core1块做i++的时候，其缓存中的值变成了1，即使马上回写到主内存，那么在回写之后core2缓存中的i值依然是0，其执行i++，回写到内存就会覆盖第一块内核的操作，使得最终的结果是1，而不是预期中的2</p><h1 id="缓存一致性-MESI"><a href="#缓存一致性-MESI" class="headerlink" title="缓存一致性(MESI)"></a>缓存一致性(MESI)</h1><p>为了达到数据访问的一致，需要各个处理器在访问缓存时遵循一些协议，在读写时根据协议来操作，常见的协议有MSI，MESI，MOSI等。我们介绍其中最经典的MESI协议</p><p>在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：</p><ul><li>M(Modified): 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中</li><li>E(Exclusive): 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中</li><li>S(Shared): 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中</li><li>I(Invalid): 这行数据无效</li></ul><p><strong>CPU多级缓存-乱序执行优化</strong><br>处理器为提高运算速度而做出违背代码原有顺序的优化</p><p><strong>乱序执行优化出现问题的原因</strong><br>在单核时代处理器做出的优化可以保证执行结果不会远离预期目标，但是，在多核时代却并非如此。在多核时代，同时会有多个核同时执行指令，每一个核的指令都可能被乱序。另外,处理器还引入了L1，L2,…,Ln等多级缓存机制，每个核心都有自己的缓存机制，这样就导致了逻辑次序上后写入内存的数据未必真的最后写入。最后就带来一个问题，如果不做任何防护措施，处理器最终得出的结果和逻辑得出结果会大不相同。比如，在一个核上执行写入操作，并在最后写一个标记用来表示操作完毕，之后从另外一个核上通过判断这个标记来判定所需要的数据是否已经就绪，这种做法就存在一定风险：标记位先被写入但之前的操作却并未完成(可能是未计算完成，也可能是数据没有从处理器缓存刷新到主存中，最终导致另外的核使用了错误的数据)</p><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/01.jpg" alt></p><p>JMM规定了线程的工作内存和主内存的交互关系，以及线程之间的可见性和程序的执行顺序。一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。JMM对程序员屏蔽了CPU以及OS内存的使用问题，能够使程序在不同的CPU和OS内存上都能够达到预期的效果。</p><p>Java采用内存共享的模式来实现线程之间的通信。编译器和处理器可以对程序进行重排序优化处理，但是需要遵守一些规则，不能随意重排序</p><h2 id="Java内存模型—同步八种操作"><a href="#Java内存模型—同步八种操作" class="headerlink" title="Java内存模型—同步八种操作"></a>Java内存模型—同步八种操作</h2><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/17.jpg" alt></p><ul><li><p>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</p></li><li><p>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</p></li><li><p>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</p></li><li><p>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</p></li><li><p>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</p></li><li><p>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</p></li><li><p>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</p></li><li><p>write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中</p></li></ul><h2 id="同步规则分析"><a href="#同步规则分析" class="headerlink" title="同步规则分析"></a>同步规则分析</h2><ul><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步会主内存中</p></li><li><p>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</p></li><li><p>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。</p></li><li><p>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</p></li></ul><p>-对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</p><h1 id="并发的优势和风险"><a href="#并发的优势和风险" class="headerlink" title="并发的优势和风险"></a>并发的优势和风险</h1><p><em>优势</em>:</p><ul><li>速度：同时处理多个请求，响应更快；复杂的操作可以分成多个进程（或线程）同时进行</li><li>设计：程序设计在某些情况下更简单，也可以有更多的选择</li><li>资源利用：CPU能够等待IO的时候能够做一些其他的事情</li></ul><p><em>风险</em>:</p><ul><li>安全性：多个线程共享数据时可能会产生于期望不相符的结果</li><li>活跃性：某个操作无法继续进行下去时，就会发生活跃性问题。比如：死锁、饥饿等问题。</li><li>性能：线程过多时会使得：CPU频繁切换，调度时间增多；同步机制；消耗过多内存</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>CPU多级缓存：缓存一致性、乱序执行优化</li><li>Java内存模型： JMM规定、抽象结构、同步八种操作以及规则</li><li>Java并发的优势与风险</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;em&gt;并发&lt;/em&gt;：同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程会交替执行，这些线程是同时存在的。如果运
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发压力测试</title>
    <link href="http://yoursite.com/2019/04/21/concurrence/%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2019/04/21/concurrence/并发压力测试/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-21T17:34:14.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h1><p>Postman 是一个很强大的 API调试、Http请求的工具</p><ul><li>我们将测试如下接口, 环境：springboot<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>@Slf4j采用了lombok简化了代码，它可直接使用log.info()使用日志对象</p></blockquote><p><strong>使用之前我们先配置全局参数，方便日后的使用</strong></p><ul><li><p>设置全局变量<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/02.jpg" alt></p></li><li><p>定义全局变量参数<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/03.jpg" alt></p></li><li><p>测试接口<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/04.jpg" alt></p></li></ul><h2 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h2><p>创建一个分类目录，将上述的测试接口添加到该目录中，点击run<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/05.jpg" alt></p><ul><li>此时会出现新的窗口，进行并发测试<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/06.jpg" alt></li></ul><h1 id="apache-benche"><a href="#apache-benche" class="headerlink" title="apache benche"></a>apache benche</h1><p>ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控</p><blockquote><p>download: <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></p></blockquote><ul><li><p>ab命令进行并发测试<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/07.jpg" alt></p></li><li><p>测试参数如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/08.jpg" alt></p></li></ul><h1 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h1><p> Apache JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测 试但后来扩展到其他测试领域。 它可以用于测试静态和动态资源例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、 数据库， FTP 服务器， 等等。JMeter 可以用于对服务器、网络或对象模拟巨大的负载，来在不同压力类别下测试它们的 强度和分析整体性能。另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果</p><blockquote><p>download:<a href="https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/</a></p></blockquote><p><em>解压完毕在bin目录下执行jmeter.bat会启动如下界面</em><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/09.jpg" alt></p><blockquote><p>新建一个线程组</p></blockquote><ul><li><p>线程组配置<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/10.jpg" alt></p></li><li><p>创建测试请求和查询结果<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/11.jpg" alt></p></li></ul><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/12.jpg" alt></p><h1 id="代码并发模拟"><a href="#代码并发模拟" class="headerlink" title="代码并发模拟"></a>代码并发模拟</h1><ul><li>CountDownLatch<br>计数器不断的向下减<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/13.jpg" alt></li></ul><blockquote><p>该类可阻塞线程，并保证线程在满足特定的情况下继续执行</p></blockquote><ul><li>Semaphore<br>字面意思为”信号量”<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/concurrent/14.jpg" alt></li></ul><blockquote><p>该类可阻塞进程，并且控制同一时间的请求并发量</p></blockquote><p>如果我们想模拟并发测试的时，并在所有线程执行完输出执行结果，应该结合上诉两个类来完成。</p><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>不做同步的情况下，该结果是不一致的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;postman&quot;&gt;&lt;a href=&quot;#postman&quot; class=&quot;headerlink&quot; title=&quot;postman&quot;&gt;&lt;/a&gt;postman&lt;/h1&gt;&lt;p&gt;Postman 是一个很强大的 API调试、Http请求的工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将测试
      
    
    </summary>
    
      <category term="Java并发系列文章" scheme="http://yoursite.com/categories/Java%E5%B9%B6%E5%8F%91%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>创建高性能的索引</title>
    <link href="http://yoursite.com/2019/04/20/mysql/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/04/20/mysql/创建高性能的索引/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-21T08:07:49.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第五章 创建高性能的索引</em><br>索引在MySQL中也称为key，它是存储引擎用于快速找到记录的一种数据结构。索引能够轻易将查询性能提高几个数量级</p><h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>存储引擎是如何使用索引的？ 首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。也就是说，如果某个列建立了索引，那么会先在索引中查找。</p><ul><li>可创建多个索引，如果多个列，那么顺序非常重要</li></ul><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p><img src="http://poporz7f8.bkt.clouddn.com/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.jpg" alt></p><p>索引在存储引擎层，因此不同的存储引擎对索引的工作方式也不一样，并不是所有的存储引擎都支持所有类型的索引</p><p><strong>B-Tree索引</strong></p><blockquote><p>术语B-Tree是因为MySQL在create table和其他语句中也使用该关键字<br></p></blockquote><p>内部算法实际使用B+Tree实现，InnoDB使用B+Tree，NDB集群使用T-Tree来存储索引</p><ul><li>B-Tree与二叉树的形式存储索引，意味着所有的值都是顺序的，能够快速访问数据不需要进行全表扫描</li><li>B-Tree对索引是顺序组织存储，所以适合查找范围数据</li></ul><p><strong>哈希索引</strong><br>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效, 哈希索引会将所有的哈希码存储在索引中，同时在哈希表中存储每个数据行的指针</p><ul><li>在MySQL中，只有memory引擎支持哈希索引</li><li>如果要查询很多关联的表，哈希索引非常使用用于查询</li><li>InnoDB有一种特殊的功能 <em>自适应哈希索引</em> 如果它注意到某些索引使用频繁，内部会基于B-Tree之上创建哈希索引</li></ul><p><strong>创建自定义索引</strong><br>我们可模拟InnoDB一样创建函数, 虽然还是使用B-Tree进行查找，但是使用哈希值来查询<br><br><em>我们有如下表</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hash_test(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">  <span class="keyword">url</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">  url_crc <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>例如url存储”<a href="http://www.mysql.com&quot;" target="_blank" rel="noopener">http://www.mysql.com&quot;</a>, 我们进行如下查询效率是非常低的，使用的是全表扫描<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span>;</span><br></pre></td></tr></table></figure></p><p>因此我们在上述表中添加了url_crc它用于存储URL的哈希值，通过哈希值来进行查询，效率是极高的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将值存储到url_crr列</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">crc32</span>(<span class="string">'http://www.mysql.com'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">url</span> <span class="keyword">FROM</span> hash_test <span class="keyword">WHERE</span> <span class="keyword">url</span> = <span class="string">'http://www.mysql.com'</span> <span class="keyword">AND</span> url_crc = <span class="keyword">crc32</span>(<span class="string">"http://www.mysql.com"</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p>上述过程的缺陷是需要手动设置哈希值，当然可使用触发器来完成。注意：哈希冲突问题，或可使用FNV64()哈希函数，冲突比CRC32()少</p></blockquote><p><strong>全文索引</strong><br>它查找的是文本中的关键词，而不是直接比较索引中的值。类似于搜索引擎做的事情</p><h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><ul><li>大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序和临时表</li><li>可将随机I/O变为顺序IO</li></ul><p><em>索引是最好的解决方案吗?</em><br>只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是最有效的</p><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><p>正确的创建和使用索引是实现高性能查询的基础</p><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p><em>不当的使用索引</em><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>如果查询总的列不是独立的，则MySQL不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>如果需要索引很长的字符串，这会导致索引变的大且慢。我们可采用<em>索引开始部分的字符</em>来提高索引效率。但是也会降低索引的选择性。指定是如果你使用部分字符，那么出现重复的值越高</p><ul><li>对于blob、text或很长的varcher类型的列必须采用前缀索引</li></ul><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>在多个列上建立独立的单列索引大部分情况下并不能提高性能，在MySQL5.0版本引入了”索引合并”的策略，一定程度上表上的多个单列索引来定位指定的行</p><ul><li>OR、AND、UNION以集合的方式会根据索引查询并不会进行全表扫描</li></ul><h2 id="选择合适的索引顺序"><a href="#选择合适的索引顺序" class="headerlink" title="选择合适的索引顺序"></a>选择合适的索引顺序</h2><p>在B-Tree索引中，意味着安装最左列进行排序，其次第二列</p><ul><li>将选择性最高的列放到索引最前列</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>InnoDB的聚簇索引在同一个结构中保存了B-Tree索引和数据行，它的优点有</p><ul><li>把相关数据保存在一起，例如实现电子邮箱时，可根据用户ID聚集数据获取全部邮件</li><li>数据访问更快，聚簇索引将索引和数据存储在一个B-Tree中</li></ul><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>MySQL可直接获取列的数据，这样就不再需要读取数据行, 如果一个索引包含所有需要查询的字段的值，称为覆盖索引</p><ul><li>覆盖索引必须要存储索引的值，并不是所有的存储引擎都支持覆盖索引</li></ul><h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><ul><li>MySQL有两种方式生成有序的结果，排序、按索引顺序扫描 <em>可使用explain select table 查看tyep值 如果为index则使用了索引扫描来做排序</em></li></ul><h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中</p><ul><li>可以在create table语句中指定pack_keys参数来控制压缩索引的方式</li></ul><h2 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h2><p>如果在相同列上创建多个索引, 那么MySQL需要单独维护重复的索引，这会影响性能</p><ul><li>未使用的索引考虑删除</li></ul><h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行，如果你的查询从不访问那些不需要的行，那么就会锁定更少的行</p><ul><li>InnoDB行锁效率高，只有在访问行的时候才会对其加锁</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>如果列中建立了索引，存储引擎会根据索引快速查询到记录。</li><li>InnoDB使用B-Tree索引，所有中都是顺序的，避免了全表扫描。哈希索引只有memory</li><li>可以使用CRC32(‘url’)获取哈希值，可通过哈希值来查询较长的字符串如URL地址，不要使用SHA1()和MD5()作为哈希函数</li><li>编写查询语句时尽可能选择合适的索引以避免单行查找，尽可能使用数据原生顺序从而避免而外的排序操作，尽可能使用索引覆盖查询</li><li>不要因”应该为where子句中出现的所有列创建索引”所谓的经验法来创建索引，而是要应该根找出消耗最长时间的查询来创建合适的索引</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第五章 创建高性能的索引&lt;/em&gt;&lt;br&gt;索引在MySQL中也称为k
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Schema与数据类型优化</title>
    <link href="http://yoursite.com/2019/04/19/mysql/Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/04/19/mysql/Schema与数据类型优化/</id>
    <published>2019-04-19T08:39:23.000Z</published>
    <updated>2019-04-19T10:29:36.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h1><p><em>本章节来自 <strong>高性能MySQL</strong> 第四章 Schema与数据类型优化</em> <br></p><blockquote><p>选择正确的数据类型对于获得高性能至关重要</p></blockquote><ul><li>更小的通常更好，尽量使用存储数据的最小数据类型</li><li>简单就好，例如整形比字符操作更快，而不是使用字符存储时间</li><li>尽量避免NULL，通常情况下最好将列指定为NOT NULL</li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>存储整数可使用：tinyint、smallint、mediumint、int、bigint<br>。分别使用8、16、24、32、64位存储空间</p><ul><li>整数类型有可选的unsigend属性，表示不允许负值</li><li>整数计算通常使用bigint</li></ul><h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><p>实数是带有小数部分的数字</p><ul><li>float（4字节）和double（8字节）支持浮点运算</li><li>decimal用于存储精确的小数, 因为decimal只是一种存储格式，在计算中会转换为double</li><li>只在对小数进行精确计算时才使用decimal，例如财务数据</li></ul><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>不同的存储引擎存储字符的方式可能不同</p><ul><li>varchar存储可边长字符串，仅使用必要的空间</li><li>char类型是定长的，适合存储更短的字符串。当存储char值时，MySQL会删除所有的末尾空格</li><li>binary和varbinary用于存储二进制字符串，存储的是字节码而不是字符</li><li>blob和text：存储大数据而设计的字符串类型。前者为二进制，后者为字符串。它们与其他类型不同，存储引擎会做特殊处理，如果值太大，InnoDB会使用专门的”外部”存储区域进行存储</li><li>使用枚举类型存储字符串，与数字-字符串映射关系查找表</li></ul><h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><p>MySQL能存储的最小时间颗粒度为秒，MariaDB支持微妙级别的时间类型，<em>可使用bigint存储微秒级别的时间戳</em></p><ul><li>datetime: 可保存大范围的值，1001年-9999年，精度为秒。8字节存储</li><li>timestamp: 保存了从1970-1-1午夜（格林尼治标准时间）以来的秒数, 使用4字节存储。</li></ul><h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型</p><ul><li>bit：bit(1)定义一个包含单个位的字段, 存储一个或多个true/false</li><li>set: 存储很多个true/false，以集合的形式来表示</li></ul><h2 id="选择标识符"><a href="#选择标识符" class="headerlink" title="选择标识符"></a>选择标识符</h2><p>整数通常是标识列最好的选择，enum和set只适合标记固定的值，如人的性别、产品类型等，尽量避免字符串类型作为标识列，因为消耗空间<br><br>随机字符如UUID存储会导致insert、select语句变慢。插入会随机写到索引不同位置，查询逻辑上相邻的行为分布在磁盘和内存分布在不同的位置。</p><ul><li>如果存储UUID，移出’-‘，使用unhex()函数转换位16字节数字，存储在binary(16)。检索使用hex()函数格式化位十六进制的格式</li></ul><h1 id="schema设计中的陷阱"><a href="#schema设计中的陷阱" class="headerlink" title="schema设计中的陷阱"></a>schema设计中的陷阱</h1><ul><li>太多的列</li><li>太多的表关联，MySQL限制每个关联操作最多61张表。如果希望查询效率更高，单个查询最好在12个表以内做关联</li><li>防止过度的使用enum</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择优化的数据类型&quot;&gt;&lt;a href=&quot;#选择优化的数据类型&quot; class=&quot;headerlink&quot; title=&quot;选择优化的数据类型&quot;&gt;&lt;/a&gt;选择优化的数据类型&lt;/h1&gt;&lt;p&gt;&lt;em&gt;本章节来自 &lt;strong&gt;高性能MySQL&lt;/strong&gt; 第四章 Sc
      
    
    </summary>
    
      <category term="高性能MySQL读书笔记" scheme="http://yoursite.com/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper分布式锁原理</title>
    <link href="http://yoursite.com/2019/04/19/zookeeper/zookeeper%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/19/zookeeper/zookeeper分布式锁原理/</id>
    <published>2019-04-18T16:06:16.000Z</published>
    <updated>2019-04-25T07:52:04.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁-活锁概念"><a href="#死锁-活锁概念" class="headerlink" title="死锁 | 活锁概念"></a>死锁 | 活锁概念</h1><p><strong>死锁</strong></p><ul><li>如果有两个服务订单服务和商品服务，订单服务需要读取库存操作, 商品服务也需要读取库存操作(图1)</li><li>此时订单服务读取完库存之后并没有释放(没有提交)。当商品服务再次读取时，库存数据可能会不一致（脏读）。通常这种情况采用<em>死锁</em></li><li>解决：在订单服务访问库存的时候，无论crud操作都加一把锁(未释放)。那么商品服务就不能访问库存了(图2)</li></ul><p><em>图1</em></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/05.jpg" alt></p><p><em>图2</em></p><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/06.jpg" alt></p><p><em>活锁</em><br>无论多少个服务，只对库存进行<strong>读取的操作</strong> 那么其他服务都可以去读取，否则都要进行加锁。这种情况成为<em>活锁</em></p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>在分布式环境下，当不同的服务访问某一个共享资源数据(数据库)的时候，可能会发生数据不一致的情况</p><p><em>下订单流程</em><br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/07.jpg" alt><br>如果在创建订单和扣除库存的操作没有完成（sleep），此时有其他请求进入时，那么库存的数量就可能会造成不一致(之前的值，因为sleep了)</p><h2 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h2><p><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/09.jpg" alt></p><ul><li>在获取锁的时候，要根据锁是否被占用才可获取。如果没有占用创建锁 <em>zk临时节点</em>。临时节点会根据客户端会话的断开而断开（释放锁）</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>什么是死锁：当A服务进行CRUD库存的时候，其他服务不可访问库存</li><li>什么是活锁：如果A服务只是进行读库存的操作，那么其他服务可访问库存</li><li>利用Zookeeper不能重复创建一个节点的特性来实现一个分布式锁，与redis很类似</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;死锁-活锁概念&quot;&gt;&lt;a href=&quot;#死锁-活锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁 | 活锁概念&quot;&gt;&lt;/a&gt;死锁 | 活锁概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有两个服务订单服务和商
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="死锁" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81/"/>
    
      <category term="活锁" scheme="http://yoursite.com/tags/%E6%B4%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper集群</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper集群/</id>
    <published>2019-04-18T06:08:54.000Z</published>
    <updated>2019-04-25T07:48:31.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper集群概述"><a href="#zookeeper集群概述" class="headerlink" title="zookeeper集群概述"></a>zookeeper集群概述</h1><p>zookeeper集群包含主从节点，心跳机制（选举模式），架构如下<br><img src="https://hexo-1258491682.cos.ap-guangzhou.myqcloud.com/zookeeper/04.jpg" alt></p><p><em>选举模式</em>: 如果上述图中的master宕机了, slave1和slave进行选举，只有其中一个为master。如果原来的master恢复了，那么会加入到集群中成为slave。集群个数建议为奇数因为需要选举的过程</p><h1 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h1><ul><li>配置数据文件 myid 1/2/3 对应 server.1/2/3</li><li>通过 ./zkCli.sh -server [ip]:[port] 检测集群是否配置成功</li></ul><p><em>拷贝3份zookeeper文件, 在第一份文件中的zoo.cfg配置如下信息</em><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个文件都需要加入该配置</span></span><br><span class="line"><span class="comment"># master节点ip | 数据同步的端口 | 选举端口</span></span><br><span class="line"><span class="string">server.1=192.168.211.136:2888:3888</span></span><br><span class="line"><span class="string">server.2=192.168.211.136:2889:3889</span></span><br><span class="line"><span class="string">server.3=192.168.211.136:2890:3890</span></span><br></pre></td></tr></table></figure></p><p><em>在dataDir数据源目录创建 myid 添加数字 1</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang dataDir]# vim myid</span><br><span class="line">[root@zhongjinlang dataDir]# ll</span><br><span class="line">总用量 8</span><br><span class="line">-rw-r--r--. 1 root root 2 4月  18 00:42 myid</span><br><span class="line">drwxr-xr-x. 2 root root 6 4月  18 00:32 version-2</span><br><span class="line">-rw-r--r--. 1 root root 4 4月  18 00:32 zookeeper_server.pid</span><br></pre></td></tr></table></figure></p><blockquote><p>其他文件修改端口 2182、2183和创建myid即可</p></blockquote><p><em>分别启动 ./zkServer.sh start 并在2181中set一个节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] create /data 123 </span><br><span class="line">Created /data</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /</span><br><span class="line">[zookeeper, data]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出当前连接，连接2182</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] [root@zhongjinlang bin]# ./zkCli.sh -server </span><br><span class="line">localhost:2182</span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时发现从节点2182有了master的数据（2183也有）</span></span><br><span class="line">[zk: localhost:2182(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper, data]</span><br></pre></td></tr></table></figure></p><h2 id="查看集群状态"><a href="#查看集群状态" class="headerlink" title="查看集群状态"></a>查看集群状态</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower # 从节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Mode: leader # 主节点</span><br><span class="line"></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: follower # 从节点</span><br></pre></td></tr></table></figure><h2 id="选举模式实验"><a href="#选举模式实验" class="headerlink" title="选举模式实验"></a>选举模式实验</h2><p>上述可看出2182为主节点，我们将2182进程kill，观察谁会成为主节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此时已经连接不了2182</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2182</span><br><span class="line">Ncat: Connection refused.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分别连接其他节点</span></span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2181</span><br><span class="line">Mode: follower</span><br><span class="line">[root@zhongjinlang bin]# echo stat | nc localhost 2183</span><br><span class="line">Mode: leader # 2183成为了主节点</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper集群包含主从节点、心跳机制。当主节点挂了，经过选举会将某一个从节点成为主节点，来保证整体服务的高可用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper集群概述&quot;&gt;&lt;a href=&quot;#zookeeper集群概述&quot; class=&quot;headerlink&quot; title=&quot;zookeeper集群概述&quot;&gt;&lt;/a&gt;zookeeper集群概述&lt;/h1&gt;&lt;p&gt;zookeeper集群包含主从节点，心跳机制（选举模
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeperACL权限控制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeperACL%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeperACL权限控制/</id>
    <published>2019-04-17T17:12:12.000Z</published>
    <updated>2019-04-18T17:12:54.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为ACL-access-control-lists"><a href="#何为ACL-access-control-lists" class="headerlink" title="何为ACL(access control lists)?"></a>何为ACL(access control lists)?</h1><p>可以对节点设置读写等权限，来保障数据的安全性，权限permission可以指定不同的范围以及角色<br></p><h1 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h1><ul><li>getAcl：获取某个节点的权限信息</li><li>setAcl：设置某个节点的权限</li><li>addauth： 输入认证授权信息，注册用户将用户根据指定的权限才可登入</li></ul><h2 id="ACL的构成一"><a href="#ACL的构成一" class="headerlink" title="ACL的构成一"></a>ACL的构成一</h2><ul><li><p>zookeeper的ACL通过[scheme:id:permission]来构成权限列表</p><blockquote><p>scheme: 代表采用的某种全新机制</p></blockquote><blockquote><p>id: 代表允许访问的用户</p></blockquote><blockquote><p>permission: 权限组合字符串</p></blockquote></li></ul><h2 id="ACL的构成二-scheme"><a href="#ACL的构成二-scheme" class="headerlink" title="ACL的构成二 - scheme"></a>ACL的构成二 - scheme</h2><ul><li><p>world：只有一个用户, 语法: world:anyone:[permission] 默认情况下它表示任何人都可访问这一节点</p></li><li><p>auth：认证登入，需要注册用户且有权限。语法：auth:user:password:[permission]</p></li><li><p>digest：需要对密码进行加密才可访问，语法：digest：username:BASE64(SHA1(password)):[permission]</p></li><li><p>ip: 可限制某个ip的访问，语法：ip:192.168.1.1:[permission]</p></li><li><p>super: 代表超级管理员，拥有所有权限</p></li></ul><h2 id="ACL的构成三-permission"><a href="#ACL的构成三-permission" class="headerlink" title="ACL的构成三 - permission"></a>ACL的构成三 - permission</h2><p>权限字符串使用缩写 crdwa，分别表示：</p><ul><li>c: create创建子节点。表示设置了改权限才可进行创建子节点</li><li>r: read获取节点/子节点列表的权限 </li><li>d: delete删除子节点权限</li><li>w: write写节点数据权限</li><li>a: admin权限才可分配permission</li></ul><h1 id="ACL实战"><a href="#ACL实战" class="headerlink" title="ACL实战"></a>ACL实战</h1><h2 id="world"><a href="#world" class="headerlink" title="world"></a>world</h2><p><em>创建一个节点并查看默认的权限</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /imooc/abc data </span><br><span class="line">Created /imooc/abc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] getAcl /imooc/abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拥有所有权限</span></span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br></pre></td></tr></table></figure></p><p><em>设置权限：禁止删除</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 20] setAcl /imooc/abc world:anyone:crwa</span><br></pre></td></tr></table></figure></p><p><em>此时节点的权限、后新创建一个节点再进行删除测试（因为当前节点拥有之前的权限）</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 21] getAcl /imooc/abc</span><br><span class="line">'world,'anyone</span><br><span class="line">: crwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] create /imooc/abc/xyz new-data-isnotdelete </span><br><span class="line">Created /imooc/abc/xyz</span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] delete /imooc/abc/xyz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提示权限不足</span></span><br><span class="line">Authentication is not valid : /imooc/abc/xyz</span><br></pre></td></tr></table></figure></p><h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h2><p>明文登入<br><em>注册账号并登入</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 39] create /name/zhangsan zs </span><br><span class="line">Created /name/zhangsan</span><br><span class="line">[zk: localhost:2181(CONNECTED) 40] getAcl /name/zhangsan</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"><span class="meta">#</span><span class="bash"> 登入提示没有这个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 41] setAcl /name/zhangsan auth:zhangsan:123:cdrwa     </span><br><span class="line">Acl is not valid : /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注册一个用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 42] addauth digest zhangsan:zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次登入</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 43] setAcl /name/zhangsan auth:zhangsan:123:cdrwa</span><br></pre></td></tr></table></figure></p><p><em>此时权限信息</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 44] getAcl /name/zhangsan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 密码存在数据库中是一个密文</span></span><br><span class="line">'digest,'zhangsan:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdrwa</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># digest</span></span></span><br><span class="line">使用密文方式登入</span><br><span class="line"></span><br><span class="line">*创建新的节点 并设置登入账号以及密码*</span><br><span class="line">```shell</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] getAcl /name/lisi</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置密码（密文）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] setAcl /name/lisi digest:lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=:cdra</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] getAcl /name/lisi</span><br><span class="line">'digest,'lisi:7Tjni+rxBvYp1MDxthriuVT77Gw=</span><br><span class="line">: cdra</span><br></pre></td></tr></table></figure></p><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>控制某个网段是否有权限来访问目录节点，通常用于控制客户端</p><p><em>创建一个新的节点</em><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 19] create /name/ip ip</span><br><span class="line">Created /name/ip</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] getAcl /name/ip</span><br><span class="line">'world,'anyone</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置权限</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 21] setAcl /name/ip ip:192.168.117.1:cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 22] getAcl /name/ip</span><br><span class="line">'ip,'192.168.117.1</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此时虚拟机不可访问</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] get /name/ip</span><br><span class="line">Authentication is not valid : /name/ip</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>zookeeper的ACL可对节点进行权限控制来保障数据安全性</li><li>world：默认所有用户登入</li><li>auth：注册用户登入，注册密码时为明文</li><li>digest：注册用户登入，注册密码时为密文</li><li>ip: 可限制网段访问</li><li>super: 可访问所有权限</li><li>ACL使用场景一：开发/测试环境分离，开发者无权操作测试库的节点，只能看</li><li>ACL使用场景二：生产环境上控制指定IP的服务可以访问相关节点，防止混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为ACL-access-control-lists&quot;&gt;&lt;a href=&quot;#何为ACL-access-control-lists&quot; class=&quot;headerlink&quot; title=&quot;何为ACL(access control lists)?&quot;&gt;&lt;/a&gt;何为ACL(
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper的watch机制</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E7%9A%84watch%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper的watch机制/</id>
    <published>2019-04-17T16:11:33.000Z</published>
    <updated>2019-04-18T17:12:36.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为watch"><a href="#何为watch" class="headerlink" title="何为watch?"></a>何为watch?</h1><p>针对每个节点的操作，都会有一个监督者<strong>watch</strong>。当节点发现变化时，如create、set、delete都会触发一个watch事件。<br><br>zookeeper中的watch是一次性的，<em>触发后立即销毁</em>。注意是在zookeeper中</p><ul><li><p>父节点，子节点增删改都会触发watch</p></li><li><p>针对不同类型的操作，触发的watch事件不同：如节点创建事件、节点删除事件、节点数据变化事件</p></li></ul><h1 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h1><h2 id="父节点watch事件"><a href="#父节点watch事件" class="headerlink" title="父节点watch事件"></a>父节点watch事件</h2><ul><li>创建父节点触发: NodeCreated</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先设置一个事件（<span class="built_in">set</span> get都可以 使用<span class="built_in">help</span>查看）</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] stat /imooc watch  </span><br><span class="line">Node does not exist: /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc 123</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 触发了事件</span></span><br><span class="line">watch::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeCreated path:/imooc</span><br><span class="line">Created /imooc</span><br></pre></td></tr></table></figure><ul><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li></ul><h2 id="子节点watch事件"><a href="#子节点watch事件" class="headerlink" title="子节点watch事件"></a>子节点watch事件</h2><p>ls为父节点设置watch</p><ul><li>创建子节点触发：NodeChildrenChanged<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /imooc</span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] ls /imooc watch </span><br><span class="line">[]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] create /imooc/abc 88 </span><br><span class="line">Created /imooc/abc</span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/imooc</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>触发了NodeChildrenChanged</p></blockquote><ul><li>删除子节点也是触发：NodeChildrenChanged</li><li><p>修改子节点不会触发事件</p></li><li><p>TODO：增加和删除触发的事件为什么一样：因为它们为子节点，子节点和父节点需要进行区分，父节点有不同的事件，对于父节点来说不需要关注子节点的事件。因为父节点只需要告诉客户端 哦我的子节点改变了NodeChildrenChanged事件</p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>watcher使用场景：在集群环境下，如果某个节点发生了变化，例如配置文件的变化，我们可通过watcher监听获取到数据，并将其同步到其他分布式的节点中，达到数据的一致性</li><li>zookeeper节点（子父）发生变化时，会触发watch事件，并且出发后立即销毁（在zookeeper中)不同的类型操作watch事件也不同（增、删、改）</li><li>在修改节点数据之前可设置watch，如果下次获取该节点时会触发不同的watch类似</li><li>父节点触发watch事件有： NodeCreated（增）、NodeDeleted（删）、NodeDataChanged（改）</li><li>子节点触发watch事件有:  NodeChildrenChanged（增删）、修改不会触发事件因为对于父节点来说并不关心</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;何为watch&quot;&gt;&lt;a href=&quot;#何为watch&quot; class=&quot;headerlink&quot; title=&quot;何为watch?&quot;&gt;&lt;/a&gt;何为watch?&lt;/h1&gt;&lt;p&gt;针对每个节点的操作，都会有一个监督者&lt;strong&gt;watch&lt;/strong&gt;。当节点发现变化
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper命令使用</title>
    <link href="http://yoursite.com/2019/04/18/zookeeper/zookeeper%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/18/zookeeper/zookeeper命令使用/</id>
    <published>2019-04-17T16:10:33.000Z</published>
    <updated>2019-04-18T17:12:48.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>通过 ./zkCli.sh打开客户端进行命令行后台操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang bin]# zkCli.sh</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="ls-ls2"><a href="#ls-ls2" class="headerlink" title="ls | ls2"></a>ls | ls2</h2><p><strong>查看zookeeper路径</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] ls /</span><br><span class="line">[zookeeper]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p><strong>查看状态信息</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls2 /</span><br><span class="line">[zookeeper]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建了之后，zk为这个节点所分配的ID</span></span><br><span class="line">cZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> create-time</span></span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后zk的ID</span></span><br><span class="line">mZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改后节点的时间</span></span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点ID</span></span><br><span class="line">pZxid = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点发生变化后的version值</span></span><br><span class="line">cversion = -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点数据的version，修改后累加1</span></span><br><span class="line">dataVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 权限</span></span><br><span class="line">aclVersion = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 子节点个数（ls /）</span></span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure></p><h2 id="get-stat"><a href="#get-stat" class="headerlink" title="get | stat"></a>get | stat</h2><ul><li><p>stat命令：ls2 = ls + stat</p></li><li><p>get：取出当前节点数据，如果没有数据，与上述内容一至</p></li></ul><h1 id="节点操作命令"><a href="#节点操作命令" class="headerlink" title="节点操作命令"></a>节点操作命令</h1><p>讲述该节内容前，我们先阐述session的基本原理：</p><ul><li>客户端与服务端之间的连接存在会话</li><li>每个会话都可设置一个超时时间（30分钟不操作session失效）：心跳结束，则session过期</li><li>session过期，临时节点znode会被抛弃</li><li>心跳机制： 客户端向服务端的ping包请求</li></ul><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><ul><li><p>创建默认节点节点（持久化节点）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 11] create /imooc immoc-data </span><br><span class="line">Created /imooc</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] get /immoc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前节点的持久化数据</span></span><br><span class="line">immoc-data</span><br><span class="line">..</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据长度</span></span><br><span class="line">dataLength = 10</span><br></pre></td></tr></table></figure></li><li><p>创建节点后目录为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /     </span><br><span class="line">[zookeeper, imooc]</span><br></pre></td></tr></table></figure></li><li><p>创建临时节点: create -e /imooc/tmp immoc-data</p></li><li><p>创建顺序节点: 每个节点后缀都会增加数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 5] create -s /imooc/sec seq </span><br><span class="line">Created /imooc/sec0000000001</span><br><span class="line">[zk: localhost:2181(CONNECTED) 6] create -s /imooc/sec seq</span><br><span class="line">Created /imooc/sec0000000002</span><br></pre></td></tr></table></figure></li></ul><h2 id="set-delete"><a href="#set-delete" class="headerlink" title="set | delete"></a>set | delete</h2><ul><li><p>set path data [version]：修改节点如果默认不设置版本号，直接删除。加上版本号可实现乐观锁(只能修改最新的数据)</p></li><li><p>delete path [version]: 直接删除节点, 加上版本号只能删除最新数据</p></li></ul><h1 id="四字命令-four-letter-words"><a href="#四字命令-four-letter-words" class="headerlink" title="四字命令 four letter words"></a>四字命令 four letter words</h1><p>zookeeper可通过它自身提供的简写命令来和服务器进行交互, 可查看服务器的一些状态信息。使用运维来进行监控</p><ul><li>需要使用nc命令，安装yum install nc</li><li>语法： echo [commod] | nc [ip] [port]</li></ul><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>它可查看zookeeper的状态信息，以及是否mode（集群还是单机）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo stat | nc 192.168.211.136 2181</span><br><span class="line">Zookeeper version: 3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">Clients:</span><br><span class="line"> /192.168.211.136:34346[0](queued=0,recved=1,sent=0)</span><br><span class="line"></span><br><span class="line">Latency min/avg/max: 0/0/27</span><br><span class="line">Received: 2696</span><br><span class="line">Sent: 2701</span><br><span class="line">Connections: 1</span><br><span class="line">Outstanding: 0</span><br><span class="line">Zxid: 0x45</span><br><span class="line">Mode: standalone</span><br><span class="line">Node count: 8</span><br></pre></td></tr></table></figure><h2 id="ruok"><a href="#ruok" class="headerlink" title="ruok"></a>ruok</h2><p>查看当前zk服务是否启动，启动返回imok</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo ruok | nc localhost 2181</span><br><span class="line">imok[root@zhongjinlang /]#</span><br></pre></td></tr></table></figure><h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><p>列出未经处理的会话和临时节点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo dump | nc localhost 2181</span><br><span class="line">SessionTracker dump:</span><br><span class="line">Session Sets (0):</span><br><span class="line">ephemeral nodes dump:</span><br><span class="line">Sessions with Ephemerals (0):</span><br></pre></td></tr></table></figure><h2 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h2><p>查看服务器配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo conf | nc localhost 2181</span><br><span class="line">clientPort=2181</span><br><span class="line">dataDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataDir/version-2</span><br><span class="line">dataLogDir=/usr/local/server/zookeeper/zookeeper-3.4.11/bin/../dataLogDir/version-2</span><br><span class="line">tickTime=2000</span><br><span class="line">maxClientCnxns=60</span><br><span class="line">minSessionTimeout=4000</span><br><span class="line">maxSessionTimeout=40000</span><br><span class="line">serverId=0</span><br></pre></td></tr></table></figure><h2 id="cons"><a href="#cons" class="headerlink" title="cons"></a>cons</h2><p>展示连接到服务器的客户端信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo cons | nc localhost 2181</span><br><span class="line"> /0:0:0:0:0:0:0:1:47224[0](queued=0,recved=1,sent=0)</span><br></pre></td></tr></table></figure><h2 id="mntr"><a href="#mntr" class="headerlink" title="mntr"></a>mntr</h2><p>监控zookeeper的健康信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo mntr | nc localhost 2181</span><br><span class="line">zk_version3.4.11-37e277162d567b55a07d1755f0b31c32e93c01a0, built on 11/01/2017 18:06 GMT</span><br><span class="line">zk_avg_latency0</span><br><span class="line">zk_max_latency27</span><br><span class="line">zk_min_latency0</span><br><span class="line">zk_packets_received2703</span><br><span class="line">zk_packets_sent2708</span><br><span class="line">zk_num_alive_connections1</span><br><span class="line">zk_outstanding_requests0</span><br><span class="line">zk_server_statestandalone</span><br><span class="line">zk_znode_count8</span><br><span class="line">zk_watch_count0</span><br><span class="line">zk_ephemerals_count0</span><br><span class="line">zk_approximate_data_size85</span><br><span class="line">zk_open_file_descriptor_count30</span><br><span class="line">zk_max_file_descriptor_count4096</span><br></pre></td></tr></table></figure><h2 id="wchs"><a href="#wchs" class="headerlink" title="wchs"></a>wchs</h2><p>展示watch信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zhongjinlang /]# echo wchs | nc localhost 2181</span><br><span class="line">0 connections watching 0 paths</span><br><span class="line">Total watches:0</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>ls / 查看zk目录</li><li>ls2 / 查看节点信息</li><li>get / 取出当前节点信息</li><li>zookeeper存储了节点的各种状态，如数据的大小、修改时间等</li><li>ephemeralOwner = 0x0属性如果为0x0那么为临时节点，否则为持久节点（后面是一串数据）。临时节点在断开连接后消失（10秒左右延迟 - 心跳机制）</li><li>create path data创建持久化节点</li><li>set path data [version]修改节点</li><li>delete path data [version]删除节点</li><li>使用set和delete时候，建议根据version删除，可达到<em>乐观锁的</em>效果，不会删除到之前旧的数据</li><li>zookeeper提供四字命令可查看服务器的一些状态信息，语法：echo [命令] | nc [ip] [port]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;通过 ./zkCli.sh打开客户端进行命令行后台操作&lt;figure class=&quot;highlight shel
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://yoursite.com/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
      <category term="乐观锁" scheme="http://yoursite.com/tags/%E4%B9%90%E8%A7%82%E9%94%81/"/>
    
  </entry>
  
</feed>
